type Access {
  id: UUID!
  read: Boolean!
  write: Boolean!
  delete: Boolean!
}

type AccessConnection {
  pageInfo: PageInfo!
  edges: [AccessEdge]!
  aggregate: AggregateAccess!
}

input AccessCreateInput {
  id: UUID
  read: Boolean
  write: Boolean
  delete: Boolean
}

input AccessCreateOneInput {
  create: AccessCreateInput
  connect: AccessWhereUniqueInput
}

type AccessEdge {
  node: Access!
  cursor: String!
}

enum AccessOrderByInput {
  id_ASC
  id_DESC
  read_ASC
  read_DESC
  write_ASC
  write_DESC
  delete_ASC
  delete_DESC
}

type AccessPreviousValues {
  id: UUID!
  read: Boolean!
  write: Boolean!
  delete: Boolean!
}

type AccessSubscriptionPayload {
  mutation: MutationType!
  node: Access
  updatedFields: [String!]
  previousValues: AccessPreviousValues
}

input AccessSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AccessWhereInput
  AND: [AccessSubscriptionWhereInput!]
  OR: [AccessSubscriptionWhereInput!]
  NOT: [AccessSubscriptionWhereInput!]
}

input AccessUpdateDataInput {
  read: Boolean
  write: Boolean
  delete: Boolean
}

input AccessUpdateInput {
  read: Boolean
  write: Boolean
  delete: Boolean
}

input AccessUpdateManyMutationInput {
  read: Boolean
  write: Boolean
  delete: Boolean
}

input AccessUpdateOneRequiredInput {
  create: AccessCreateInput
  update: AccessUpdateDataInput
  upsert: AccessUpsertNestedInput
  connect: AccessWhereUniqueInput
}

input AccessUpsertNestedInput {
  update: AccessUpdateDataInput!
  create: AccessCreateInput!
}

input AccessWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  read: Boolean
  read_not: Boolean
  write: Boolean
  write_not: Boolean
  delete: Boolean
  delete_not: Boolean
  AND: [AccessWhereInput!]
  OR: [AccessWhereInput!]
  NOT: [AccessWhereInput!]
}

input AccessWhereUniqueInput {
  id: UUID
}

type Admin {
  id: UUID!
  name: String!
  domain: String!
  public: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  menu(where: PageWhereInput, orderBy: PageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Page!]
  creator: User!
  meta: Json
}

type AdminConnection {
  pageInfo: PageInfo!
  edges: [AdminEdge]!
  aggregate: AggregateAdmin!
}

input AdminCreateInput {
  id: UUID
  name: String!
  domain: String!
  public: Boolean
  menu: PageCreateManyInput
  creator: UserCreateOneInput!
  meta: Json
}

type AdminEdge {
  node: Admin!
  cursor: String!
}

enum AdminOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  domain_ASC
  domain_DESC
  public_ASC
  public_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  meta_ASC
  meta_DESC
}

type AdminPreviousValues {
  id: UUID!
  name: String!
  domain: String!
  public: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  meta: Json
}

type AdminSubscriptionPayload {
  mutation: MutationType!
  node: Admin
  updatedFields: [String!]
  previousValues: AdminPreviousValues
}

input AdminSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AdminWhereInput
  AND: [AdminSubscriptionWhereInput!]
  OR: [AdminSubscriptionWhereInput!]
  NOT: [AdminSubscriptionWhereInput!]
}

input AdminUpdateInput {
  name: String
  domain: String
  public: Boolean
  menu: PageUpdateManyInput
  creator: UserUpdateOneRequiredInput
  meta: Json
}

input AdminUpdateManyMutationInput {
  name: String
  domain: String
  public: Boolean
  meta: Json
}

input AdminWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  domain: String
  domain_not: String
  domain_in: [String!]
  domain_not_in: [String!]
  domain_lt: String
  domain_lte: String
  domain_gt: String
  domain_gte: String
  domain_contains: String
  domain_not_contains: String
  domain_starts_with: String
  domain_not_starts_with: String
  domain_ends_with: String
  domain_not_ends_with: String
  public: Boolean
  public_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  menu_every: PageWhereInput
  menu_some: PageWhereInput
  menu_none: PageWhereInput
  creator: UserWhereInput
  AND: [AdminWhereInput!]
  OR: [AdminWhereInput!]
  NOT: [AdminWhereInput!]
}

input AdminWhereUniqueInput {
  id: UUID
  name: String
}

type AggregateAccess {
  count: Int!
}

type AggregateAdmin {
  count: Int!
}

type AggregateEntity {
  count: Int!
}

type AggregateEvent {
  count: Int!
}

type AggregateFile {
  count: Int!
}

type AggregateGroup {
  count: Int!
}

type Aggregatei18n {
  count: Int!
}

type AggregateImage {
  count: Int!
}

type AggregateItem {
  count: Int!
}

type AggregateLang {
  count: Int!
}

type AggregateLog {
  count: Int!
}

type AggregateMarkup {
  count: Int!
}

type AggregateMeasurement {
  count: Int!
}

type AggregateNews {
  count: Int!
}

type AggregateNote {
  count: Int!
}

type AggregatePage {
  count: Int!
}

type AggregatePageHead {
  count: Int!
}

type AggregatePageMeta {
  count: Int!
}

type AggregateParagraph {
  count: Int!
}

type AggregatePermission {
  count: Int!
}

type AggregatePermissionType {
  count: Int!
}

type AggregatePost {
  count: Int!
}

type AggregateProperty {
  count: Int!
}

type AggregateQuote {
  count: Int!
}

type AggregateReply {
  count: Int!
}

type AggregateSite {
  count: Int!
}

type AggregateStatement {
  count: Int!
}

type AggregateTag {
  count: Int!
}

type AggregateTheme {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type Entity {
  id: UUID!
  value: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  i18n(where: i18nWhereInput, orderBy: i18nOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [i18n!]
  reference: Item
  logs(where: LogWhereInput, orderBy: LogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Log!]
  meta: Json
}

type EntityConnection {
  pageInfo: PageInfo!
  edges: [EntityEdge]!
  aggregate: AggregateEntity!
}

input EntityCreateInput {
  id: UUID
  value: String!
  i18n: i18nCreateManyInput
  reference: ItemCreateOneInput
  logs: LogCreateManyInput
  meta: Json
}

input EntityCreateOneInput {
  create: EntityCreateInput
  connect: EntityWhereUniqueInput
}

type EntityEdge {
  node: Entity!
  cursor: String!
}

enum EntityOrderByInput {
  id_ASC
  id_DESC
  value_ASC
  value_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  meta_ASC
  meta_DESC
}

type EntityPreviousValues {
  id: UUID!
  value: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  meta: Json
}

type EntitySubscriptionPayload {
  mutation: MutationType!
  node: Entity
  updatedFields: [String!]
  previousValues: EntityPreviousValues
}

input EntitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EntityWhereInput
  AND: [EntitySubscriptionWhereInput!]
  OR: [EntitySubscriptionWhereInput!]
  NOT: [EntitySubscriptionWhereInput!]
}

input EntityUpdateDataInput {
  value: String
  i18n: i18nUpdateManyInput
  reference: ItemUpdateOneInput
  logs: LogUpdateManyInput
  meta: Json
}

input EntityUpdateInput {
  value: String
  i18n: i18nUpdateManyInput
  reference: ItemUpdateOneInput
  logs: LogUpdateManyInput
  meta: Json
}

input EntityUpdateManyMutationInput {
  value: String
  meta: Json
}

input EntityUpdateOneRequiredInput {
  create: EntityCreateInput
  update: EntityUpdateDataInput
  upsert: EntityUpsertNestedInput
  connect: EntityWhereUniqueInput
}

input EntityUpsertNestedInput {
  update: EntityUpdateDataInput!
  create: EntityCreateInput!
}

input EntityWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  i18n_every: i18nWhereInput
  i18n_some: i18nWhereInput
  i18n_none: i18nWhereInput
  reference: ItemWhereInput
  logs_every: LogWhereInput
  logs_some: LogWhereInput
  logs_none: LogWhereInput
  AND: [EntityWhereInput!]
  OR: [EntityWhereInput!]
  NOT: [EntityWhereInput!]
}

input EntityWhereUniqueInput {
  id: UUID
}

type Event {
  id: UUID!
  type: EventType!
  code: String
  result: String
  createdAt: DateTime!
  meta: Json
}

type EventConnection {
  pageInfo: PageInfo!
  edges: [EventEdge]!
  aggregate: AggregateEvent!
}

input EventCreateInput {
  id: UUID
  type: EventType
  code: String
  result: String
  meta: Json
}

input EventCreateOneInput {
  create: EventCreateInput
  connect: EventWhereUniqueInput
}

type EventEdge {
  node: Event!
  cursor: String!
}

enum EventOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  code_ASC
  code_DESC
  result_ASC
  result_DESC
  createdAt_ASC
  createdAt_DESC
  meta_ASC
  meta_DESC
}

type EventPreviousValues {
  id: UUID!
  type: EventType!
  code: String
  result: String
  createdAt: DateTime!
  meta: Json
}

type EventSubscriptionPayload {
  mutation: MutationType!
  node: Event
  updatedFields: [String!]
  previousValues: EventPreviousValues
}

input EventSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EventWhereInput
  AND: [EventSubscriptionWhereInput!]
  OR: [EventSubscriptionWhereInput!]
  NOT: [EventSubscriptionWhereInput!]
}

enum EventType {
  ERROR
  WARNING
  INFO
  LOG
}

input EventUpdateDataInput {
  type: EventType
  code: String
  result: String
  meta: Json
}

input EventUpdateInput {
  type: EventType
  code: String
  result: String
  meta: Json
}

input EventUpdateManyMutationInput {
  type: EventType
  code: String
  result: String
  meta: Json
}

input EventUpdateOneRequiredInput {
  create: EventCreateInput
  update: EventUpdateDataInput
  upsert: EventUpsertNestedInput
  connect: EventWhereUniqueInput
}

input EventUpsertNestedInput {
  update: EventUpdateDataInput!
  create: EventCreateInput!
}

input EventWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  type: EventType
  type_not: EventType
  type_in: [EventType!]
  type_not_in: [EventType!]
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  result: String
  result_not: String
  result_in: [String!]
  result_not_in: [String!]
  result_lt: String
  result_lte: String
  result_gt: String
  result_gte: String
  result_contains: String
  result_not_contains: String
  result_starts_with: String
  result_not_starts_with: String
  result_ends_with: String
  result_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [EventWhereInput!]
  OR: [EventWhereInput!]
  NOT: [EventWhereInput!]
}

input EventWhereUniqueInput {
  id: UUID
}

type File {
  id: UUID!
  name: String!
  path: String!
  size: Float!
  hidden: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  uploadBy: User!
  meta: Json
}

type FileConnection {
  pageInfo: PageInfo!
  edges: [FileEdge]!
  aggregate: AggregateFile!
}

input FileCreateInput {
  id: UUID
  name: String!
  path: String!
  size: Float
  hidden: Boolean
  uploadBy: UserCreateOneInput!
  meta: Json
}

input FileCreateOneInput {
  create: FileCreateInput
  connect: FileWhereUniqueInput
}

type FileEdge {
  node: File!
  cursor: String!
}

enum FileOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  path_ASC
  path_DESC
  size_ASC
  size_DESC
  hidden_ASC
  hidden_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  meta_ASC
  meta_DESC
}

type FilePreviousValues {
  id: UUID!
  name: String!
  path: String!
  size: Float!
  hidden: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  meta: Json
}

type FileSubscriptionPayload {
  mutation: MutationType!
  node: File
  updatedFields: [String!]
  previousValues: FilePreviousValues
}

input FileSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FileWhereInput
  AND: [FileSubscriptionWhereInput!]
  OR: [FileSubscriptionWhereInput!]
  NOT: [FileSubscriptionWhereInput!]
}

input FileUpdateDataInput {
  name: String
  path: String
  size: Float
  hidden: Boolean
  uploadBy: UserUpdateOneRequiredInput
  meta: Json
}

input FileUpdateInput {
  name: String
  path: String
  size: Float
  hidden: Boolean
  uploadBy: UserUpdateOneRequiredInput
  meta: Json
}

input FileUpdateManyMutationInput {
  name: String
  path: String
  size: Float
  hidden: Boolean
  meta: Json
}

input FileUpdateOneInput {
  create: FileCreateInput
  update: FileUpdateDataInput
  upsert: FileUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: FileWhereUniqueInput
}

input FileUpsertNestedInput {
  update: FileUpdateDataInput!
  create: FileCreateInput!
}

input FileWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  size: Float
  size_not: Float
  size_in: [Float!]
  size_not_in: [Float!]
  size_lt: Float
  size_lte: Float
  size_gt: Float
  size_gte: Float
  hidden: Boolean
  hidden_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  uploadBy: UserWhereInput
  AND: [FileWhereInput!]
  OR: [FileWhereInput!]
  NOT: [FileWhereInput!]
}

input FileWhereUniqueInput {
  id: UUID
}

type Group {
  id: UUID!
  name: String!
  description: String
  permission: Permission!
  meta: Json
}

type GroupConnection {
  pageInfo: PageInfo!
  edges: [GroupEdge]!
  aggregate: AggregateGroup!
}

input GroupCreateInput {
  id: UUID
  name: String!
  description: String
  permission: PermissionCreateOneInput!
  meta: Json
}

input GroupCreateOneInput {
  create: GroupCreateInput
  connect: GroupWhereUniqueInput
}

type GroupEdge {
  node: Group!
  cursor: String!
}

enum GroupOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  meta_ASC
  meta_DESC
}

type GroupPreviousValues {
  id: UUID!
  name: String!
  description: String
  meta: Json
}

type GroupSubscriptionPayload {
  mutation: MutationType!
  node: Group
  updatedFields: [String!]
  previousValues: GroupPreviousValues
}

input GroupSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GroupWhereInput
  AND: [GroupSubscriptionWhereInput!]
  OR: [GroupSubscriptionWhereInput!]
  NOT: [GroupSubscriptionWhereInput!]
}

input GroupUpdateDataInput {
  name: String
  description: String
  permission: PermissionUpdateOneRequiredInput
  meta: Json
}

input GroupUpdateInput {
  name: String
  description: String
  permission: PermissionUpdateOneRequiredInput
  meta: Json
}

input GroupUpdateManyMutationInput {
  name: String
  description: String
  meta: Json
}

input GroupUpdateOneRequiredInput {
  create: GroupCreateInput
  update: GroupUpdateDataInput
  upsert: GroupUpsertNestedInput
  connect: GroupWhereUniqueInput
}

input GroupUpsertNestedInput {
  update: GroupUpdateDataInput!
  create: GroupCreateInput!
}

input GroupWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  permission: PermissionWhereInput
  AND: [GroupWhereInput!]
  OR: [GroupWhereInput!]
  NOT: [GroupWhereInput!]
}

input GroupWhereUniqueInput {
  id: UUID
  name: String
}

type i18n {
  id: UUID!
  text: String
  lang: Lang!
  i18n(where: i18nWhereInput, orderBy: i18nOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [i18n!]
  meta: Json
}

type i18nConnection {
  pageInfo: PageInfo!
  edges: [i18nEdge]!
  aggregate: Aggregatei18n!
}

input i18nCreateInput {
  id: UUID
  text: String
  lang: LangCreateOneWithoutI18nInput!
  i18n: i18nCreateManyInput
  meta: Json
}

input i18nCreateManyInput {
  create: [i18nCreateInput!]
  connect: [i18nWhereUniqueInput!]
}

input i18nCreateManyWithoutLangInput {
  create: [i18nCreateWithoutLangInput!]
  connect: [i18nWhereUniqueInput!]
}

input i18nCreateWithoutLangInput {
  id: UUID
  text: String
  i18n: i18nCreateManyInput
  meta: Json
}

type i18nEdge {
  node: i18n!
  cursor: String!
}

enum i18nOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
  meta_ASC
  meta_DESC
}

type i18nPreviousValues {
  id: UUID!
  text: String
  meta: Json
}

input i18nScalarWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  AND: [i18nScalarWhereInput!]
  OR: [i18nScalarWhereInput!]
  NOT: [i18nScalarWhereInput!]
}

type i18nSubscriptionPayload {
  mutation: MutationType!
  node: i18n
  updatedFields: [String!]
  previousValues: i18nPreviousValues
}

input i18nSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: i18nWhereInput
  AND: [i18nSubscriptionWhereInput!]
  OR: [i18nSubscriptionWhereInput!]
  NOT: [i18nSubscriptionWhereInput!]
}

input i18nUpdateDataInput {
  text: String
  lang: LangUpdateOneRequiredWithoutI18nInput
  i18n: i18nUpdateManyInput
  meta: Json
}

input i18nUpdateInput {
  text: String
  lang: LangUpdateOneRequiredWithoutI18nInput
  i18n: i18nUpdateManyInput
  meta: Json
}

input i18nUpdateManyDataInput {
  text: String
  meta: Json
}

input i18nUpdateManyInput {
  create: [i18nCreateInput!]
  update: [i18nUpdateWithWhereUniqueNestedInput!]
  upsert: [i18nUpsertWithWhereUniqueNestedInput!]
  delete: [i18nWhereUniqueInput!]
  connect: [i18nWhereUniqueInput!]
  set: [i18nWhereUniqueInput!]
  disconnect: [i18nWhereUniqueInput!]
  deleteMany: [i18nScalarWhereInput!]
  updateMany: [i18nUpdateManyWithWhereNestedInput!]
}

input i18nUpdateManyMutationInput {
  text: String
  meta: Json
}

input i18nUpdateManyWithoutLangInput {
  create: [i18nCreateWithoutLangInput!]
  delete: [i18nWhereUniqueInput!]
  connect: [i18nWhereUniqueInput!]
  set: [i18nWhereUniqueInput!]
  disconnect: [i18nWhereUniqueInput!]
  update: [i18nUpdateWithWhereUniqueWithoutLangInput!]
  upsert: [i18nUpsertWithWhereUniqueWithoutLangInput!]
  deleteMany: [i18nScalarWhereInput!]
  updateMany: [i18nUpdateManyWithWhereNestedInput!]
}

input i18nUpdateManyWithWhereNestedInput {
  where: i18nScalarWhereInput!
  data: i18nUpdateManyDataInput!
}

input i18nUpdateWithoutLangDataInput {
  text: String
  i18n: i18nUpdateManyInput
  meta: Json
}

input i18nUpdateWithWhereUniqueNestedInput {
  where: i18nWhereUniqueInput!
  data: i18nUpdateDataInput!
}

input i18nUpdateWithWhereUniqueWithoutLangInput {
  where: i18nWhereUniqueInput!
  data: i18nUpdateWithoutLangDataInput!
}

input i18nUpsertWithWhereUniqueNestedInput {
  where: i18nWhereUniqueInput!
  update: i18nUpdateDataInput!
  create: i18nCreateInput!
}

input i18nUpsertWithWhereUniqueWithoutLangInput {
  where: i18nWhereUniqueInput!
  update: i18nUpdateWithoutLangDataInput!
  create: i18nCreateWithoutLangInput!
}

input i18nWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  lang: LangWhereInput
  i18n_every: i18nWhereInput
  i18n_some: i18nWhereInput
  i18n_none: i18nWhereInput
  AND: [i18nWhereInput!]
  OR: [i18nWhereInput!]
  NOT: [i18nWhereInput!]
}

input i18nWhereUniqueInput {
  id: UUID
}

type Image {
  id: UUID!
  name: String!
  description: String
  format: Measurement
  createdAt: DateTime!
  updatedAt: DateTime!
  file: File
  meta: Json
}

type ImageConnection {
  pageInfo: PageInfo!
  edges: [ImageEdge]!
  aggregate: AggregateImage!
}

input ImageCreateInput {
  id: UUID
  name: String!
  description: String
  format: MeasurementCreateOneInput
  file: FileCreateOneInput
  meta: Json
}

input ImageCreateManyInput {
  create: [ImageCreateInput!]
  connect: [ImageWhereUniqueInput!]
}

input ImageCreateOneInput {
  create: ImageCreateInput
  connect: ImageWhereUniqueInput
}

type ImageEdge {
  node: Image!
  cursor: String!
}

enum ImageOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  meta_ASC
  meta_DESC
}

type ImagePreviousValues {
  id: UUID!
  name: String!
  description: String
  createdAt: DateTime!
  updatedAt: DateTime!
  meta: Json
}

input ImageScalarWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ImageScalarWhereInput!]
  OR: [ImageScalarWhereInput!]
  NOT: [ImageScalarWhereInput!]
}

type ImageSubscriptionPayload {
  mutation: MutationType!
  node: Image
  updatedFields: [String!]
  previousValues: ImagePreviousValues
}

input ImageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ImageWhereInput
  AND: [ImageSubscriptionWhereInput!]
  OR: [ImageSubscriptionWhereInput!]
  NOT: [ImageSubscriptionWhereInput!]
}

input ImageUpdateDataInput {
  name: String
  description: String
  format: MeasurementUpdateOneInput
  file: FileUpdateOneInput
  meta: Json
}

input ImageUpdateInput {
  name: String
  description: String
  format: MeasurementUpdateOneInput
  file: FileUpdateOneInput
  meta: Json
}

input ImageUpdateManyDataInput {
  name: String
  description: String
  meta: Json
}

input ImageUpdateManyInput {
  create: [ImageCreateInput!]
  update: [ImageUpdateWithWhereUniqueNestedInput!]
  upsert: [ImageUpsertWithWhereUniqueNestedInput!]
  delete: [ImageWhereUniqueInput!]
  connect: [ImageWhereUniqueInput!]
  set: [ImageWhereUniqueInput!]
  disconnect: [ImageWhereUniqueInput!]
  deleteMany: [ImageScalarWhereInput!]
  updateMany: [ImageUpdateManyWithWhereNestedInput!]
}

input ImageUpdateManyMutationInput {
  name: String
  description: String
  meta: Json
}

input ImageUpdateManyWithWhereNestedInput {
  where: ImageScalarWhereInput!
  data: ImageUpdateManyDataInput!
}

input ImageUpdateOneInput {
  create: ImageCreateInput
  update: ImageUpdateDataInput
  upsert: ImageUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ImageWhereUniqueInput
}

input ImageUpdateWithWhereUniqueNestedInput {
  where: ImageWhereUniqueInput!
  data: ImageUpdateDataInput!
}

input ImageUpsertNestedInput {
  update: ImageUpdateDataInput!
  create: ImageCreateInput!
}

input ImageUpsertWithWhereUniqueNestedInput {
  where: ImageWhereUniqueInput!
  update: ImageUpdateDataInput!
  create: ImageCreateInput!
}

input ImageWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  format: MeasurementWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  file: FileWhereInput
  AND: [ImageWhereInput!]
  OR: [ImageWhereInput!]
  NOT: [ImageWhereInput!]
}

input ImageWhereUniqueInput {
  id: UUID
}

type Item {
  id: UUID!
  itemId: String!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  i18n(where: i18nWhereInput, orderBy: i18nOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [i18n!]
  images(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Image!]
  introduction(where: ParagraphWhereInput, orderBy: ParagraphOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Paragraph!]
  statements(where: StatementWhereInput, orderBy: StatementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Statement!]
  logs(where: LogWhereInput, orderBy: LogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Log!]
  creator: User!
  meta: Json
}

type ItemConnection {
  pageInfo: PageInfo!
  edges: [ItemEdge]!
  aggregate: AggregateItem!
}

input ItemCreateInput {
  id: UUID
  itemId: String!
  name: String!
  i18n: i18nCreateManyInput
  images: ImageCreateManyInput
  introduction: ParagraphCreateManyInput
  statements: StatementCreateManyInput
  logs: LogCreateManyInput
  creator: UserCreateOneInput!
  meta: Json
}

input ItemCreateOneInput {
  create: ItemCreateInput
  connect: ItemWhereUniqueInput
}

type ItemEdge {
  node: Item!
  cursor: String!
}

enum ItemOrderByInput {
  id_ASC
  id_DESC
  itemId_ASC
  itemId_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  meta_ASC
  meta_DESC
}

type ItemPreviousValues {
  id: UUID!
  itemId: String!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  meta: Json
}

type ItemSubscriptionPayload {
  mutation: MutationType!
  node: Item
  updatedFields: [String!]
  previousValues: ItemPreviousValues
}

input ItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ItemWhereInput
  AND: [ItemSubscriptionWhereInput!]
  OR: [ItemSubscriptionWhereInput!]
  NOT: [ItemSubscriptionWhereInput!]
}

input ItemUpdateDataInput {
  itemId: String
  name: String
  i18n: i18nUpdateManyInput
  images: ImageUpdateManyInput
  introduction: ParagraphUpdateManyInput
  statements: StatementUpdateManyInput
  logs: LogUpdateManyInput
  creator: UserUpdateOneRequiredInput
  meta: Json
}

input ItemUpdateInput {
  itemId: String
  name: String
  i18n: i18nUpdateManyInput
  images: ImageUpdateManyInput
  introduction: ParagraphUpdateManyInput
  statements: StatementUpdateManyInput
  logs: LogUpdateManyInput
  creator: UserUpdateOneRequiredInput
  meta: Json
}

input ItemUpdateManyMutationInput {
  itemId: String
  name: String
  meta: Json
}

input ItemUpdateOneInput {
  create: ItemCreateInput
  update: ItemUpdateDataInput
  upsert: ItemUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ItemWhereUniqueInput
}

input ItemUpsertNestedInput {
  update: ItemUpdateDataInput!
  create: ItemCreateInput!
}

input ItemWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  itemId: String
  itemId_not: String
  itemId_in: [String!]
  itemId_not_in: [String!]
  itemId_lt: String
  itemId_lte: String
  itemId_gt: String
  itemId_gte: String
  itemId_contains: String
  itemId_not_contains: String
  itemId_starts_with: String
  itemId_not_starts_with: String
  itemId_ends_with: String
  itemId_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  i18n_every: i18nWhereInput
  i18n_some: i18nWhereInput
  i18n_none: i18nWhereInput
  images_every: ImageWhereInput
  images_some: ImageWhereInput
  images_none: ImageWhereInput
  introduction_every: ParagraphWhereInput
  introduction_some: ParagraphWhereInput
  introduction_none: ParagraphWhereInput
  statements_every: StatementWhereInput
  statements_some: StatementWhereInput
  statements_none: StatementWhereInput
  logs_every: LogWhereInput
  logs_some: LogWhereInput
  logs_none: LogWhereInput
  creator: UserWhereInput
  AND: [ItemWhereInput!]
  OR: [ItemWhereInput!]
  NOT: [ItemWhereInput!]
}

input ItemWhereUniqueInput {
  id: UUID
  itemId: String
}

scalar Json

type Lang {
  id: UUID!
  code: String!
  langName: String!
  i18n(where: i18nWhereInput, orderBy: i18nOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [i18n!]
  meta: Json
}

type LangConnection {
  pageInfo: PageInfo!
  edges: [LangEdge]!
  aggregate: AggregateLang!
}

input LangCreateInput {
  id: UUID
  code: String!
  langName: String!
  i18n: i18nCreateManyWithoutLangInput
  meta: Json
}

input LangCreateOneWithoutI18nInput {
  create: LangCreateWithoutI18nInput
  connect: LangWhereUniqueInput
}

input LangCreateWithoutI18nInput {
  id: UUID
  code: String!
  langName: String!
  meta: Json
}

type LangEdge {
  node: Lang!
  cursor: String!
}

enum LangOrderByInput {
  id_ASC
  id_DESC
  code_ASC
  code_DESC
  langName_ASC
  langName_DESC
  meta_ASC
  meta_DESC
}

type LangPreviousValues {
  id: UUID!
  code: String!
  langName: String!
  meta: Json
}

type LangSubscriptionPayload {
  mutation: MutationType!
  node: Lang
  updatedFields: [String!]
  previousValues: LangPreviousValues
}

input LangSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LangWhereInput
  AND: [LangSubscriptionWhereInput!]
  OR: [LangSubscriptionWhereInput!]
  NOT: [LangSubscriptionWhereInput!]
}

input LangUpdateInput {
  code: String
  langName: String
  i18n: i18nUpdateManyWithoutLangInput
  meta: Json
}

input LangUpdateManyMutationInput {
  code: String
  langName: String
  meta: Json
}

input LangUpdateOneRequiredWithoutI18nInput {
  create: LangCreateWithoutI18nInput
  update: LangUpdateWithoutI18nDataInput
  upsert: LangUpsertWithoutI18nInput
  connect: LangWhereUniqueInput
}

input LangUpdateWithoutI18nDataInput {
  code: String
  langName: String
  meta: Json
}

input LangUpsertWithoutI18nInput {
  update: LangUpdateWithoutI18nDataInput!
  create: LangCreateWithoutI18nInput!
}

input LangWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  langName: String
  langName_not: String
  langName_in: [String!]
  langName_not_in: [String!]
  langName_lt: String
  langName_lte: String
  langName_gt: String
  langName_gte: String
  langName_contains: String
  langName_not_contains: String
  langName_starts_with: String
  langName_not_starts_with: String
  langName_ends_with: String
  langName_not_ends_with: String
  i18n_every: i18nWhereInput
  i18n_some: i18nWhereInput
  i18n_none: i18nWhereInput
  AND: [LangWhereInput!]
  OR: [LangWhereInput!]
  NOT: [LangWhereInput!]
}

input LangWhereUniqueInput {
  id: UUID
  code: String
}

type Log {
  id: UUID!
  ip: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  event: Event!
  user: User
  meta: Json
}

type LogConnection {
  pageInfo: PageInfo!
  edges: [LogEdge]!
  aggregate: AggregateLog!
}

input LogCreateInput {
  id: UUID
  ip: String!
  event: EventCreateOneInput!
  user: UserCreateOneInput
  meta: Json
}

input LogCreateManyInput {
  create: [LogCreateInput!]
  connect: [LogWhereUniqueInput!]
}

input LogCreateManyWithoutUserInput {
  create: [LogCreateWithoutUserInput!]
  connect: [LogWhereUniqueInput!]
}

input LogCreateWithoutUserInput {
  id: UUID
  ip: String!
  event: EventCreateOneInput!
  meta: Json
}

type LogEdge {
  node: Log!
  cursor: String!
}

enum LogOrderByInput {
  id_ASC
  id_DESC
  ip_ASC
  ip_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  meta_ASC
  meta_DESC
}

type LogPreviousValues {
  id: UUID!
  ip: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  meta: Json
}

input LogScalarWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  ip: String
  ip_not: String
  ip_in: [String!]
  ip_not_in: [String!]
  ip_lt: String
  ip_lte: String
  ip_gt: String
  ip_gte: String
  ip_contains: String
  ip_not_contains: String
  ip_starts_with: String
  ip_not_starts_with: String
  ip_ends_with: String
  ip_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [LogScalarWhereInput!]
  OR: [LogScalarWhereInput!]
  NOT: [LogScalarWhereInput!]
}

type LogSubscriptionPayload {
  mutation: MutationType!
  node: Log
  updatedFields: [String!]
  previousValues: LogPreviousValues
}

input LogSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LogWhereInput
  AND: [LogSubscriptionWhereInput!]
  OR: [LogSubscriptionWhereInput!]
  NOT: [LogSubscriptionWhereInput!]
}

input LogUpdateDataInput {
  ip: String
  event: EventUpdateOneRequiredInput
  user: UserUpdateOneInput
  meta: Json
}

input LogUpdateInput {
  ip: String
  event: EventUpdateOneRequiredInput
  user: UserUpdateOneInput
  meta: Json
}

input LogUpdateManyDataInput {
  ip: String
  meta: Json
}

input LogUpdateManyInput {
  create: [LogCreateInput!]
  update: [LogUpdateWithWhereUniqueNestedInput!]
  upsert: [LogUpsertWithWhereUniqueNestedInput!]
  delete: [LogWhereUniqueInput!]
  connect: [LogWhereUniqueInput!]
  set: [LogWhereUniqueInput!]
  disconnect: [LogWhereUniqueInput!]
  deleteMany: [LogScalarWhereInput!]
  updateMany: [LogUpdateManyWithWhereNestedInput!]
}

input LogUpdateManyMutationInput {
  ip: String
  meta: Json
}

input LogUpdateManyWithoutUserInput {
  create: [LogCreateWithoutUserInput!]
  delete: [LogWhereUniqueInput!]
  connect: [LogWhereUniqueInput!]
  set: [LogWhereUniqueInput!]
  disconnect: [LogWhereUniqueInput!]
  update: [LogUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [LogUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [LogScalarWhereInput!]
  updateMany: [LogUpdateManyWithWhereNestedInput!]
}

input LogUpdateManyWithWhereNestedInput {
  where: LogScalarWhereInput!
  data: LogUpdateManyDataInput!
}

input LogUpdateWithoutUserDataInput {
  ip: String
  event: EventUpdateOneRequiredInput
  meta: Json
}

input LogUpdateWithWhereUniqueNestedInput {
  where: LogWhereUniqueInput!
  data: LogUpdateDataInput!
}

input LogUpdateWithWhereUniqueWithoutUserInput {
  where: LogWhereUniqueInput!
  data: LogUpdateWithoutUserDataInput!
}

input LogUpsertWithWhereUniqueNestedInput {
  where: LogWhereUniqueInput!
  update: LogUpdateDataInput!
  create: LogCreateInput!
}

input LogUpsertWithWhereUniqueWithoutUserInput {
  where: LogWhereUniqueInput!
  update: LogUpdateWithoutUserDataInput!
  create: LogCreateWithoutUserInput!
}

input LogWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  ip: String
  ip_not: String
  ip_in: [String!]
  ip_not_in: [String!]
  ip_lt: String
  ip_lte: String
  ip_gt: String
  ip_gte: String
  ip_contains: String
  ip_not_contains: String
  ip_starts_with: String
  ip_not_starts_with: String
  ip_ends_with: String
  ip_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  event: EventWhereInput
  user: UserWhereInput
  AND: [LogWhereInput!]
  OR: [LogWhereInput!]
  NOT: [LogWhereInput!]
}

input LogWhereUniqueInput {
  id: UUID
}

scalar Long

type Markup {
  id: UUID!
  type: MarkupType!
  start: Int
  end: Int
  href: String
  rel: String
  src: String
  title: String
  meta: Json
}

type MarkupConnection {
  pageInfo: PageInfo!
  edges: [MarkupEdge]!
  aggregate: AggregateMarkup!
}

input MarkupCreateInput {
  id: UUID
  type: MarkupType!
  start: Int
  end: Int
  href: String
  rel: String
  src: String
  title: String
  meta: Json
}

input MarkupCreateManyInput {
  create: [MarkupCreateInput!]
  connect: [MarkupWhereUniqueInput!]
}

type MarkupEdge {
  node: Markup!
  cursor: String!
}

enum MarkupOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  start_ASC
  start_DESC
  end_ASC
  end_DESC
  href_ASC
  href_DESC
  rel_ASC
  rel_DESC
  src_ASC
  src_DESC
  title_ASC
  title_DESC
  meta_ASC
  meta_DESC
}

type MarkupPreviousValues {
  id: UUID!
  type: MarkupType!
  start: Int
  end: Int
  href: String
  rel: String
  src: String
  title: String
  meta: Json
}

input MarkupScalarWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  type: MarkupType
  type_not: MarkupType
  type_in: [MarkupType!]
  type_not_in: [MarkupType!]
  start: Int
  start_not: Int
  start_in: [Int!]
  start_not_in: [Int!]
  start_lt: Int
  start_lte: Int
  start_gt: Int
  start_gte: Int
  end: Int
  end_not: Int
  end_in: [Int!]
  end_not_in: [Int!]
  end_lt: Int
  end_lte: Int
  end_gt: Int
  end_gte: Int
  href: String
  href_not: String
  href_in: [String!]
  href_not_in: [String!]
  href_lt: String
  href_lte: String
  href_gt: String
  href_gte: String
  href_contains: String
  href_not_contains: String
  href_starts_with: String
  href_not_starts_with: String
  href_ends_with: String
  href_not_ends_with: String
  rel: String
  rel_not: String
  rel_in: [String!]
  rel_not_in: [String!]
  rel_lt: String
  rel_lte: String
  rel_gt: String
  rel_gte: String
  rel_contains: String
  rel_not_contains: String
  rel_starts_with: String
  rel_not_starts_with: String
  rel_ends_with: String
  rel_not_ends_with: String
  src: String
  src_not: String
  src_in: [String!]
  src_not_in: [String!]
  src_lt: String
  src_lte: String
  src_gt: String
  src_gte: String
  src_contains: String
  src_not_contains: String
  src_starts_with: String
  src_not_starts_with: String
  src_ends_with: String
  src_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [MarkupScalarWhereInput!]
  OR: [MarkupScalarWhereInput!]
  NOT: [MarkupScalarWhereInput!]
}

type MarkupSubscriptionPayload {
  mutation: MutationType!
  node: Markup
  updatedFields: [String!]
  previousValues: MarkupPreviousValues
}

input MarkupSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MarkupWhereInput
  AND: [MarkupSubscriptionWhereInput!]
  OR: [MarkupSubscriptionWhereInput!]
  NOT: [MarkupSubscriptionWhereInput!]
}

enum MarkupType {
  EMBED
  ITEM
  IMAGE
  LINK
  ITALIC
  STRONG
}

input MarkupUpdateDataInput {
  type: MarkupType
  start: Int
  end: Int
  href: String
  rel: String
  src: String
  title: String
  meta: Json
}

input MarkupUpdateInput {
  type: MarkupType
  start: Int
  end: Int
  href: String
  rel: String
  src: String
  title: String
  meta: Json
}

input MarkupUpdateManyDataInput {
  type: MarkupType
  start: Int
  end: Int
  href: String
  rel: String
  src: String
  title: String
  meta: Json
}

input MarkupUpdateManyInput {
  create: [MarkupCreateInput!]
  update: [MarkupUpdateWithWhereUniqueNestedInput!]
  upsert: [MarkupUpsertWithWhereUniqueNestedInput!]
  delete: [MarkupWhereUniqueInput!]
  connect: [MarkupWhereUniqueInput!]
  set: [MarkupWhereUniqueInput!]
  disconnect: [MarkupWhereUniqueInput!]
  deleteMany: [MarkupScalarWhereInput!]
  updateMany: [MarkupUpdateManyWithWhereNestedInput!]
}

input MarkupUpdateManyMutationInput {
  type: MarkupType
  start: Int
  end: Int
  href: String
  rel: String
  src: String
  title: String
  meta: Json
}

input MarkupUpdateManyWithWhereNestedInput {
  where: MarkupScalarWhereInput!
  data: MarkupUpdateManyDataInput!
}

input MarkupUpdateWithWhereUniqueNestedInput {
  where: MarkupWhereUniqueInput!
  data: MarkupUpdateDataInput!
}

input MarkupUpsertWithWhereUniqueNestedInput {
  where: MarkupWhereUniqueInput!
  update: MarkupUpdateDataInput!
  create: MarkupCreateInput!
}

input MarkupWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  type: MarkupType
  type_not: MarkupType
  type_in: [MarkupType!]
  type_not_in: [MarkupType!]
  start: Int
  start_not: Int
  start_in: [Int!]
  start_not_in: [Int!]
  start_lt: Int
  start_lte: Int
  start_gt: Int
  start_gte: Int
  end: Int
  end_not: Int
  end_in: [Int!]
  end_not_in: [Int!]
  end_lt: Int
  end_lte: Int
  end_gt: Int
  end_gte: Int
  href: String
  href_not: String
  href_in: [String!]
  href_not_in: [String!]
  href_lt: String
  href_lte: String
  href_gt: String
  href_gte: String
  href_contains: String
  href_not_contains: String
  href_starts_with: String
  href_not_starts_with: String
  href_ends_with: String
  href_not_ends_with: String
  rel: String
  rel_not: String
  rel_in: [String!]
  rel_not_in: [String!]
  rel_lt: String
  rel_lte: String
  rel_gt: String
  rel_gte: String
  rel_contains: String
  rel_not_contains: String
  rel_starts_with: String
  rel_not_starts_with: String
  rel_ends_with: String
  rel_not_ends_with: String
  src: String
  src_not: String
  src_in: [String!]
  src_not_in: [String!]
  src_lt: String
  src_lte: String
  src_gt: String
  src_gte: String
  src_contains: String
  src_not_contains: String
  src_starts_with: String
  src_not_starts_with: String
  src_ends_with: String
  src_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [MarkupWhereInput!]
  OR: [MarkupWhereInput!]
  NOT: [MarkupWhereInput!]
}

input MarkupWhereUniqueInput {
  id: UUID
}

type Measurement {
  id: UUID!
  height: Float!
  width: Float!
}

type MeasurementConnection {
  pageInfo: PageInfo!
  edges: [MeasurementEdge]!
  aggregate: AggregateMeasurement!
}

input MeasurementCreateInput {
  id: UUID
  height: Float
  width: Float
}

input MeasurementCreateOneInput {
  create: MeasurementCreateInput
  connect: MeasurementWhereUniqueInput
}

type MeasurementEdge {
  node: Measurement!
  cursor: String!
}

enum MeasurementOrderByInput {
  id_ASC
  id_DESC
  height_ASC
  height_DESC
  width_ASC
  width_DESC
}

type MeasurementPreviousValues {
  id: UUID!
  height: Float!
  width: Float!
}

type MeasurementSubscriptionPayload {
  mutation: MutationType!
  node: Measurement
  updatedFields: [String!]
  previousValues: MeasurementPreviousValues
}

input MeasurementSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MeasurementWhereInput
  AND: [MeasurementSubscriptionWhereInput!]
  OR: [MeasurementSubscriptionWhereInput!]
  NOT: [MeasurementSubscriptionWhereInput!]
}

input MeasurementUpdateDataInput {
  height: Float
  width: Float
}

input MeasurementUpdateInput {
  height: Float
  width: Float
}

input MeasurementUpdateManyMutationInput {
  height: Float
  width: Float
}

input MeasurementUpdateOneInput {
  create: MeasurementCreateInput
  update: MeasurementUpdateDataInput
  upsert: MeasurementUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: MeasurementWhereUniqueInput
}

input MeasurementUpsertNestedInput {
  update: MeasurementUpdateDataInput!
  create: MeasurementCreateInput!
}

input MeasurementWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  height: Float
  height_not: Float
  height_in: [Float!]
  height_not_in: [Float!]
  height_lt: Float
  height_lte: Float
  height_gt: Float
  height_gte: Float
  width: Float
  width_not: Float
  width_in: [Float!]
  width_not_in: [Float!]
  width_lt: Float
  width_lte: Float
  width_gt: Float
  width_gte: Float
  AND: [MeasurementWhereInput!]
  OR: [MeasurementWhereInput!]
  NOT: [MeasurementWhereInput!]
}

input MeasurementWhereUniqueInput {
  id: UUID
}

type Mutation {
  # createAccess(data: AccessCreateInput!): Access!
  # updateAccess(data: AccessUpdateInput!, where: AccessWhereUniqueInput!): Access
  # updateManyAccesses(data: AccessUpdateManyMutationInput!, where: AccessWhereInput): BatchPayload!
  # upsertAccess(where: AccessWhereUniqueInput!, create: AccessCreateInput!, update: AccessUpdateInput!): Access!
  # deleteAccess(where: AccessWhereUniqueInput!): Access
  # deleteManyAccesses(where: AccessWhereInput): BatchPayload!
  createAdmin(data: AdminCreateInput!): Admin!
  updateAdmin(data: AdminUpdateInput!, where: AdminWhereUniqueInput!): Admin
  updateManyAdmins(data: AdminUpdateManyMutationInput!, where: AdminWhereInput): BatchPayload!
  upsertAdmin(where: AdminWhereUniqueInput!, create: AdminCreateInput!, update: AdminUpdateInput!): Admin!
  deleteAdmin(where: AdminWhereUniqueInput!): Admin
  deleteManyAdmins(where: AdminWhereInput): BatchPayload!
  # createEntity(data: EntityCreateInput!): Entity!
  # updateEntity(data: EntityUpdateInput!, where: EntityWhereUniqueInput!): Entity
  # updateManyEntities(data: EntityUpdateManyMutationInput!, where: EntityWhereInput): BatchPayload!
  # upsertEntity(where: EntityWhereUniqueInput!, create: EntityCreateInput!, update: EntityUpdateInput!): Entity!
  # deleteEntity(where: EntityWhereUniqueInput!): Entity
  # deleteManyEntities(where: EntityWhereInput): BatchPayload!
  # createEvent(data: EventCreateInput!): Event!
  # updateEvent(data: EventUpdateInput!, where: EventWhereUniqueInput!): Event
  # updateManyEvents(data: EventUpdateManyMutationInput!, where: EventWhereInput): BatchPayload!
  # upsertEvent(where: EventWhereUniqueInput!, create: EventCreateInput!, update: EventUpdateInput!): Event!
  # deleteEvent(where: EventWhereUniqueInput!): Event
  # deleteManyEvents(where: EventWhereInput): BatchPayload!
  createFile(data: FileCreateInput!): File!
  updateFile(data: FileUpdateInput!, where: FileWhereUniqueInput!): File
  updateManyFiles(data: FileUpdateManyMutationInput!, where: FileWhereInput): BatchPayload!
  upsertFile(where: FileWhereUniqueInput!, create: FileCreateInput!, update: FileUpdateInput!): File!
  deleteFile(where: FileWhereUniqueInput!): File
  deleteManyFiles(where: FileWhereInput): BatchPayload!
  createGroup(data: GroupCreateInput!): Group!
  updateGroup(data: GroupUpdateInput!, where: GroupWhereUniqueInput!): Group
  updateManyGroups(data: GroupUpdateManyMutationInput!, where: GroupWhereInput): BatchPayload!
  upsertGroup(where: GroupWhereUniqueInput!, create: GroupCreateInput!, update: GroupUpdateInput!): Group!
  deleteGroup(where: GroupWhereUniqueInput!): Group
  deleteManyGroups(where: GroupWhereInput): BatchPayload!
  createImage(data: ImageCreateInput!): Image!
  updateImage(data: ImageUpdateInput!, where: ImageWhereUniqueInput!): Image
  updateManyImages(data: ImageUpdateManyMutationInput!, where: ImageWhereInput): BatchPayload!
  upsertImage(where: ImageWhereUniqueInput!, create: ImageCreateInput!, update: ImageUpdateInput!): Image!
  deleteImage(where: ImageWhereUniqueInput!): Image
  deleteManyImages(where: ImageWhereInput): BatchPayload!
  createItem(data: ItemCreateInput!): Item!
  updateItem(data: ItemUpdateInput!, where: ItemWhereUniqueInput!): Item
  updateManyItems(data: ItemUpdateManyMutationInput!, where: ItemWhereInput): BatchPayload!
  upsertItem(where: ItemWhereUniqueInput!, create: ItemCreateInput!, update: ItemUpdateInput!): Item!
  deleteItem(where: ItemWhereUniqueInput!): Item
  deleteManyItems(where: ItemWhereInput): BatchPayload!
  # createLang(data: LangCreateInput!): Lang!
  # updateLang(data: LangUpdateInput!, where: LangWhereUniqueInput!): Lang
  # updateManyLangs(data: LangUpdateManyMutationInput!, where: LangWhereInput): BatchPayload!
  # upsertLang(where: LangWhereUniqueInput!, create: LangCreateInput!, update: LangUpdateInput!): Lang!
  # deleteLang(where: LangWhereUniqueInput!): Lang
  # deleteManyLangs(where: LangWhereInput): BatchPayload!
  # createLog(data: LogCreateInput!): Log!
  # updateLog(data: LogUpdateInput!, where: LogWhereUniqueInput!): Log
  # updateManyLogs(data: LogUpdateManyMutationInput!, where: LogWhereInput): BatchPayload!
  # upsertLog(where: LogWhereUniqueInput!, create: LogCreateInput!, update: LogUpdateInput!): Log!
  deleteLog(where: LogWhereUniqueInput!): Log
  deleteManyLogs(where: LogWhereInput): BatchPayload!
  # createMarkup(data: MarkupCreateInput!): Markup!
  # updateMarkup(data: MarkupUpdateInput!, where: MarkupWhereUniqueInput!): Markup
  # updateManyMarkups(data: MarkupUpdateManyMutationInput!, where: MarkupWhereInput): BatchPayload!
  # upsertMarkup(where: MarkupWhereUniqueInput!, create: MarkupCreateInput!, update: MarkupUpdateInput!): Markup!
  # deleteMarkup(where: MarkupWhereUniqueInput!): Markup
  # deleteManyMarkups(where: MarkupWhereInput): BatchPayload!
  # createMeasurement(data: MeasurementCreateInput!): Measurement!
  # updateMeasurement(data: MeasurementUpdateInput!, where: MeasurementWhereUniqueInput!): Measurement
  # updateManyMeasurements(data: MeasurementUpdateManyMutationInput!, where: MeasurementWhereInput): BatchPayload!
  # upsertMeasurement(where: MeasurementWhereUniqueInput!, create: MeasurementCreateInput!, update: MeasurementUpdateInput!): Measurement!
  # deleteMeasurement(where: MeasurementWhereUniqueInput!): Measurement
  # deleteManyMeasurements(where: MeasurementWhereInput): BatchPayload!
  createNews(data: NewsCreateInput!): News!
  updateNews(data: NewsUpdateInput!, where: NewsWhereUniqueInput!): News
  updateManyNewses(data: NewsUpdateManyMutationInput!, where: NewsWhereInput): BatchPayload!
  upsertNews(where: NewsWhereUniqueInput!, create: NewsCreateInput!, update: NewsUpdateInput!): News!
  deleteNews(where: NewsWhereUniqueInput!): News
  deleteManyNewses(where: NewsWhereInput): BatchPayload!
  createNote(data: NoteCreateInput!): Note!
  updateNote(data: NoteUpdateInput!, where: NoteWhereUniqueInput!): Note
  updateManyNotes(data: NoteUpdateManyMutationInput!, where: NoteWhereInput): BatchPayload!
  upsertNote(where: NoteWhereUniqueInput!, create: NoteCreateInput!, update: NoteUpdateInput!): Note!
  deleteNote(where: NoteWhereUniqueInput!): Note
  deleteManyNotes(where: NoteWhereInput): BatchPayload!
  createPage(data: PageCreateInput!): Page!
  updatePage(data: PageUpdateInput!, where: PageWhereUniqueInput!): Page
  updateManyPages(data: PageUpdateManyMutationInput!, where: PageWhereInput): BatchPayload!
  upsertPage(where: PageWhereUniqueInput!, create: PageCreateInput!, update: PageUpdateInput!): Page!
  deletePage(where: PageWhereUniqueInput!): Page
  deleteManyPages(where: PageWhereInput): BatchPayload!
  # createPageHead(data: PageHeadCreateInput!): PageHead!
  # updatePageHead(data: PageHeadUpdateInput!, where: PageHeadWhereUniqueInput!): PageHead
  # updateManyPageHeads(data: PageHeadUpdateManyMutationInput!, where: PageHeadWhereInput): BatchPayload!
  # upsertPageHead(where: PageHeadWhereUniqueInput!, create: PageHeadCreateInput!, update: PageHeadUpdateInput!): PageHead!
  # deletePageHead(where: PageHeadWhereUniqueInput!): PageHead
  # deleteManyPageHeads(where: PageHeadWhereInput): BatchPayload!
  # createPageMeta(data: PageMetaCreateInput!): PageMeta!
  # updatePageMeta(data: PageMetaUpdateInput!, where: PageMetaWhereUniqueInput!): PageMeta
  # updateManyPageMetas(data: PageMetaUpdateManyMutationInput!, where: PageMetaWhereInput): BatchPayload!
  # upsertPageMeta(where: PageMetaWhereUniqueInput!, create: PageMetaCreateInput!, update: PageMetaUpdateInput!): PageMeta!
  # deletePageMeta(where: PageMetaWhereUniqueInput!): PageMeta
  # deleteManyPageMetas(where: PageMetaWhereInput): BatchPayload!
  # createParagraph(data: ParagraphCreateInput!): Paragraph!
  # updateParagraph(data: ParagraphUpdateInput!, where: ParagraphWhereUniqueInput!): Paragraph
  # updateManyParagraphs(data: ParagraphUpdateManyMutationInput!, where: ParagraphWhereInput): BatchPayload!
  # upsertParagraph(where: ParagraphWhereUniqueInput!, create: ParagraphCreateInput!, update: ParagraphUpdateInput!): Paragraph!
  # deleteParagraph(where: ParagraphWhereUniqueInput!): Paragraph
  # deleteManyParagraphs(where: ParagraphWhereInput): BatchPayload!
  createPermission(data: PermissionCreateInput!): Permission!
  updatePermission(data: PermissionUpdateInput!, where: PermissionWhereUniqueInput!): Permission
  updateManyPermissions(data: PermissionUpdateManyMutationInput!, where: PermissionWhereInput): BatchPayload!
  upsertPermission(where: PermissionWhereUniqueInput!, create: PermissionCreateInput!, update: PermissionUpdateInput!): Permission!
  deletePermission(where: PermissionWhereUniqueInput!): Permission
  deleteManyPermissions(where: PermissionWhereInput): BatchPayload!
  # createPermissionType(data: PermissionTypeCreateInput!): PermissionType!
  # updatePermissionType(data: PermissionTypeUpdateInput!, where: PermissionTypeWhereUniqueInput!): PermissionType
  # upsertPermissionType(where: PermissionTypeWhereUniqueInput!, create: PermissionTypeCreateInput!, update: PermissionTypeUpdateInput!): PermissionType!
  # deletePermissionType(where: PermissionTypeWhereUniqueInput!): PermissionType
  # deleteManyPermissionTypes(where: PermissionTypeWhereInput): BatchPayload!
  createPost(data: PostCreateInput!): Post!
  updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
  updateManyPosts(data: PostUpdateManyMutationInput!, where: PostWhereInput): BatchPayload!
  upsertPost(where: PostWhereUniqueInput!, create: PostCreateInput!, update: PostUpdateInput!): Post!
  deletePost(where: PostWhereUniqueInput!): Post
  deleteManyPosts(where: PostWhereInput): BatchPayload!
  createProperty(data: PropertyCreateInput!): Property!
  updateProperty(data: PropertyUpdateInput!, where: PropertyWhereUniqueInput!): Property
  updateManyProperties(data: PropertyUpdateManyMutationInput!, where: PropertyWhereInput): BatchPayload!
  upsertProperty(where: PropertyWhereUniqueInput!, create: PropertyCreateInput!, update: PropertyUpdateInput!): Property!
  deleteProperty(where: PropertyWhereUniqueInput!): Property
  deleteManyProperties(where: PropertyWhereInput): BatchPayload!
  createQuote(data: QuoteCreateInput!): Quote!
  updateQuote(data: QuoteUpdateInput!, where: QuoteWhereUniqueInput!): Quote
  updateManyQuotes(data: QuoteUpdateManyMutationInput!, where: QuoteWhereInput): BatchPayload!
  upsertQuote(where: QuoteWhereUniqueInput!, create: QuoteCreateInput!, update: QuoteUpdateInput!): Quote!
  deleteQuote(where: QuoteWhereUniqueInput!): Quote
  deleteManyQuotes(where: QuoteWhereInput): BatchPayload!
  createReply(data: ReplyCreateInput!): Reply!
  updateReply(data: ReplyUpdateInput!, where: ReplyWhereUniqueInput!): Reply
  updateManyReplies(data: ReplyUpdateManyMutationInput!, where: ReplyWhereInput): BatchPayload!
  upsertReply(where: ReplyWhereUniqueInput!, create: ReplyCreateInput!, update: ReplyUpdateInput!): Reply!
  deleteReply(where: ReplyWhereUniqueInput!): Reply
  deleteManyReplies(where: ReplyWhereInput): BatchPayload!
  createSite(data: SiteCreateInput!): Site!
  updateSite(data: SiteUpdateInput!, where: SiteWhereUniqueInput!): Site
  updateManySites(data: SiteUpdateManyMutationInput!, where: SiteWhereInput): BatchPayload!
  upsertSite(where: SiteWhereUniqueInput!, create: SiteCreateInput!, update: SiteUpdateInput!): Site!
  deleteSite(where: SiteWhereUniqueInput!): Site
  deleteManySites(where: SiteWhereInput): BatchPayload!
  # createStatement(data: StatementCreateInput!): Statement!
  # updateStatement(data: StatementUpdateInput!, where: StatementWhereUniqueInput!): Statement
  # updateManyStatements(data: StatementUpdateManyMutationInput!, where: StatementWhereInput): BatchPayload!
  # upsertStatement(where: StatementWhereUniqueInput!, create: StatementCreateInput!, update: StatementUpdateInput!): Statement!
  # deleteStatement(where: StatementWhereUniqueInput!): Statement
  # deleteManyStatements(where: StatementWhereInput): BatchPayload!
  createTag(data: TagCreateInput!): Tag!
  updateTag(data: TagUpdateInput!, where: TagWhereUniqueInput!): Tag
  updateManyTags(data: TagUpdateManyMutationInput!, where: TagWhereInput): BatchPayload!
  upsertTag(where: TagWhereUniqueInput!, create: TagCreateInput!, update: TagUpdateInput!): Tag!
  deleteTag(where: TagWhereUniqueInput!): Tag
  deleteManyTags(where: TagWhereInput): BatchPayload!
  createTheme(data: ThemeCreateInput!): Theme!
  updateTheme(data: ThemeUpdateInput!, where: ThemeWhereUniqueInput!): Theme
  updateManyThemes(data: ThemeUpdateManyMutationInput!, where: ThemeWhereInput): BatchPayload!
  upsertTheme(where: ThemeWhereUniqueInput!, create: ThemeCreateInput!, update: ThemeUpdateInput!): Theme!
  deleteTheme(where: ThemeWhereUniqueInput!): Theme
  deleteManyThemes(where: ThemeWhereInput): BatchPayload!
  verify: User!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  # createi18n(data: i18nCreateInput!): i18n!
  # updatei18n(data: i18nUpdateInput!, where: i18nWhereUniqueInput!): i18n
  # updateManyi18ns(data: i18nUpdateManyMutationInput!, where: i18nWhereInput): BatchPayload!
  # upserti18n(where: i18nWhereUniqueInput!, create: i18nCreateInput!, update: i18nUpdateInput!): i18n!
  # deletei18n(where: i18nWhereUniqueInput!): i18n
  # deleteManyi18ns(where: i18nWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

type News {
  id: UUID!
  title: String!
  published: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  validUntil: DateTime!
  author: User!
  banner(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Image!]
  paragraphs(where: ParagraphWhereInput, orderBy: ParagraphOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Paragraph!]
  replies(where: ReplyWhereInput, orderBy: ReplyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Reply!]
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
  meta: Json
}

type NewsConnection {
  pageInfo: PageInfo!
  edges: [NewsEdge]!
  aggregate: AggregateNews!
}

input NewsCreateInput {
  id: UUID
  title: String!
  published: Boolean
  validUntil: DateTime!
  author: UserCreateOneInput!
  banner: ImageCreateManyInput
  paragraphs: ParagraphCreateManyInput
  replies: ReplyCreateManyInput
  tags: TagCreateManyInput
  meta: Json
}

type NewsEdge {
  node: News!
  cursor: String!
}

enum NewsOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  published_ASC
  published_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  validUntil_ASC
  validUntil_DESC
  meta_ASC
  meta_DESC
}

type NewsPreviousValues {
  id: UUID!
  title: String!
  published: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  validUntil: DateTime!
  meta: Json
}

type NewsSubscriptionPayload {
  mutation: MutationType!
  node: News
  updatedFields: [String!]
  previousValues: NewsPreviousValues
}

input NewsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NewsWhereInput
  AND: [NewsSubscriptionWhereInput!]
  OR: [NewsSubscriptionWhereInput!]
  NOT: [NewsSubscriptionWhereInput!]
}

input NewsUpdateInput {
  title: String
  published: Boolean
  validUntil: DateTime
  author: UserUpdateOneRequiredInput
  banner: ImageUpdateManyInput
  paragraphs: ParagraphUpdateManyInput
  replies: ReplyUpdateManyInput
  tags: TagUpdateManyInput
  meta: Json
}

input NewsUpdateManyMutationInput {
  title: String
  published: Boolean
  validUntil: DateTime
  meta: Json
}

input NewsWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  published: Boolean
  published_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  validUntil: DateTime
  validUntil_not: DateTime
  validUntil_in: [DateTime!]
  validUntil_not_in: [DateTime!]
  validUntil_lt: DateTime
  validUntil_lte: DateTime
  validUntil_gt: DateTime
  validUntil_gte: DateTime
  author: UserWhereInput
  banner_every: ImageWhereInput
  banner_some: ImageWhereInput
  banner_none: ImageWhereInput
  paragraphs_every: ParagraphWhereInput
  paragraphs_some: ParagraphWhereInput
  paragraphs_none: ParagraphWhereInput
  replies_every: ReplyWhereInput
  replies_some: ReplyWhereInput
  replies_none: ReplyWhereInput
  tags_every: TagWhereInput
  tags_some: TagWhereInput
  tags_none: TagWhereInput
  AND: [NewsWhereInput!]
  OR: [NewsWhereInput!]
  NOT: [NewsWhereInput!]
}

input NewsWhereUniqueInput {
  id: UUID
}

interface Node {
  id: ID!
}

type Note {
  id: UUID!
  content: String
  createdAt: DateTime!
  updatedAt: DateTime!
  user: User!
  notes(where: NoteWhereInput, orderBy: NoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Note!]
  meta: Json
}

type NoteConnection {
  pageInfo: PageInfo!
  edges: [NoteEdge]!
  aggregate: AggregateNote!
}

input NoteCreateInput {
  id: UUID
  content: String
  user: UserCreateOneInput!
  notes: NoteCreateManyWithoutNotesInput
  meta: Json
}

input NoteCreateManyInput {
  create: [NoteCreateInput!]
  connect: [NoteWhereUniqueInput!]
}

input NoteCreateManyWithoutNotesInput {
  create: [NoteCreateWithoutNotesInput!]
  connect: [NoteWhereUniqueInput!]
}

input NoteCreateWithoutNotesInput {
  id: UUID
  content: String
  user: UserCreateOneInput!
  meta: Json
}

type NoteEdge {
  node: Note!
  cursor: String!
}

enum NoteOrderByInput {
  id_ASC
  id_DESC
  content_ASC
  content_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  meta_ASC
  meta_DESC
}

type NotePreviousValues {
  id: UUID!
  content: String
  createdAt: DateTime!
  updatedAt: DateTime!
  meta: Json
}

input NoteScalarWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [NoteScalarWhereInput!]
  OR: [NoteScalarWhereInput!]
  NOT: [NoteScalarWhereInput!]
}

type NoteSubscriptionPayload {
  mutation: MutationType!
  node: Note
  updatedFields: [String!]
  previousValues: NotePreviousValues
}

input NoteSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NoteWhereInput
  AND: [NoteSubscriptionWhereInput!]
  OR: [NoteSubscriptionWhereInput!]
  NOT: [NoteSubscriptionWhereInput!]
}

input NoteUpdateDataInput {
  content: String
  user: UserUpdateOneRequiredInput
  notes: NoteUpdateManyWithoutNotesInput
  meta: Json
}

input NoteUpdateInput {
  content: String
  user: UserUpdateOneRequiredInput
  notes: NoteUpdateManyWithoutNotesInput
  meta: Json
}

input NoteUpdateManyDataInput {
  content: String
  meta: Json
}

input NoteUpdateManyInput {
  create: [NoteCreateInput!]
  update: [NoteUpdateWithWhereUniqueNestedInput!]
  upsert: [NoteUpsertWithWhereUniqueNestedInput!]
  delete: [NoteWhereUniqueInput!]
  connect: [NoteWhereUniqueInput!]
  set: [NoteWhereUniqueInput!]
  disconnect: [NoteWhereUniqueInput!]
  deleteMany: [NoteScalarWhereInput!]
  updateMany: [NoteUpdateManyWithWhereNestedInput!]
}

input NoteUpdateManyMutationInput {
  content: String
  meta: Json
}

input NoteUpdateManyWithoutNotesInput {
  create: [NoteCreateWithoutNotesInput!]
  delete: [NoteWhereUniqueInput!]
  connect: [NoteWhereUniqueInput!]
  set: [NoteWhereUniqueInput!]
  disconnect: [NoteWhereUniqueInput!]
  update: [NoteUpdateWithWhereUniqueWithoutNotesInput!]
  upsert: [NoteUpsertWithWhereUniqueWithoutNotesInput!]
  deleteMany: [NoteScalarWhereInput!]
  updateMany: [NoteUpdateManyWithWhereNestedInput!]
}

input NoteUpdateManyWithWhereNestedInput {
  where: NoteScalarWhereInput!
  data: NoteUpdateManyDataInput!
}

input NoteUpdateWithoutNotesDataInput {
  content: String
  user: UserUpdateOneRequiredInput
  meta: Json
}

input NoteUpdateWithWhereUniqueNestedInput {
  where: NoteWhereUniqueInput!
  data: NoteUpdateDataInput!
}

input NoteUpdateWithWhereUniqueWithoutNotesInput {
  where: NoteWhereUniqueInput!
  data: NoteUpdateWithoutNotesDataInput!
}

input NoteUpsertWithWhereUniqueNestedInput {
  where: NoteWhereUniqueInput!
  update: NoteUpdateDataInput!
  create: NoteCreateInput!
}

input NoteUpsertWithWhereUniqueWithoutNotesInput {
  where: NoteWhereUniqueInput!
  update: NoteUpdateWithoutNotesDataInput!
  create: NoteCreateWithoutNotesInput!
}

input NoteWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  user: UserWhereInput
  notes_every: NoteWhereInput
  notes_some: NoteWhereInput
  notes_none: NoteWhereInput
  AND: [NoteWhereInput!]
  OR: [NoteWhereInput!]
  NOT: [NoteWhereInput!]
}

input NoteWhereUniqueInput {
  id: UUID
}

type Page {
  id: UUID!
  path: String!
  name: String!
  type: PageType!
  index: Int
  createdAt: DateTime!
  updatedAt: DateTime!
  label(where: i18nWhereInput, orderBy: i18nOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [i18n!]
  head: PageHead!
  layout: Theme!
  creator: User!
  meta: Json
}

type PageConnection {
  pageInfo: PageInfo!
  edges: [PageEdge]!
  aggregate: AggregatePage!
}

input PageCreateInput {
  id: UUID
  path: String!
  name: String!
  type: PageType!
  index: Int
  label: i18nCreateManyInput
  head: PageHeadCreateOneInput!
  layout: ThemeCreateOneInput!
  creator: UserCreateOneInput!
  meta: Json
}

input PageCreateManyInput {
  create: [PageCreateInput!]
  connect: [PageWhereUniqueInput!]
}

type PageEdge {
  node: Page!
  cursor: String!
}

type PageHead {
  id: UUID!
  title: String!
  meta(where: PageMetaWhereInput, orderBy: PageMetaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PageMeta!]
}

type PageHeadConnection {
  pageInfo: PageInfo!
  edges: [PageHeadEdge]!
  aggregate: AggregatePageHead!
}

input PageHeadCreateInput {
  id: UUID
  title: String!
  meta: PageMetaCreateManyInput
}

input PageHeadCreateOneInput {
  create: PageHeadCreateInput
  connect: PageHeadWhereUniqueInput
}

type PageHeadEdge {
  node: PageHead!
  cursor: String!
}

enum PageHeadOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
}

type PageHeadPreviousValues {
  id: UUID!
  title: String!
}

type PageHeadSubscriptionPayload {
  mutation: MutationType!
  node: PageHead
  updatedFields: [String!]
  previousValues: PageHeadPreviousValues
}

input PageHeadSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PageHeadWhereInput
  AND: [PageHeadSubscriptionWhereInput!]
  OR: [PageHeadSubscriptionWhereInput!]
  NOT: [PageHeadSubscriptionWhereInput!]
}

input PageHeadUpdateDataInput {
  title: String
  meta: PageMetaUpdateManyInput
}

input PageHeadUpdateInput {
  title: String
  meta: PageMetaUpdateManyInput
}

input PageHeadUpdateManyMutationInput {
  title: String
}

input PageHeadUpdateOneRequiredInput {
  create: PageHeadCreateInput
  update: PageHeadUpdateDataInput
  upsert: PageHeadUpsertNestedInput
  connect: PageHeadWhereUniqueInput
}

input PageHeadUpsertNestedInput {
  update: PageHeadUpdateDataInput!
  create: PageHeadCreateInput!
}

input PageHeadWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  meta_every: PageMetaWhereInput
  meta_some: PageMetaWhereInput
  meta_none: PageMetaWhereInput
  AND: [PageHeadWhereInput!]
  OR: [PageHeadWhereInput!]
  NOT: [PageHeadWhereInput!]
}

input PageHeadWhereUniqueInput {
  id: UUID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type PageMeta {
  id: UUID!
  charset: String
  name: String
  property: String
  content: String
}

type PageMetaConnection {
  pageInfo: PageInfo!
  edges: [PageMetaEdge]!
  aggregate: AggregatePageMeta!
}

input PageMetaCreateInput {
  id: UUID
  charset: String
  name: String
  property: String
  content: String
}

input PageMetaCreateManyInput {
  create: [PageMetaCreateInput!]
  connect: [PageMetaWhereUniqueInput!]
}

type PageMetaEdge {
  node: PageMeta!
  cursor: String!
}

enum PageMetaOrderByInput {
  id_ASC
  id_DESC
  charset_ASC
  charset_DESC
  name_ASC
  name_DESC
  property_ASC
  property_DESC
  content_ASC
  content_DESC
}

type PageMetaPreviousValues {
  id: UUID!
  charset: String!
  name: String
  property: String
  content: String
}

input PageMetaScalarWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  charset: String
  charset_not: String
  charset_in: [String!]
  charset_not_in: [String!]
  charset_lt: String
  charset_lte: String
  charset_gt: String
  charset_gte: String
  charset_contains: String
  charset_not_contains: String
  charset_starts_with: String
  charset_not_starts_with: String
  charset_ends_with: String
  charset_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  property: String
  property_not: String
  property_in: [String!]
  property_not_in: [String!]
  property_lt: String
  property_lte: String
  property_gt: String
  property_gte: String
  property_contains: String
  property_not_contains: String
  property_starts_with: String
  property_not_starts_with: String
  property_ends_with: String
  property_not_ends_with: String
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  AND: [PageMetaScalarWhereInput!]
  OR: [PageMetaScalarWhereInput!]
  NOT: [PageMetaScalarWhereInput!]
}

type PageMetaSubscriptionPayload {
  mutation: MutationType!
  node: PageMeta
  updatedFields: [String!]
  previousValues: PageMetaPreviousValues
}

input PageMetaSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PageMetaWhereInput
  AND: [PageMetaSubscriptionWhereInput!]
  OR: [PageMetaSubscriptionWhereInput!]
  NOT: [PageMetaSubscriptionWhereInput!]
}

input PageMetaUpdateDataInput {
  charset: String
  name: String
  property: String
  content: String
}

input PageMetaUpdateInput {
  charset: String
  name: String
  property: String
  content: String
}

input PageMetaUpdateManyDataInput {
  charset: String
  name: String
  property: String
  content: String
}

input PageMetaUpdateManyInput {
  create: [PageMetaCreateInput!]
  update: [PageMetaUpdateWithWhereUniqueNestedInput!]
  upsert: [PageMetaUpsertWithWhereUniqueNestedInput!]
  delete: [PageMetaWhereUniqueInput!]
  connect: [PageMetaWhereUniqueInput!]
  set: [PageMetaWhereUniqueInput!]
  disconnect: [PageMetaWhereUniqueInput!]
  deleteMany: [PageMetaScalarWhereInput!]
  updateMany: [PageMetaUpdateManyWithWhereNestedInput!]
}

input PageMetaUpdateManyMutationInput {
  charset: String
  name: String
  property: String
  content: String
}

input PageMetaUpdateManyWithWhereNestedInput {
  where: PageMetaScalarWhereInput!
  data: PageMetaUpdateManyDataInput!
}

input PageMetaUpdateWithWhereUniqueNestedInput {
  where: PageMetaWhereUniqueInput!
  data: PageMetaUpdateDataInput!
}

input PageMetaUpsertWithWhereUniqueNestedInput {
  where: PageMetaWhereUniqueInput!
  update: PageMetaUpdateDataInput!
  create: PageMetaCreateInput!
}

input PageMetaWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  charset: String
  charset_not: String
  charset_in: [String!]
  charset_not_in: [String!]
  charset_lt: String
  charset_lte: String
  charset_gt: String
  charset_gte: String
  charset_contains: String
  charset_not_contains: String
  charset_starts_with: String
  charset_not_starts_with: String
  charset_ends_with: String
  charset_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  property: String
  property_not: String
  property_in: [String!]
  property_not_in: [String!]
  property_lt: String
  property_lte: String
  property_gt: String
  property_gte: String
  property_contains: String
  property_not_contains: String
  property_starts_with: String
  property_not_starts_with: String
  property_ends_with: String
  property_not_ends_with: String
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  AND: [PageMetaWhereInput!]
  OR: [PageMetaWhereInput!]
  NOT: [PageMetaWhereInput!]
}

input PageMetaWhereUniqueInput {
  id: UUID
}

enum PageOrderByInput {
  id_ASC
  id_DESC
  path_ASC
  path_DESC
  name_ASC
  name_DESC
  type_ASC
  type_DESC
  index_ASC
  index_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  meta_ASC
  meta_DESC
}

type PagePreviousValues {
  id: UUID!
  path: String!
  name: String!
  type: PageType!
  index: Int
  createdAt: DateTime!
  updatedAt: DateTime!
  meta: Json
}

input PageScalarWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: PageType
  type_not: PageType
  type_in: [PageType!]
  type_not_in: [PageType!]
  index: Int
  index_not: Int
  index_in: [Int!]
  index_not_in: [Int!]
  index_lt: Int
  index_lte: Int
  index_gt: Int
  index_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PageScalarWhereInput!]
  OR: [PageScalarWhereInput!]
  NOT: [PageScalarWhereInput!]
}

type PageSubscriptionPayload {
  mutation: MutationType!
  node: Page
  updatedFields: [String!]
  previousValues: PagePreviousValues
}

input PageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PageWhereInput
  AND: [PageSubscriptionWhereInput!]
  OR: [PageSubscriptionWhereInput!]
  NOT: [PageSubscriptionWhereInput!]
}

enum PageType {
  HOME
  MAIN
  SELF
  BOX
  ERROR
}

input PageUpdateDataInput {
  path: String
  name: String
  type: PageType
  index: Int
  label: i18nUpdateManyInput
  head: PageHeadUpdateOneRequiredInput
  layout: ThemeUpdateOneRequiredInput
  creator: UserUpdateOneRequiredInput
  meta: Json
}

input PageUpdateInput {
  path: String
  name: String
  type: PageType
  index: Int
  label: i18nUpdateManyInput
  head: PageHeadUpdateOneRequiredInput
  layout: ThemeUpdateOneRequiredInput
  creator: UserUpdateOneRequiredInput
  meta: Json
}

input PageUpdateManyDataInput {
  path: String
  name: String
  type: PageType
  index: Int
  meta: Json
}

input PageUpdateManyInput {
  create: [PageCreateInput!]
  update: [PageUpdateWithWhereUniqueNestedInput!]
  upsert: [PageUpsertWithWhereUniqueNestedInput!]
  delete: [PageWhereUniqueInput!]
  connect: [PageWhereUniqueInput!]
  set: [PageWhereUniqueInput!]
  disconnect: [PageWhereUniqueInput!]
  deleteMany: [PageScalarWhereInput!]
  updateMany: [PageUpdateManyWithWhereNestedInput!]
}

input PageUpdateManyMutationInput {
  path: String
  name: String
  type: PageType
  index: Int
  meta: Json
}

input PageUpdateManyWithWhereNestedInput {
  where: PageScalarWhereInput!
  data: PageUpdateManyDataInput!
}

input PageUpdateWithWhereUniqueNestedInput {
  where: PageWhereUniqueInput!
  data: PageUpdateDataInput!
}

input PageUpsertWithWhereUniqueNestedInput {
  where: PageWhereUniqueInput!
  update: PageUpdateDataInput!
  create: PageCreateInput!
}

input PageWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: PageType
  type_not: PageType
  type_in: [PageType!]
  type_not_in: [PageType!]
  index: Int
  index_not: Int
  index_in: [Int!]
  index_not_in: [Int!]
  index_lt: Int
  index_lte: Int
  index_gt: Int
  index_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  label_every: i18nWhereInput
  label_some: i18nWhereInput
  label_none: i18nWhereInput
  head: PageHeadWhereInput
  layout: ThemeWhereInput
  creator: UserWhereInput
  AND: [PageWhereInput!]
  OR: [PageWhereInput!]
  NOT: [PageWhereInput!]
}

input PageWhereUniqueInput {
  id: UUID
  path: String
  name: String
}

type Paragraph {
  id: UUID!
  index: Int!
  text: String
  type: ParagraphType
  markup(where: MarkupWhereInput, orderBy: MarkupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Markup!]
  quotes(where: QuoteWhereInput, orderBy: QuoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Quote!]
  replies(where: ReplyWhereInput, orderBy: ReplyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Reply!]
  meta: Json
}

type ParagraphConnection {
  pageInfo: PageInfo!
  edges: [ParagraphEdge]!
  aggregate: AggregateParagraph!
}

input ParagraphCreateInput {
  id: UUID
  index: Int
  text: String
  type: ParagraphType
  markup: MarkupCreateManyInput
  quotes: QuoteCreateManyInput
  replies: ReplyCreateManyInput
  meta: Json
}

input ParagraphCreateManyInput {
  create: [ParagraphCreateInput!]
  connect: [ParagraphWhereUniqueInput!]
}

type ParagraphEdge {
  node: Paragraph!
  cursor: String!
}

enum ParagraphOrderByInput {
  id_ASC
  id_DESC
  index_ASC
  index_DESC
  text_ASC
  text_DESC
  type_ASC
  type_DESC
  meta_ASC
  meta_DESC
}

type ParagraphPreviousValues {
  id: UUID!
  index: Int!
  text: String
  type: ParagraphType
  meta: Json
}

input ParagraphScalarWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  index: Int
  index_not: Int
  index_in: [Int!]
  index_not_in: [Int!]
  index_lt: Int
  index_lte: Int
  index_gt: Int
  index_gte: Int
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  type: ParagraphType
  type_not: ParagraphType
  type_in: [ParagraphType!]
  type_not_in: [ParagraphType!]
  AND: [ParagraphScalarWhereInput!]
  OR: [ParagraphScalarWhereInput!]
  NOT: [ParagraphScalarWhereInput!]
}

type ParagraphSubscriptionPayload {
  mutation: MutationType!
  node: Paragraph
  updatedFields: [String!]
  previousValues: ParagraphPreviousValues
}

input ParagraphSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ParagraphWhereInput
  AND: [ParagraphSubscriptionWhereInput!]
  OR: [ParagraphSubscriptionWhereInput!]
  NOT: [ParagraphSubscriptionWhereInput!]
}

enum ParagraphType {
  HEADLINE
  TITLE
  SUBTITLE
  QUOTE
  PART
  PARAGRAPH
  IMAGE
}

input ParagraphUpdateDataInput {
  index: Int
  text: String
  type: ParagraphType
  markup: MarkupUpdateManyInput
  quotes: QuoteUpdateManyInput
  replies: ReplyUpdateManyInput
  meta: Json
}

input ParagraphUpdateInput {
  index: Int
  text: String
  type: ParagraphType
  markup: MarkupUpdateManyInput
  quotes: QuoteUpdateManyInput
  replies: ReplyUpdateManyInput
  meta: Json
}

input ParagraphUpdateManyDataInput {
  index: Int
  text: String
  type: ParagraphType
  meta: Json
}

input ParagraphUpdateManyInput {
  create: [ParagraphCreateInput!]
  update: [ParagraphUpdateWithWhereUniqueNestedInput!]
  upsert: [ParagraphUpsertWithWhereUniqueNestedInput!]
  delete: [ParagraphWhereUniqueInput!]
  connect: [ParagraphWhereUniqueInput!]
  set: [ParagraphWhereUniqueInput!]
  disconnect: [ParagraphWhereUniqueInput!]
  deleteMany: [ParagraphScalarWhereInput!]
  updateMany: [ParagraphUpdateManyWithWhereNestedInput!]
}

input ParagraphUpdateManyMutationInput {
  index: Int
  text: String
  type: ParagraphType
  meta: Json
}

input ParagraphUpdateManyWithWhereNestedInput {
  where: ParagraphScalarWhereInput!
  data: ParagraphUpdateManyDataInput!
}

input ParagraphUpdateWithWhereUniqueNestedInput {
  where: ParagraphWhereUniqueInput!
  data: ParagraphUpdateDataInput!
}

input ParagraphUpsertWithWhereUniqueNestedInput {
  where: ParagraphWhereUniqueInput!
  update: ParagraphUpdateDataInput!
  create: ParagraphCreateInput!
}

input ParagraphWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  index: Int
  index_not: Int
  index_in: [Int!]
  index_not_in: [Int!]
  index_lt: Int
  index_lte: Int
  index_gt: Int
  index_gte: Int
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  type: ParagraphType
  type_not: ParagraphType
  type_in: [ParagraphType!]
  type_not_in: [ParagraphType!]
  markup_every: MarkupWhereInput
  markup_some: MarkupWhereInput
  markup_none: MarkupWhereInput
  quotes_every: QuoteWhereInput
  quotes_some: QuoteWhereInput
  quotes_none: QuoteWhereInput
  replies_every: ReplyWhereInput
  replies_some: ReplyWhereInput
  replies_none: ReplyWhereInput
  AND: [ParagraphWhereInput!]
  OR: [ParagraphWhereInput!]
  NOT: [ParagraphWhereInput!]
}

input ParagraphWhereUniqueInput {
  id: UUID
}

type Permission {
  id: UUID!
  type: String!
  loginAdmin: Boolean!
  banned: Boolean!
  news: PermissionType!
  post: PermissionType!
  reply: PermissionType!
  item: PermissionType!
  property: PermissionType!
  user: PermissionType!
  group: PermissionType!
  layout: PermissionType!
  log: PermissionType!
  analytics: PermissionType!
  site: PermissionType!
  admin: PermissionType!
  theme: PermissionType!
  page: PermissionType!
  meta: Json
}

type PermissionConnection {
  pageInfo: PageInfo!
  edges: [PermissionEdge]!
  aggregate: AggregatePermission!
}

input PermissionCreateInput {
  id: UUID
  type: String!
  loginAdmin: Boolean
  banned: Boolean
  news: PermissionTypeCreateOneInput!
  post: PermissionTypeCreateOneInput!
  reply: PermissionTypeCreateOneInput!
  item: PermissionTypeCreateOneInput!
  property: PermissionTypeCreateOneInput!
  user: PermissionTypeCreateOneInput!
  group: PermissionTypeCreateOneInput!
  layout: PermissionTypeCreateOneInput!
  log: PermissionTypeCreateOneInput!
  analytics: PermissionTypeCreateOneInput!
  site: PermissionTypeCreateOneInput!
  admin: PermissionTypeCreateOneInput!
  theme: PermissionTypeCreateOneInput!
  page: PermissionTypeCreateOneInput!
  meta: Json
}

input PermissionCreateOneInput {
  create: PermissionCreateInput
  connect: PermissionWhereUniqueInput
}

type PermissionEdge {
  node: Permission!
  cursor: String!
}

enum PermissionOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  loginAdmin_ASC
  loginAdmin_DESC
  banned_ASC
  banned_DESC
  meta_ASC
  meta_DESC
}

type PermissionPreviousValues {
  id: UUID!
  type: String!
  loginAdmin: Boolean!
  banned: Boolean!
  meta: Json
}

type PermissionSubscriptionPayload {
  mutation: MutationType!
  node: Permission
  updatedFields: [String!]
  previousValues: PermissionPreviousValues
}

input PermissionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PermissionWhereInput
  AND: [PermissionSubscriptionWhereInput!]
  OR: [PermissionSubscriptionWhereInput!]
  NOT: [PermissionSubscriptionWhereInput!]
}

type PermissionType {
  id: UUID!
  owner: Access!
  group: Access!
  anyone: Access!
}

type PermissionTypeConnection {
  pageInfo: PageInfo!
  edges: [PermissionTypeEdge]!
  aggregate: AggregatePermissionType!
}

input PermissionTypeCreateInput {
  id: UUID
  owner: AccessCreateOneInput!
  group: AccessCreateOneInput!
  anyone: AccessCreateOneInput!
}

input PermissionTypeCreateOneInput {
  create: PermissionTypeCreateInput
  connect: PermissionTypeWhereUniqueInput
}

type PermissionTypeEdge {
  node: PermissionType!
  cursor: String!
}

enum PermissionTypeOrderByInput {
  id_ASC
  id_DESC
}

type PermissionTypePreviousValues {
  id: UUID!
}

type PermissionTypeSubscriptionPayload {
  mutation: MutationType!
  node: PermissionType
  updatedFields: [String!]
  previousValues: PermissionTypePreviousValues
}

input PermissionTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PermissionTypeWhereInput
  AND: [PermissionTypeSubscriptionWhereInput!]
  OR: [PermissionTypeSubscriptionWhereInput!]
  NOT: [PermissionTypeSubscriptionWhereInput!]
}

input PermissionTypeUpdateDataInput {
  owner: AccessUpdateOneRequiredInput
  group: AccessUpdateOneRequiredInput
  anyone: AccessUpdateOneRequiredInput
}

input PermissionTypeUpdateInput {
  owner: AccessUpdateOneRequiredInput
  group: AccessUpdateOneRequiredInput
  anyone: AccessUpdateOneRequiredInput
}

input PermissionTypeUpdateOneRequiredInput {
  create: PermissionTypeCreateInput
  update: PermissionTypeUpdateDataInput
  upsert: PermissionTypeUpsertNestedInput
  connect: PermissionTypeWhereUniqueInput
}

input PermissionTypeUpsertNestedInput {
  update: PermissionTypeUpdateDataInput!
  create: PermissionTypeCreateInput!
}

input PermissionTypeWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  owner: AccessWhereInput
  group: AccessWhereInput
  anyone: AccessWhereInput
  AND: [PermissionTypeWhereInput!]
  OR: [PermissionTypeWhereInput!]
  NOT: [PermissionTypeWhereInput!]
}

input PermissionTypeWhereUniqueInput {
  id: UUID
}

input PermissionUpdateDataInput {
  type: String
  loginAdmin: Boolean
  banned: Boolean
  news: PermissionTypeUpdateOneRequiredInput
  post: PermissionTypeUpdateOneRequiredInput
  reply: PermissionTypeUpdateOneRequiredInput
  item: PermissionTypeUpdateOneRequiredInput
  property: PermissionTypeUpdateOneRequiredInput
  user: PermissionTypeUpdateOneRequiredInput
  group: PermissionTypeUpdateOneRequiredInput
  layout: PermissionTypeUpdateOneRequiredInput
  log: PermissionTypeUpdateOneRequiredInput
  analytics: PermissionTypeUpdateOneRequiredInput
  site: PermissionTypeUpdateOneRequiredInput
  admin: PermissionTypeUpdateOneRequiredInput
  theme: PermissionTypeUpdateOneRequiredInput
  page: PermissionTypeUpdateOneRequiredInput
  meta: Json
}

input PermissionUpdateInput {
  type: String
  loginAdmin: Boolean
  banned: Boolean
  news: PermissionTypeUpdateOneRequiredInput
  post: PermissionTypeUpdateOneRequiredInput
  reply: PermissionTypeUpdateOneRequiredInput
  item: PermissionTypeUpdateOneRequiredInput
  property: PermissionTypeUpdateOneRequiredInput
  user: PermissionTypeUpdateOneRequiredInput
  group: PermissionTypeUpdateOneRequiredInput
  layout: PermissionTypeUpdateOneRequiredInput
  log: PermissionTypeUpdateOneRequiredInput
  analytics: PermissionTypeUpdateOneRequiredInput
  site: PermissionTypeUpdateOneRequiredInput
  admin: PermissionTypeUpdateOneRequiredInput
  theme: PermissionTypeUpdateOneRequiredInput
  page: PermissionTypeUpdateOneRequiredInput
  meta: Json
}

input PermissionUpdateManyMutationInput {
  type: String
  loginAdmin: Boolean
  banned: Boolean
  meta: Json
}

input PermissionUpdateOneRequiredInput {
  create: PermissionCreateInput
  update: PermissionUpdateDataInput
  upsert: PermissionUpsertNestedInput
  connect: PermissionWhereUniqueInput
}

input PermissionUpsertNestedInput {
  update: PermissionUpdateDataInput!
  create: PermissionCreateInput!
}

input PermissionWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  loginAdmin: Boolean
  loginAdmin_not: Boolean
  banned: Boolean
  banned_not: Boolean
  news: PermissionTypeWhereInput
  post: PermissionTypeWhereInput
  reply: PermissionTypeWhereInput
  item: PermissionTypeWhereInput
  property: PermissionTypeWhereInput
  user: PermissionTypeWhereInput
  group: PermissionTypeWhereInput
  layout: PermissionTypeWhereInput
  log: PermissionTypeWhereInput
  analytics: PermissionTypeWhereInput
  site: PermissionTypeWhereInput
  admin: PermissionTypeWhereInput
  theme: PermissionTypeWhereInput
  page: PermissionTypeWhereInput
  AND: [PermissionWhereInput!]
  OR: [PermissionWhereInput!]
  NOT: [PermissionWhereInput!]
}

input PermissionWhereUniqueInput {
  id: UUID
  type: String
}

type Post {
  id: UUID!
  title: String!
  published: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  validUntil: DateTime!
  author: User!
  banner(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Image!]
  paragraphs(where: ParagraphWhereInput, orderBy: ParagraphOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Paragraph!]
  replies(where: ReplyWhereInput, orderBy: ReplyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Reply!]
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag!]
  meta: Json
}

type PostConnection {
  pageInfo: PageInfo!
  edges: [PostEdge]!
  aggregate: AggregatePost!
}

input PostCreateInput {
  id: UUID
  title: String!
  published: Boolean
  validUntil: DateTime!
  author: UserCreateOneInput!
  banner: ImageCreateManyInput
  paragraphs: ParagraphCreateManyInput
  replies: ReplyCreateManyInput
  tags: TagCreateManyInput
  meta: Json
}

type PostEdge {
  node: Post!
  cursor: String!
}

enum PostOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  published_ASC
  published_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  validUntil_ASC
  validUntil_DESC
  meta_ASC
  meta_DESC
}

type PostPreviousValues {
  id: UUID!
  title: String!
  published: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  validUntil: DateTime!
  meta: Json
}

type PostSubscriptionPayload {
  mutation: MutationType!
  node: Post
  updatedFields: [String!]
  previousValues: PostPreviousValues
}

input PostSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PostWhereInput
  AND: [PostSubscriptionWhereInput!]
  OR: [PostSubscriptionWhereInput!]
  NOT: [PostSubscriptionWhereInput!]
}

input PostUpdateInput {
  title: String
  published: Boolean
  validUntil: DateTime
  author: UserUpdateOneRequiredInput
  banner: ImageUpdateManyInput
  paragraphs: ParagraphUpdateManyInput
  replies: ReplyUpdateManyInput
  tags: TagUpdateManyInput
  meta: Json
}

input PostUpdateManyMutationInput {
  title: String
  published: Boolean
  validUntil: DateTime
  meta: Json
}

input PostWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  published: Boolean
  published_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  validUntil: DateTime
  validUntil_not: DateTime
  validUntil_in: [DateTime!]
  validUntil_not_in: [DateTime!]
  validUntil_lt: DateTime
  validUntil_lte: DateTime
  validUntil_gt: DateTime
  validUntil_gte: DateTime
  author: UserWhereInput
  banner_every: ImageWhereInput
  banner_some: ImageWhereInput
  banner_none: ImageWhereInput
  paragraphs_every: ParagraphWhereInput
  paragraphs_some: ParagraphWhereInput
  paragraphs_none: ParagraphWhereInput
  replies_every: ReplyWhereInput
  replies_some: ReplyWhereInput
  replies_none: ReplyWhereInput
  tags_every: TagWhereInput
  tags_some: TagWhereInput
  tags_none: TagWhereInput
  AND: [PostWhereInput!]
  OR: [PostWhereInput!]
  NOT: [PostWhereInput!]
}

input PostWhereUniqueInput {
  id: UUID
}

type Property {
  id: UUID!
  propertyId: String!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  description: String
  i18n(where: i18nWhereInput, orderBy: i18nOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [i18n!]
  logs(where: LogWhereInput, orderBy: LogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Log!]
  creator: User!
  meta: Json
}

type PropertyConnection {
  pageInfo: PageInfo!
  edges: [PropertyEdge]!
  aggregate: AggregateProperty!
}

input PropertyCreateInput {
  id: UUID
  propertyId: String!
  name: String!
  description: String
  i18n: i18nCreateManyInput
  logs: LogCreateManyInput
  creator: UserCreateOneInput!
  meta: Json
}

input PropertyCreateOneInput {
  create: PropertyCreateInput
  connect: PropertyWhereUniqueInput
}

type PropertyEdge {
  node: Property!
  cursor: String!
}

enum PropertyOrderByInput {
  id_ASC
  id_DESC
  propertyId_ASC
  propertyId_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  description_ASC
  description_DESC
  meta_ASC
  meta_DESC
}

type PropertyPreviousValues {
  id: UUID!
  propertyId: String!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  description: String
  meta: Json
}

type PropertySubscriptionPayload {
  mutation: MutationType!
  node: Property
  updatedFields: [String!]
  previousValues: PropertyPreviousValues
}

input PropertySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PropertyWhereInput
  AND: [PropertySubscriptionWhereInput!]
  OR: [PropertySubscriptionWhereInput!]
  NOT: [PropertySubscriptionWhereInput!]
}

input PropertyUpdateDataInput {
  propertyId: String
  name: String
  description: String
  i18n: i18nUpdateManyInput
  logs: LogUpdateManyInput
  creator: UserUpdateOneRequiredInput
  meta: Json
}

input PropertyUpdateInput {
  propertyId: String
  name: String
  description: String
  i18n: i18nUpdateManyInput
  logs: LogUpdateManyInput
  creator: UserUpdateOneRequiredInput
  meta: Json
}

input PropertyUpdateManyMutationInput {
  propertyId: String
  name: String
  description: String
  meta: Json
}

input PropertyUpdateOneRequiredInput {
  create: PropertyCreateInput
  update: PropertyUpdateDataInput
  upsert: PropertyUpsertNestedInput
  connect: PropertyWhereUniqueInput
}

input PropertyUpsertNestedInput {
  update: PropertyUpdateDataInput!
  create: PropertyCreateInput!
}

input PropertyWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  propertyId: String
  propertyId_not: String
  propertyId_in: [String!]
  propertyId_not_in: [String!]
  propertyId_lt: String
  propertyId_lte: String
  propertyId_gt: String
  propertyId_gte: String
  propertyId_contains: String
  propertyId_not_contains: String
  propertyId_starts_with: String
  propertyId_not_starts_with: String
  propertyId_ends_with: String
  propertyId_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  i18n_every: i18nWhereInput
  i18n_some: i18nWhereInput
  i18n_none: i18nWhereInput
  logs_every: LogWhereInput
  logs_some: LogWhereInput
  logs_none: LogWhereInput
  creator: UserWhereInput
  AND: [PropertyWhereInput!]
  OR: [PropertyWhereInput!]
  NOT: [PropertyWhereInput!]
}

input PropertyWhereUniqueInput {
  id: UUID
  propertyId: String
  name: String
}

type Query {
  # access(where: AccessWhereUniqueInput!): Access
  # accesses(where: AccessWhereInput, orderBy: AccessOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Access]!
  # accessesConnection(where: AccessWhereInput, orderBy: AccessOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AccessConnection!
  admin(where: AdminWhereUniqueInput!): Admin
  admins(where: AdminWhereInput, orderBy: AdminOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Admin]!
  adminsConnection(where: AdminWhereInput, orderBy: AdminOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AdminConnection!
  # entity(where: EntityWhereUniqueInput!): Entity
  # entities(where: EntityWhereInput, orderBy: EntityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Entity]!
  # entitiesConnection(where: EntityWhereInput, orderBy: EntityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EntityConnection!
  # event(where: EventWhereUniqueInput!): Event
  # events(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Event]!
  # eventsConnection(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EventConnection!
  file(where: FileWhereUniqueInput!): File
  files(where: FileWhereInput, orderBy: FileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [File]!
  filesConnection(where: FileWhereInput, orderBy: FileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FileConnection!
  group(where: GroupWhereUniqueInput!): Group
  groups(where: GroupWhereInput, orderBy: GroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Group]!
  groupsConnection(where: GroupWhereInput, orderBy: GroupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GroupConnection!
  image(where: ImageWhereUniqueInput!): Image
  images(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Image]!
  imagesConnection(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ImageConnection!
  item(where: ItemWhereUniqueInput!): Item
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item]!
  itemsConnection(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ItemConnection!
  lang(where: LangWhereUniqueInput!): Lang
  langs(where: LangWhereInput, orderBy: LangOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Lang]!
  langsConnection(where: LangWhereInput, orderBy: LangOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LangConnection!
  log(where: LogWhereUniqueInput!): Log
  logs(where: LogWhereInput, orderBy: LogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Log]!
  logsConnection(where: LogWhereInput, orderBy: LogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LogConnection!
  # markup(where: MarkupWhereUniqueInput!): Markup
  # markups(where: MarkupWhereInput, orderBy: MarkupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Markup]!
  # markupsConnection(where: MarkupWhereInput, orderBy: MarkupOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MarkupConnection!
  # measurement(where: MeasurementWhereUniqueInput!): Measurement
  # measurements(where: MeasurementWhereInput, orderBy: MeasurementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Measurement]!
  # measurementsConnection(where: MeasurementWhereInput, orderBy: MeasurementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MeasurementConnection!
  news(where: NewsWhereUniqueInput!): News
  newses(where: NewsWhereInput, orderBy: NewsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [News]!
  newsesConnection(where: NewsWhereInput, orderBy: NewsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NewsConnection!
  # note(where: NoteWhereUniqueInput!): Note
  # notes(where: NoteWhereInput, orderBy: NoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Note]!
  # notesConnection(where: NoteWhereInput, orderBy: NoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NoteConnection!
  page(where: PageWhereUniqueInput!): Page
  pages(where: PageWhereInput, orderBy: PageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Page]!
  pagesConnection(where: PageWhereInput, orderBy: PageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PageConnection!
  # pageHead(where: PageHeadWhereUniqueInput!): PageHead
  # pageHeads(where: PageHeadWhereInput, orderBy: PageHeadOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PageHead]!
  # pageHeadsConnection(where: PageHeadWhereInput, orderBy: PageHeadOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PageHeadConnection!
  # pageMeta(where: PageMetaWhereUniqueInput!): PageMeta
  # pageMetas(where: PageMetaWhereInput, orderBy: PageMetaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PageMeta]!
  # pageMetasConnection(where: PageMetaWhereInput, orderBy: PageMetaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PageMetaConnection!
  # paragraph(where: ParagraphWhereUniqueInput!): Paragraph
  # paragraphs(where: ParagraphWhereInput, orderBy: ParagraphOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Paragraph]!
  # paragraphsConnection(where: ParagraphWhereInput, orderBy: ParagraphOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ParagraphConnection!
  permission(where: PermissionWhereUniqueInput!): Permission
  permissions(where: PermissionWhereInput, orderBy: PermissionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Permission]!
  permissionsConnection(where: PermissionWhereInput, orderBy: PermissionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PermissionConnection!
  # permissionType(where: PermissionTypeWhereUniqueInput!): PermissionType
  # permissionTypes(where: PermissionTypeWhereInput, orderBy: PermissionTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PermissionType]!
  # permissionTypesConnection(where: PermissionTypeWhereInput, orderBy: PermissionTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PermissionTypeConnection!
  post(where: PostWhereUniqueInput!): Post
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post]!
  postsConnection(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PostConnection!
  property(where: PropertyWhereUniqueInput!): Property
  properties(where: PropertyWhereInput, orderBy: PropertyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Property]!
  propertiesConnection(where: PropertyWhereInput, orderBy: PropertyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PropertyConnection!
  # quote(where: QuoteWhereUniqueInput!): Quote
  # quotes(where: QuoteWhereInput, orderBy: QuoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Quote]!
  # quotesConnection(where: QuoteWhereInput, orderBy: QuoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): QuoteConnection!
  # reply(where: ReplyWhereUniqueInput!): Reply
  # replies(where: ReplyWhereInput, orderBy: ReplyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Reply]!
  # repliesConnection(where: ReplyWhereInput, orderBy: ReplyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReplyConnection!
  site(where: SiteWhereUniqueInput!): Site
  sites(where: SiteWhereInput, orderBy: SiteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Site]!
  sitesConnection(where: SiteWhereInput, orderBy: SiteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SiteConnection!
  # statement(where: StatementWhereUniqueInput!): Statement
  # statements(where: StatementWhereInput, orderBy: StatementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Statement]!
  # statementsConnection(where: StatementWhereInput, orderBy: StatementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StatementConnection!
  tag(where: TagWhereUniqueInput!): Tag
  tags(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tag]!
  tagsConnection(where: TagWhereInput, orderBy: TagOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TagConnection!
  theme(where: ThemeWhereUniqueInput!): Theme
  themes(where: ThemeWhereInput, orderBy: ThemeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Theme]!
  themesConnection(where: ThemeWhereInput, orderBy: ThemeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ThemeConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  # i18n(where: i18nWhereUniqueInput!): i18n
  # i18ns(where: i18nWhereInput, orderBy: i18nOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [i18n]!
  # i18nsConnection(where: i18nWhereInput, orderBy: i18nOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): i18nConnection!
  node(id: ID!): Node
}

type Quote {
  id: UUID!
  start: Int!
  end: Int!
  type: QuoteType!
  createdAt: DateTime!
  updatedAt: DateTime!
  user: User!
  notes(where: NoteWhereInput, orderBy: NoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Note!]
  replies(where: ReplyWhereInput, orderBy: ReplyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Reply!]
  meta: Json
}

type QuoteConnection {
  pageInfo: PageInfo!
  edges: [QuoteEdge]!
  aggregate: AggregateQuote!
}

input QuoteCreateInput {
  id: UUID
  start: Int
  end: Int
  type: QuoteType
  user: UserCreateOneInput!
  notes: NoteCreateManyInput
  replies: ReplyCreateManyInput
  meta: Json
}

input QuoteCreateManyInput {
  create: [QuoteCreateInput!]
  connect: [QuoteWhereUniqueInput!]
}

type QuoteEdge {
  node: Quote!
  cursor: String!
}

enum QuoteOrderByInput {
  id_ASC
  id_DESC
  start_ASC
  start_DESC
  end_ASC
  end_DESC
  type_ASC
  type_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  meta_ASC
  meta_DESC
}

type QuotePreviousValues {
  id: UUID!
  start: Int!
  end: Int!
  type: QuoteType!
  createdAt: DateTime!
  updatedAt: DateTime!
  meta: Json
}

input QuoteScalarWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  start: Int
  start_not: Int
  start_in: [Int!]
  start_not_in: [Int!]
  start_lt: Int
  start_lte: Int
  start_gt: Int
  start_gte: Int
  end: Int
  end_not: Int
  end_in: [Int!]
  end_not_in: [Int!]
  end_lt: Int
  end_lte: Int
  end_gt: Int
  end_gte: Int
  type: QuoteType
  type_not: QuoteType
  type_in: [QuoteType!]
  type_not_in: [QuoteType!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [QuoteScalarWhereInput!]
  OR: [QuoteScalarWhereInput!]
  NOT: [QuoteScalarWhereInput!]
}

type QuoteSubscriptionPayload {
  mutation: MutationType!
  node: Quote
  updatedFields: [String!]
  previousValues: QuotePreviousValues
}

input QuoteSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: QuoteWhereInput
  AND: [QuoteSubscriptionWhereInput!]
  OR: [QuoteSubscriptionWhereInput!]
  NOT: [QuoteSubscriptionWhereInput!]
}

enum QuoteType {
  HIGHLIGHT
  NOTE
  REPLY
}

input QuoteUpdateDataInput {
  start: Int
  end: Int
  type: QuoteType
  user: UserUpdateOneRequiredInput
  notes: NoteUpdateManyInput
  replies: ReplyUpdateManyInput
  meta: Json
}

input QuoteUpdateInput {
  start: Int
  end: Int
  type: QuoteType
  user: UserUpdateOneRequiredInput
  notes: NoteUpdateManyInput
  replies: ReplyUpdateManyInput
  meta: Json
}

input QuoteUpdateManyDataInput {
  start: Int
  end: Int
  type: QuoteType
  meta: Json
}

input QuoteUpdateManyInput {
  create: [QuoteCreateInput!]
  update: [QuoteUpdateWithWhereUniqueNestedInput!]
  upsert: [QuoteUpsertWithWhereUniqueNestedInput!]
  delete: [QuoteWhereUniqueInput!]
  connect: [QuoteWhereUniqueInput!]
  set: [QuoteWhereUniqueInput!]
  disconnect: [QuoteWhereUniqueInput!]
  deleteMany: [QuoteScalarWhereInput!]
  updateMany: [QuoteUpdateManyWithWhereNestedInput!]
}

input QuoteUpdateManyMutationInput {
  start: Int
  end: Int
  type: QuoteType
  meta: Json
}

input QuoteUpdateManyWithWhereNestedInput {
  where: QuoteScalarWhereInput!
  data: QuoteUpdateManyDataInput!
}

input QuoteUpdateWithWhereUniqueNestedInput {
  where: QuoteWhereUniqueInput!
  data: QuoteUpdateDataInput!
}

input QuoteUpsertWithWhereUniqueNestedInput {
  where: QuoteWhereUniqueInput!
  update: QuoteUpdateDataInput!
  create: QuoteCreateInput!
}

input QuoteWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  start: Int
  start_not: Int
  start_in: [Int!]
  start_not_in: [Int!]
  start_lt: Int
  start_lte: Int
  start_gt: Int
  start_gte: Int
  end: Int
  end_not: Int
  end_in: [Int!]
  end_not_in: [Int!]
  end_lt: Int
  end_lte: Int
  end_gt: Int
  end_gte: Int
  type: QuoteType
  type_not: QuoteType
  type_in: [QuoteType!]
  type_not_in: [QuoteType!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  user: UserWhereInput
  notes_every: NoteWhereInput
  notes_some: NoteWhereInput
  notes_none: NoteWhereInput
  replies_every: ReplyWhereInput
  replies_some: ReplyWhereInput
  replies_none: ReplyWhereInput
  AND: [QuoteWhereInput!]
  OR: [QuoteWhereInput!]
  NOT: [QuoteWhereInput!]
}

input QuoteWhereUniqueInput {
  id: UUID
}

type Reply {
  id: UUID!
  replyId: Int!
  content: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  user: User!
  replies(where: ReplyWhereInput, orderBy: ReplyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Reply!]
  meta: Json
}

type ReplyConnection {
  pageInfo: PageInfo!
  edges: [ReplyEdge]!
  aggregate: AggregateReply!
}

input ReplyCreateInput {
  id: UUID
  replyId: Int!
  content: String!
  user: UserCreateOneInput!
  replies: ReplyCreateManyWithoutRepliesInput
  meta: Json
}

input ReplyCreateManyInput {
  create: [ReplyCreateInput!]
  connect: [ReplyWhereUniqueInput!]
}

input ReplyCreateManyWithoutRepliesInput {
  create: [ReplyCreateWithoutRepliesInput!]
  connect: [ReplyWhereUniqueInput!]
}

input ReplyCreateWithoutRepliesInput {
  id: UUID
  replyId: Int!
  content: String!
  user: UserCreateOneInput!
  meta: Json
}

type ReplyEdge {
  node: Reply!
  cursor: String!
}

enum ReplyOrderByInput {
  id_ASC
  id_DESC
  replyId_ASC
  replyId_DESC
  content_ASC
  content_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  meta_ASC
  meta_DESC
}

type ReplyPreviousValues {
  id: UUID!
  replyId: Int!
  content: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  meta: Json
}

input ReplyScalarWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  replyId: Int
  replyId_not: Int
  replyId_in: [Int!]
  replyId_not_in: [Int!]
  replyId_lt: Int
  replyId_lte: Int
  replyId_gt: Int
  replyId_gte: Int
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ReplyScalarWhereInput!]
  OR: [ReplyScalarWhereInput!]
  NOT: [ReplyScalarWhereInput!]
}

type ReplySubscriptionPayload {
  mutation: MutationType!
  node: Reply
  updatedFields: [String!]
  previousValues: ReplyPreviousValues
}

input ReplySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReplyWhereInput
  AND: [ReplySubscriptionWhereInput!]
  OR: [ReplySubscriptionWhereInput!]
  NOT: [ReplySubscriptionWhereInput!]
}

input ReplyUpdateDataInput {
  replyId: Int
  content: String
  user: UserUpdateOneRequiredInput
  replies: ReplyUpdateManyWithoutRepliesInput
  meta: Json
}

input ReplyUpdateInput {
  replyId: Int
  content: String
  user: UserUpdateOneRequiredInput
  replies: ReplyUpdateManyWithoutRepliesInput
  meta: Json
}

input ReplyUpdateManyDataInput {
  replyId: Int
  content: String
  meta: Json
}

input ReplyUpdateManyInput {
  create: [ReplyCreateInput!]
  update: [ReplyUpdateWithWhereUniqueNestedInput!]
  upsert: [ReplyUpsertWithWhereUniqueNestedInput!]
  delete: [ReplyWhereUniqueInput!]
  connect: [ReplyWhereUniqueInput!]
  set: [ReplyWhereUniqueInput!]
  disconnect: [ReplyWhereUniqueInput!]
  deleteMany: [ReplyScalarWhereInput!]
  updateMany: [ReplyUpdateManyWithWhereNestedInput!]
}

input ReplyUpdateManyMutationInput {
  replyId: Int
  content: String
  meta: Json
}

input ReplyUpdateManyWithoutRepliesInput {
  create: [ReplyCreateWithoutRepliesInput!]
  delete: [ReplyWhereUniqueInput!]
  connect: [ReplyWhereUniqueInput!]
  set: [ReplyWhereUniqueInput!]
  disconnect: [ReplyWhereUniqueInput!]
  update: [ReplyUpdateWithWhereUniqueWithoutRepliesInput!]
  upsert: [ReplyUpsertWithWhereUniqueWithoutRepliesInput!]
  deleteMany: [ReplyScalarWhereInput!]
  updateMany: [ReplyUpdateManyWithWhereNestedInput!]
}

input ReplyUpdateManyWithWhereNestedInput {
  where: ReplyScalarWhereInput!
  data: ReplyUpdateManyDataInput!
}

input ReplyUpdateWithoutRepliesDataInput {
  replyId: Int
  content: String
  user: UserUpdateOneRequiredInput
  meta: Json
}

input ReplyUpdateWithWhereUniqueNestedInput {
  where: ReplyWhereUniqueInput!
  data: ReplyUpdateDataInput!
}

input ReplyUpdateWithWhereUniqueWithoutRepliesInput {
  where: ReplyWhereUniqueInput!
  data: ReplyUpdateWithoutRepliesDataInput!
}

input ReplyUpsertWithWhereUniqueNestedInput {
  where: ReplyWhereUniqueInput!
  update: ReplyUpdateDataInput!
  create: ReplyCreateInput!
}

input ReplyUpsertWithWhereUniqueWithoutRepliesInput {
  where: ReplyWhereUniqueInput!
  update: ReplyUpdateWithoutRepliesDataInput!
  create: ReplyCreateWithoutRepliesInput!
}

input ReplyWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  replyId: Int
  replyId_not: Int
  replyId_in: [Int!]
  replyId_not_in: [Int!]
  replyId_lt: Int
  replyId_lte: Int
  replyId_gt: Int
  replyId_gte: Int
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  user: UserWhereInput
  replies_every: ReplyWhereInput
  replies_some: ReplyWhereInput
  replies_none: ReplyWhereInput
  AND: [ReplyWhereInput!]
  OR: [ReplyWhereInput!]
  NOT: [ReplyWhereInput!]
}

input ReplyWhereUniqueInput {
  id: UUID
  replyId: Int
}

type Site {
  id: UUID!
  name: String!
  domain: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  menu(where: PageWhereInput, orderBy: PageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Page!]
  creator: User!
  meta: Json
}

type SiteConnection {
  pageInfo: PageInfo!
  edges: [SiteEdge]!
  aggregate: AggregateSite!
}

input SiteCreateInput {
  id: UUID
  name: String!
  domain: String!
  menu: PageCreateManyInput
  creator: UserCreateOneInput!
  meta: Json
}

type SiteEdge {
  node: Site!
  cursor: String!
}

enum SiteOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  domain_ASC
  domain_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  meta_ASC
  meta_DESC
}

type SitePreviousValues {
  id: UUID!
  name: String!
  domain: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  meta: Json
}

type SiteSubscriptionPayload {
  mutation: MutationType!
  node: Site
  updatedFields: [String!]
  previousValues: SitePreviousValues
}

input SiteSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SiteWhereInput
  AND: [SiteSubscriptionWhereInput!]
  OR: [SiteSubscriptionWhereInput!]
  NOT: [SiteSubscriptionWhereInput!]
}

input SiteUpdateInput {
  name: String
  domain: String
  menu: PageUpdateManyInput
  creator: UserUpdateOneRequiredInput
  meta: Json
}

input SiteUpdateManyMutationInput {
  name: String
  domain: String
  meta: Json
}

input SiteWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  domain: String
  domain_not: String
  domain_in: [String!]
  domain_not_in: [String!]
  domain_lt: String
  domain_lte: String
  domain_gt: String
  domain_gte: String
  domain_contains: String
  domain_not_contains: String
  domain_starts_with: String
  domain_not_starts_with: String
  domain_ends_with: String
  domain_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  menu_every: PageWhereInput
  menu_some: PageWhereInput
  menu_none: PageWhereInput
  creator: UserWhereInput
  AND: [SiteWhereInput!]
  OR: [SiteWhereInput!]
  NOT: [SiteWhereInput!]
}

input SiteWhereUniqueInput {
  id: UUID
  name: String
}

type Statement {
  id: UUID!
  index: Int
  entity: Entity!
  property: Property!
  meta: Json
}

type StatementConnection {
  pageInfo: PageInfo!
  edges: [StatementEdge]!
  aggregate: AggregateStatement!
}

input StatementCreateInput {
  id: UUID
  index: Int
  entity: EntityCreateOneInput!
  property: PropertyCreateOneInput!
  meta: Json
}

input StatementCreateManyInput {
  create: [StatementCreateInput!]
  connect: [StatementWhereUniqueInput!]
}

type StatementEdge {
  node: Statement!
  cursor: String!
}

enum StatementOrderByInput {
  id_ASC
  id_DESC
  index_ASC
  index_DESC
  meta_ASC
  meta_DESC
}

type StatementPreviousValues {
  id: UUID!
  index: Int
  meta: Json
}

input StatementScalarWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  index: Int
  index_not: Int
  index_in: [Int!]
  index_not_in: [Int!]
  index_lt: Int
  index_lte: Int
  index_gt: Int
  index_gte: Int
  AND: [StatementScalarWhereInput!]
  OR: [StatementScalarWhereInput!]
  NOT: [StatementScalarWhereInput!]
}

type StatementSubscriptionPayload {
  mutation: MutationType!
  node: Statement
  updatedFields: [String!]
  previousValues: StatementPreviousValues
}

input StatementSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StatementWhereInput
  AND: [StatementSubscriptionWhereInput!]
  OR: [StatementSubscriptionWhereInput!]
  NOT: [StatementSubscriptionWhereInput!]
}

input StatementUpdateDataInput {
  index: Int
  entity: EntityUpdateOneRequiredInput
  property: PropertyUpdateOneRequiredInput
  meta: Json
}

input StatementUpdateInput {
  index: Int
  entity: EntityUpdateOneRequiredInput
  property: PropertyUpdateOneRequiredInput
  meta: Json
}

input StatementUpdateManyDataInput {
  index: Int
  meta: Json
}

input StatementUpdateManyInput {
  create: [StatementCreateInput!]
  update: [StatementUpdateWithWhereUniqueNestedInput!]
  upsert: [StatementUpsertWithWhereUniqueNestedInput!]
  delete: [StatementWhereUniqueInput!]
  connect: [StatementWhereUniqueInput!]
  set: [StatementWhereUniqueInput!]
  disconnect: [StatementWhereUniqueInput!]
  deleteMany: [StatementScalarWhereInput!]
  updateMany: [StatementUpdateManyWithWhereNestedInput!]
}

input StatementUpdateManyMutationInput {
  index: Int
  meta: Json
}

input StatementUpdateManyWithWhereNestedInput {
  where: StatementScalarWhereInput!
  data: StatementUpdateManyDataInput!
}

input StatementUpdateWithWhereUniqueNestedInput {
  where: StatementWhereUniqueInput!
  data: StatementUpdateDataInput!
}

input StatementUpsertWithWhereUniqueNestedInput {
  where: StatementWhereUniqueInput!
  update: StatementUpdateDataInput!
  create: StatementCreateInput!
}

input StatementWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  index: Int
  index_not: Int
  index_in: [Int!]
  index_not_in: [Int!]
  index_lt: Int
  index_lte: Int
  index_gt: Int
  index_gte: Int
  entity: EntityWhereInput
  property: PropertyWhereInput
  AND: [StatementWhereInput!]
  OR: [StatementWhereInput!]
  NOT: [StatementWhereInput!]
}

input StatementWhereUniqueInput {
  id: UUID
}

# type Subscription {
#   access(where: AccessSubscriptionWhereInput): AccessSubscriptionPayload
#   admin(where: AdminSubscriptionWhereInput): AdminSubscriptionPayload
#   entity(where: EntitySubscriptionWhereInput): EntitySubscriptionPayload
#   event(where: EventSubscriptionWhereInput): EventSubscriptionPayload
#   file(where: FileSubscriptionWhereInput): FileSubscriptionPayload
#   group(where: GroupSubscriptionWhereInput): GroupSubscriptionPayload
#   image(where: ImageSubscriptionWhereInput): ImageSubscriptionPayload
#   item(where: ItemSubscriptionWhereInput): ItemSubscriptionPayload
#   lang(where: LangSubscriptionWhereInput): LangSubscriptionPayload
#   log(where: LogSubscriptionWhereInput): LogSubscriptionPayload
#   markup(where: MarkupSubscriptionWhereInput): MarkupSubscriptionPayload
#   measurement(where: MeasurementSubscriptionWhereInput): MeasurementSubscriptionPayload
#   news(where: NewsSubscriptionWhereInput): NewsSubscriptionPayload
#   note(where: NoteSubscriptionWhereInput): NoteSubscriptionPayload
#   page(where: PageSubscriptionWhereInput): PageSubscriptionPayload
#   pageHead(where: PageHeadSubscriptionWhereInput): PageHeadSubscriptionPayload
#   pageMeta(where: PageMetaSubscriptionWhereInput): PageMetaSubscriptionPayload
#   paragraph(where: ParagraphSubscriptionWhereInput): ParagraphSubscriptionPayload
#   permission(where: PermissionSubscriptionWhereInput): PermissionSubscriptionPayload
#   permissionType(where: PermissionTypeSubscriptionWhereInput): PermissionTypeSubscriptionPayload
#   post(where: PostSubscriptionWhereInput): PostSubscriptionPayload
#   property(where: PropertySubscriptionWhereInput): PropertySubscriptionPayload
#   quote(where: QuoteSubscriptionWhereInput): QuoteSubscriptionPayload
#   reply(where: ReplySubscriptionWhereInput): ReplySubscriptionPayload
#   site(where: SiteSubscriptionWhereInput): SiteSubscriptionPayload
#   statement(where: StatementSubscriptionWhereInput): StatementSubscriptionPayload
#   tag(where: TagSubscriptionWhereInput): TagSubscriptionPayload
#   theme(where: ThemeSubscriptionWhereInput): ThemeSubscriptionPayload
#   user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
#   i18n(where: i18nSubscriptionWhereInput): i18nSubscriptionPayload
# }

type Tag {
  id: ID!
  name: String!
  description: String
  createdAt: DateTime!
  updatedAt: DateTime!
  meta: Json
}

type TagConnection {
  pageInfo: PageInfo!
  edges: [TagEdge]!
  aggregate: AggregateTag!
}

input TagCreateInput {
  id: ID
  name: String!
  description: String
  meta: Json
}

input TagCreateManyInput {
  create: [TagCreateInput!]
  connect: [TagWhereUniqueInput!]
}

type TagEdge {
  node: Tag!
  cursor: String!
}

enum TagOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  meta_ASC
  meta_DESC
}

type TagPreviousValues {
  id: ID!
  name: String!
  description: String
  createdAt: DateTime!
  updatedAt: DateTime!
  meta: Json
}

input TagScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TagScalarWhereInput!]
  OR: [TagScalarWhereInput!]
  NOT: [TagScalarWhereInput!]
}

type TagSubscriptionPayload {
  mutation: MutationType!
  node: Tag
  updatedFields: [String!]
  previousValues: TagPreviousValues
}

input TagSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TagWhereInput
  AND: [TagSubscriptionWhereInput!]
  OR: [TagSubscriptionWhereInput!]
  NOT: [TagSubscriptionWhereInput!]
}

input TagUpdateDataInput {
  name: String
  description: String
  meta: Json
}

input TagUpdateInput {
  name: String
  description: String
  meta: Json
}

input TagUpdateManyDataInput {
  name: String
  description: String
  meta: Json
}

input TagUpdateManyInput {
  create: [TagCreateInput!]
  update: [TagUpdateWithWhereUniqueNestedInput!]
  upsert: [TagUpsertWithWhereUniqueNestedInput!]
  delete: [TagWhereUniqueInput!]
  connect: [TagWhereUniqueInput!]
  set: [TagWhereUniqueInput!]
  disconnect: [TagWhereUniqueInput!]
  deleteMany: [TagScalarWhereInput!]
  updateMany: [TagUpdateManyWithWhereNestedInput!]
}

input TagUpdateManyMutationInput {
  name: String
  description: String
  meta: Json
}

input TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput!
  data: TagUpdateManyDataInput!
}

input TagUpdateWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput!
  data: TagUpdateDataInput!
}

input TagUpsertWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput!
  update: TagUpdateDataInput!
  create: TagCreateInput!
}

input TagWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TagWhereInput!]
  OR: [TagWhereInput!]
  NOT: [TagWhereInput!]
}

input TagWhereUniqueInput {
  id: ID
  name: String
}

type Theme {
  id: UUID!
  name: String!
  description: String
  component: String
  type: ThemeType
  target: ThemeTarget
  createdAt: DateTime!
  updatedAt: DateTime!
  preview(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Image!]
  creator: User!
  meta: Json
}

type ThemeConnection {
  pageInfo: PageInfo!
  edges: [ThemeEdge]!
  aggregate: AggregateTheme!
}

input ThemeCreateInput {
  id: UUID
  name: String!
  description: String
  component: String
  type: ThemeType
  target: ThemeTarget
  preview: ImageCreateManyInput
  creator: UserCreateOneInput!
  meta: Json
}

input ThemeCreateOneInput {
  create: ThemeCreateInput
  connect: ThemeWhereUniqueInput
}

type ThemeEdge {
  node: Theme!
  cursor: String!
}

enum ThemeOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  component_ASC
  component_DESC
  type_ASC
  type_DESC
  target_ASC
  target_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  meta_ASC
  meta_DESC
}

type ThemePreviousValues {
  id: UUID!
  name: String!
  description: String
  component: String
  type: ThemeType
  target: ThemeTarget
  createdAt: DateTime!
  updatedAt: DateTime!
  meta: Json
}

type ThemeSubscriptionPayload {
  mutation: MutationType!
  node: Theme
  updatedFields: [String!]
  previousValues: ThemePreviousValues
}

input ThemeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ThemeWhereInput
  AND: [ThemeSubscriptionWhereInput!]
  OR: [ThemeSubscriptionWhereInput!]
  NOT: [ThemeSubscriptionWhereInput!]
}

enum ThemeTarget {
  ITEM
  NEWS
  POST
  USER
  HOME
  GENERAL
}

enum ThemeType {
  OVERVIEW
  THEME
  LIST
  GROUP
  SINGLE
}

input ThemeUpdateDataInput {
  name: String
  description: String
  component: String
  type: ThemeType
  target: ThemeTarget
  preview: ImageUpdateManyInput
  creator: UserUpdateOneRequiredInput
  meta: Json
}

input ThemeUpdateInput {
  name: String
  description: String
  component: String
  type: ThemeType
  target: ThemeTarget
  preview: ImageUpdateManyInput
  creator: UserUpdateOneRequiredInput
  meta: Json
}

input ThemeUpdateManyMutationInput {
  name: String
  description: String
  component: String
  type: ThemeType
  target: ThemeTarget
  meta: Json
}

input ThemeUpdateOneRequiredInput {
  create: ThemeCreateInput
  update: ThemeUpdateDataInput
  upsert: ThemeUpsertNestedInput
  connect: ThemeWhereUniqueInput
}

input ThemeUpsertNestedInput {
  update: ThemeUpdateDataInput!
  create: ThemeCreateInput!
}

input ThemeWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  component: String
  component_not: String
  component_in: [String!]
  component_not_in: [String!]
  component_lt: String
  component_lte: String
  component_gt: String
  component_gte: String
  component_contains: String
  component_not_contains: String
  component_starts_with: String
  component_not_starts_with: String
  component_ends_with: String
  component_not_ends_with: String
  type: ThemeType
  type_not: ThemeType
  type_in: [ThemeType!]
  type_not_in: [ThemeType!]
  target: ThemeTarget
  target_not: ThemeTarget
  target_in: [ThemeTarget!]
  target_not_in: [ThemeTarget!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  preview_every: ImageWhereInput
  preview_some: ImageWhereInput
  preview_none: ImageWhereInput
  creator: UserWhereInput
  AND: [ThemeWhereInput!]
  OR: [ThemeWhereInput!]
  NOT: [ThemeWhereInput!]
}

input ThemeWhereUniqueInput {
  id: UUID
}

type User {
  id: UUID!
  userName: String!
  email: String!
  displayName: String
  firstName: String
  lastName: String
  description: String
  createdAt: DateTime!
  updatedAt: DateTime!
  avatar: Image
  group: Group!
  logs(where: LogWhereInput, orderBy: LogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Log!]
  meta: Json
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: UUID
  userName: String!
  email: String!
  displayName: String
  firstName: String
  lastName: String
  description: String
  avatar: ImageCreateOneInput
  group: GroupCreateOneInput!
  logs: LogCreateManyWithoutUserInput
  meta: Json
}

input UserCreateOneInput {
  connect: UserWhereUniqueInput
}

input UserCreateWithoutLogsInput {
  id: UUID
  userName: String!
  email: String!
  displayName: String
  firstName: String
  lastName: String
  description: String
  avatar: ImageCreateOneInput
  group: GroupCreateOneInput!
  meta: Json
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  userName_ASC
  userName_DESC
  email_ASC
  email_DESC
  displayName_ASC
  displayName_DESC
  firstName_ASC
  firstName_DESC
  lastName_ASC
  lastName_DESC
  description_ASC
  description_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  meta_ASC
  meta_DESC
}

type UserPreviousValues {
  id: UUID!
  userName: String!
  email: String!
  displayName: String
  firstName: String
  lastName: String
  description: String
  createdAt: DateTime!
  updatedAt: DateTime!
  meta: Json
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  userName: String
  email: String
  displayName: String
  firstName: String
  lastName: String
  description: String
  avatar: ImageUpdateOneInput
  group: GroupUpdateOneRequiredInput
  logs: LogUpdateManyWithoutUserInput
  meta: Json
}

input UserUpdateInput {
  userName: String
  email: String
  displayName: String
  firstName: String
  lastName: String
  description: String
  avatar: ImageUpdateOneInput
  group: GroupUpdateOneRequiredInput
  logs: LogUpdateManyWithoutUserInput
  meta: Json
}

input UserUpdateOneInput {
  connect: UserWhereUniqueInput
}

input UserUpdateManyMutationInput {
  userName: String
  email: String
  displayName: String
  firstName: String
  lastName: String
  description: String
  meta: Json
}

input UserUpdateOneRequiredInput {
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutLogsDataInput {
  userName: String
  email: String
  displayName: String
  firstName: String
  lastName: String
  description: String
  avatar: ImageUpdateOneInput
  group: GroupUpdateOneRequiredInput
  meta: Json
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutLogsInput {
  update: UserUpdateWithoutLogsDataInput!
  create: UserCreateWithoutLogsInput!
}

input UserWhereInput {
  id: UUID
  id_not: UUID
  id_in: [UUID!]
  id_not_in: [UUID!]
  id_lt: UUID
  id_lte: UUID
  id_gt: UUID
  id_gte: UUID
  id_contains: UUID
  id_not_contains: UUID
  id_starts_with: UUID
  id_not_starts_with: UUID
  id_ends_with: UUID
  id_not_ends_with: UUID
  userName: String
  userName_not: String
  userName_in: [String!]
  userName_not_in: [String!]
  userName_lt: String
  userName_lte: String
  userName_gt: String
  userName_gte: String
  userName_contains: String
  userName_not_contains: String
  userName_starts_with: String
  userName_not_starts_with: String
  userName_ends_with: String
  userName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  displayName: String
  displayName_not: String
  displayName_in: [String!]
  displayName_not_in: [String!]
  displayName_lt: String
  displayName_lte: String
  displayName_gt: String
  displayName_gte: String
  displayName_contains: String
  displayName_not_contains: String
  displayName_starts_with: String
  displayName_not_starts_with: String
  displayName_ends_with: String
  displayName_not_ends_with: String
  firstName: String
  firstName_not: String
  firstName_in: [String!]
  firstName_not_in: [String!]
  firstName_lt: String
  firstName_lte: String
  firstName_gt: String
  firstName_gte: String
  firstName_contains: String
  firstName_not_contains: String
  firstName_starts_with: String
  firstName_not_starts_with: String
  firstName_ends_with: String
  firstName_not_ends_with: String
  lastName: String
  lastName_not: String
  lastName_in: [String!]
  lastName_not_in: [String!]
  lastName_lt: String
  lastName_lte: String
  lastName_gt: String
  lastName_gte: String
  lastName_contains: String
  lastName_not_contains: String
  lastName_starts_with: String
  lastName_not_starts_with: String
  lastName_ends_with: String
  lastName_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  avatar: ImageWhereInput
  group: GroupWhereInput
  logs_every: LogWhereInput
  logs_some: LogWhereInput
  logs_none: LogWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: UUID
  userName: String
  email: String
}

scalar UUID
