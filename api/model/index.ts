// Code generated by Prisma (prisma@1.34.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  access: (where?: AccessWhereInput) => Promise<boolean>;
  event: (where?: EventWhereInput) => Promise<boolean>;
  file: (where?: FileWhereInput) => Promise<boolean>;
  group: (where?: GroupWhereInput) => Promise<boolean>;
  image: (where?: ImageWhereInput) => Promise<boolean>;
  item: (where?: ItemWhereInput) => Promise<boolean>;
  lang: (where?: LangWhereInput) => Promise<boolean>;
  log: (where?: LogWhereInput) => Promise<boolean>;
  markup: (where?: MarkupWhereInput) => Promise<boolean>;
  measurement: (where?: MeasurementWhereInput) => Promise<boolean>;
  news: (where?: NewsWhereInput) => Promise<boolean>;
  note: (where?: NoteWhereInput) => Promise<boolean>;
  paragraph: (where?: ParagraphWhereInput) => Promise<boolean>;
  permission: (where?: PermissionWhereInput) => Promise<boolean>;
  permissionType: (where?: PermissionTypeWhereInput) => Promise<boolean>;
  post: (where?: PostWhereInput) => Promise<boolean>;
  property: (where?: PropertyWhereInput) => Promise<boolean>;
  quote: (where?: QuoteWhereInput) => Promise<boolean>;
  reply: (where?: ReplyWhereInput) => Promise<boolean>;
  statement: (where?: StatementWhereInput) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
  theme: (where?: ThemeWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  i18n: (where?: i18nWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  access: (where: AccessWhereUniqueInput) => AccessNullablePromise;
  accesses: (args?: {
    where?: AccessWhereInput;
    orderBy?: AccessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Access>;
  accessesConnection: (args?: {
    where?: AccessWhereInput;
    orderBy?: AccessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AccessConnectionPromise;
  event: (where: EventWhereUniqueInput) => EventNullablePromise;
  events: (args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Event>;
  eventsConnection: (args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EventConnectionPromise;
  file: (where: FileWhereUniqueInput) => FileNullablePromise;
  files: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<File>;
  filesConnection: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FileConnectionPromise;
  group: (where: GroupWhereUniqueInput) => GroupNullablePromise;
  groups: (args?: {
    where?: GroupWhereInput;
    orderBy?: GroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Group>;
  groupsConnection: (args?: {
    where?: GroupWhereInput;
    orderBy?: GroupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GroupConnectionPromise;
  image: (where: ImageWhereUniqueInput) => ImageNullablePromise;
  images: (args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Image>;
  imagesConnection: (args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ImageConnectionPromise;
  item: (where: ItemWhereUniqueInput) => ItemNullablePromise;
  items: (args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Item>;
  itemsConnection: (args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ItemConnectionPromise;
  lang: (where: LangWhereUniqueInput) => LangNullablePromise;
  langs: (args?: {
    where?: LangWhereInput;
    orderBy?: LangOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Lang>;
  langsConnection: (args?: {
    where?: LangWhereInput;
    orderBy?: LangOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LangConnectionPromise;
  log: (where: LogWhereUniqueInput) => LogNullablePromise;
  logs: (args?: {
    where?: LogWhereInput;
    orderBy?: LogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Log>;
  logsConnection: (args?: {
    where?: LogWhereInput;
    orderBy?: LogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LogConnectionPromise;
  markup: (where: MarkupWhereUniqueInput) => MarkupNullablePromise;
  markups: (args?: {
    where?: MarkupWhereInput;
    orderBy?: MarkupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Markup>;
  markupsConnection: (args?: {
    where?: MarkupWhereInput;
    orderBy?: MarkupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MarkupConnectionPromise;
  measurement: (
    where: MeasurementWhereUniqueInput
  ) => MeasurementNullablePromise;
  measurements: (args?: {
    where?: MeasurementWhereInput;
    orderBy?: MeasurementOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Measurement>;
  measurementsConnection: (args?: {
    where?: MeasurementWhereInput;
    orderBy?: MeasurementOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MeasurementConnectionPromise;
  news: (where: NewsWhereUniqueInput) => NewsNullablePromise;
  newses: (args?: {
    where?: NewsWhereInput;
    orderBy?: NewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<News>;
  newsesConnection: (args?: {
    where?: NewsWhereInput;
    orderBy?: NewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NewsConnectionPromise;
  note: (where: NoteWhereUniqueInput) => NoteNullablePromise;
  notes: (args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Note>;
  notesConnection: (args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NoteConnectionPromise;
  paragraph: (where: ParagraphWhereUniqueInput) => ParagraphNullablePromise;
  paragraphs: (args?: {
    where?: ParagraphWhereInput;
    orderBy?: ParagraphOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Paragraph>;
  paragraphsConnection: (args?: {
    where?: ParagraphWhereInput;
    orderBy?: ParagraphOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ParagraphConnectionPromise;
  permission: (where: PermissionWhereUniqueInput) => PermissionNullablePromise;
  permissions: (args?: {
    where?: PermissionWhereInput;
    orderBy?: PermissionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Permission>;
  permissionsConnection: (args?: {
    where?: PermissionWhereInput;
    orderBy?: PermissionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PermissionConnectionPromise;
  permissionType: (
    where: PermissionTypeWhereUniqueInput
  ) => PermissionTypeNullablePromise;
  permissionTypes: (args?: {
    where?: PermissionTypeWhereInput;
    orderBy?: PermissionTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PermissionType>;
  permissionTypesConnection: (args?: {
    where?: PermissionTypeWhereInput;
    orderBy?: PermissionTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PermissionTypeConnectionPromise;
  post: (where: PostWhereUniqueInput) => PostNullablePromise;
  posts: (args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Post>;
  postsConnection: (args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PostConnectionPromise;
  property: (where: PropertyWhereUniqueInput) => PropertyNullablePromise;
  properties: (args?: {
    where?: PropertyWhereInput;
    orderBy?: PropertyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Property>;
  propertiesConnection: (args?: {
    where?: PropertyWhereInput;
    orderBy?: PropertyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PropertyConnectionPromise;
  quote: (where: QuoteWhereUniqueInput) => QuoteNullablePromise;
  quotes: (args?: {
    where?: QuoteWhereInput;
    orderBy?: QuoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Quote>;
  quotesConnection: (args?: {
    where?: QuoteWhereInput;
    orderBy?: QuoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QuoteConnectionPromise;
  reply: (where: ReplyWhereUniqueInput) => ReplyNullablePromise;
  replies: (args?: {
    where?: ReplyWhereInput;
    orderBy?: ReplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Reply>;
  repliesConnection: (args?: {
    where?: ReplyWhereInput;
    orderBy?: ReplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ReplyConnectionPromise;
  statement: (where: StatementWhereUniqueInput) => StatementNullablePromise;
  statements: (args?: {
    where?: StatementWhereInput;
    orderBy?: StatementOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Statement>;
  statementsConnection: (args?: {
    where?: StatementWhereInput;
    orderBy?: StatementOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StatementConnectionPromise;
  tag: (where: TagWhereUniqueInput) => TagNullablePromise;
  tags: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Tag>;
  tagsConnection: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TagConnectionPromise;
  theme: (where: ThemeWhereUniqueInput) => ThemeNullablePromise;
  themes: (args?: {
    where?: ThemeWhereInput;
    orderBy?: ThemeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Theme>;
  themesConnection: (args?: {
    where?: ThemeWhereInput;
    orderBy?: ThemeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ThemeConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  i18n: (where: i18nWhereUniqueInput) => i18nNullablePromise;
  i18ns: (args?: {
    where?: i18nWhereInput;
    orderBy?: i18nOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<i18n>;
  i18nsConnection: (args?: {
    where?: i18nWhereInput;
    orderBy?: i18nOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => i18nConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAccess: (data: AccessCreateInput) => AccessPromise;
  updateAccess: (args: {
    data: AccessUpdateInput;
    where: AccessWhereUniqueInput;
  }) => AccessPromise;
  updateManyAccesses: (args: {
    data: AccessUpdateManyMutationInput;
    where?: AccessWhereInput;
  }) => BatchPayloadPromise;
  upsertAccess: (args: {
    where: AccessWhereUniqueInput;
    create: AccessCreateInput;
    update: AccessUpdateInput;
  }) => AccessPromise;
  deleteAccess: (where: AccessWhereUniqueInput) => AccessPromise;
  deleteManyAccesses: (where?: AccessWhereInput) => BatchPayloadPromise;
  createEvent: (data: EventCreateInput) => EventPromise;
  updateEvent: (args: {
    data: EventUpdateInput;
    where: EventWhereUniqueInput;
  }) => EventPromise;
  updateManyEvents: (args: {
    data: EventUpdateManyMutationInput;
    where?: EventWhereInput;
  }) => BatchPayloadPromise;
  upsertEvent: (args: {
    where: EventWhereUniqueInput;
    create: EventCreateInput;
    update: EventUpdateInput;
  }) => EventPromise;
  deleteEvent: (where: EventWhereUniqueInput) => EventPromise;
  deleteManyEvents: (where?: EventWhereInput) => BatchPayloadPromise;
  createFile: (data: FileCreateInput) => FilePromise;
  updateFile: (args: {
    data: FileUpdateInput;
    where: FileWhereUniqueInput;
  }) => FilePromise;
  updateManyFiles: (args: {
    data: FileUpdateManyMutationInput;
    where?: FileWhereInput;
  }) => BatchPayloadPromise;
  upsertFile: (args: {
    where: FileWhereUniqueInput;
    create: FileCreateInput;
    update: FileUpdateInput;
  }) => FilePromise;
  deleteFile: (where: FileWhereUniqueInput) => FilePromise;
  deleteManyFiles: (where?: FileWhereInput) => BatchPayloadPromise;
  createGroup: (data: GroupCreateInput) => GroupPromise;
  updateGroup: (args: {
    data: GroupUpdateInput;
    where: GroupWhereUniqueInput;
  }) => GroupPromise;
  updateManyGroups: (args: {
    data: GroupUpdateManyMutationInput;
    where?: GroupWhereInput;
  }) => BatchPayloadPromise;
  upsertGroup: (args: {
    where: GroupWhereUniqueInput;
    create: GroupCreateInput;
    update: GroupUpdateInput;
  }) => GroupPromise;
  deleteGroup: (where: GroupWhereUniqueInput) => GroupPromise;
  deleteManyGroups: (where?: GroupWhereInput) => BatchPayloadPromise;
  createImage: (data: ImageCreateInput) => ImagePromise;
  updateImage: (args: {
    data: ImageUpdateInput;
    where: ImageWhereUniqueInput;
  }) => ImagePromise;
  updateManyImages: (args: {
    data: ImageUpdateManyMutationInput;
    where?: ImageWhereInput;
  }) => BatchPayloadPromise;
  upsertImage: (args: {
    where: ImageWhereUniqueInput;
    create: ImageCreateInput;
    update: ImageUpdateInput;
  }) => ImagePromise;
  deleteImage: (where: ImageWhereUniqueInput) => ImagePromise;
  deleteManyImages: (where?: ImageWhereInput) => BatchPayloadPromise;
  createItem: (data: ItemCreateInput) => ItemPromise;
  updateItem: (args: {
    data: ItemUpdateInput;
    where: ItemWhereUniqueInput;
  }) => ItemPromise;
  updateManyItems: (args: {
    data: ItemUpdateManyMutationInput;
    where?: ItemWhereInput;
  }) => BatchPayloadPromise;
  upsertItem: (args: {
    where: ItemWhereUniqueInput;
    create: ItemCreateInput;
    update: ItemUpdateInput;
  }) => ItemPromise;
  deleteItem: (where: ItemWhereUniqueInput) => ItemPromise;
  deleteManyItems: (where?: ItemWhereInput) => BatchPayloadPromise;
  createLang: (data: LangCreateInput) => LangPromise;
  updateLang: (args: {
    data: LangUpdateInput;
    where: LangWhereUniqueInput;
  }) => LangPromise;
  updateManyLangs: (args: {
    data: LangUpdateManyMutationInput;
    where?: LangWhereInput;
  }) => BatchPayloadPromise;
  upsertLang: (args: {
    where: LangWhereUniqueInput;
    create: LangCreateInput;
    update: LangUpdateInput;
  }) => LangPromise;
  deleteLang: (where: LangWhereUniqueInput) => LangPromise;
  deleteManyLangs: (where?: LangWhereInput) => BatchPayloadPromise;
  createLog: (data: LogCreateInput) => LogPromise;
  updateLog: (args: {
    data: LogUpdateInput;
    where: LogWhereUniqueInput;
  }) => LogPromise;
  updateManyLogs: (args: {
    data: LogUpdateManyMutationInput;
    where?: LogWhereInput;
  }) => BatchPayloadPromise;
  upsertLog: (args: {
    where: LogWhereUniqueInput;
    create: LogCreateInput;
    update: LogUpdateInput;
  }) => LogPromise;
  deleteLog: (where: LogWhereUniqueInput) => LogPromise;
  deleteManyLogs: (where?: LogWhereInput) => BatchPayloadPromise;
  createMarkup: (data: MarkupCreateInput) => MarkupPromise;
  updateMarkup: (args: {
    data: MarkupUpdateInput;
    where: MarkupWhereUniqueInput;
  }) => MarkupPromise;
  updateManyMarkups: (args: {
    data: MarkupUpdateManyMutationInput;
    where?: MarkupWhereInput;
  }) => BatchPayloadPromise;
  upsertMarkup: (args: {
    where: MarkupWhereUniqueInput;
    create: MarkupCreateInput;
    update: MarkupUpdateInput;
  }) => MarkupPromise;
  deleteMarkup: (where: MarkupWhereUniqueInput) => MarkupPromise;
  deleteManyMarkups: (where?: MarkupWhereInput) => BatchPayloadPromise;
  createMeasurement: (data: MeasurementCreateInput) => MeasurementPromise;
  updateMeasurement: (args: {
    data: MeasurementUpdateInput;
    where: MeasurementWhereUniqueInput;
  }) => MeasurementPromise;
  updateManyMeasurements: (args: {
    data: MeasurementUpdateManyMutationInput;
    where?: MeasurementWhereInput;
  }) => BatchPayloadPromise;
  upsertMeasurement: (args: {
    where: MeasurementWhereUniqueInput;
    create: MeasurementCreateInput;
    update: MeasurementUpdateInput;
  }) => MeasurementPromise;
  deleteMeasurement: (where: MeasurementWhereUniqueInput) => MeasurementPromise;
  deleteManyMeasurements: (
    where?: MeasurementWhereInput
  ) => BatchPayloadPromise;
  createNews: (data: NewsCreateInput) => NewsPromise;
  updateNews: (args: {
    data: NewsUpdateInput;
    where: NewsWhereUniqueInput;
  }) => NewsPromise;
  updateManyNewses: (args: {
    data: NewsUpdateManyMutationInput;
    where?: NewsWhereInput;
  }) => BatchPayloadPromise;
  upsertNews: (args: {
    where: NewsWhereUniqueInput;
    create: NewsCreateInput;
    update: NewsUpdateInput;
  }) => NewsPromise;
  deleteNews: (where: NewsWhereUniqueInput) => NewsPromise;
  deleteManyNewses: (where?: NewsWhereInput) => BatchPayloadPromise;
  createNote: (data: NoteCreateInput) => NotePromise;
  updateNote: (args: {
    data: NoteUpdateInput;
    where: NoteWhereUniqueInput;
  }) => NotePromise;
  updateManyNotes: (args: {
    data: NoteUpdateManyMutationInput;
    where?: NoteWhereInput;
  }) => BatchPayloadPromise;
  upsertNote: (args: {
    where: NoteWhereUniqueInput;
    create: NoteCreateInput;
    update: NoteUpdateInput;
  }) => NotePromise;
  deleteNote: (where: NoteWhereUniqueInput) => NotePromise;
  deleteManyNotes: (where?: NoteWhereInput) => BatchPayloadPromise;
  createParagraph: (data: ParagraphCreateInput) => ParagraphPromise;
  updateParagraph: (args: {
    data: ParagraphUpdateInput;
    where: ParagraphWhereUniqueInput;
  }) => ParagraphPromise;
  updateManyParagraphs: (args: {
    data: ParagraphUpdateManyMutationInput;
    where?: ParagraphWhereInput;
  }) => BatchPayloadPromise;
  upsertParagraph: (args: {
    where: ParagraphWhereUniqueInput;
    create: ParagraphCreateInput;
    update: ParagraphUpdateInput;
  }) => ParagraphPromise;
  deleteParagraph: (where: ParagraphWhereUniqueInput) => ParagraphPromise;
  deleteManyParagraphs: (where?: ParagraphWhereInput) => BatchPayloadPromise;
  createPermission: (data: PermissionCreateInput) => PermissionPromise;
  updatePermission: (args: {
    data: PermissionUpdateInput;
    where: PermissionWhereUniqueInput;
  }) => PermissionPromise;
  updateManyPermissions: (args: {
    data: PermissionUpdateManyMutationInput;
    where?: PermissionWhereInput;
  }) => BatchPayloadPromise;
  upsertPermission: (args: {
    where: PermissionWhereUniqueInput;
    create: PermissionCreateInput;
    update: PermissionUpdateInput;
  }) => PermissionPromise;
  deletePermission: (where: PermissionWhereUniqueInput) => PermissionPromise;
  deleteManyPermissions: (where?: PermissionWhereInput) => BatchPayloadPromise;
  createPermissionType: (
    data: PermissionTypeCreateInput
  ) => PermissionTypePromise;
  updatePermissionType: (args: {
    data: PermissionTypeUpdateInput;
    where: PermissionTypeWhereUniqueInput;
  }) => PermissionTypePromise;
  upsertPermissionType: (args: {
    where: PermissionTypeWhereUniqueInput;
    create: PermissionTypeCreateInput;
    update: PermissionTypeUpdateInput;
  }) => PermissionTypePromise;
  deletePermissionType: (
    where: PermissionTypeWhereUniqueInput
  ) => PermissionTypePromise;
  deleteManyPermissionTypes: (
    where?: PermissionTypeWhereInput
  ) => BatchPayloadPromise;
  createPost: (data: PostCreateInput) => PostPromise;
  updatePost: (args: {
    data: PostUpdateInput;
    where: PostWhereUniqueInput;
  }) => PostPromise;
  updateManyPosts: (args: {
    data: PostUpdateManyMutationInput;
    where?: PostWhereInput;
  }) => BatchPayloadPromise;
  upsertPost: (args: {
    where: PostWhereUniqueInput;
    create: PostCreateInput;
    update: PostUpdateInput;
  }) => PostPromise;
  deletePost: (where: PostWhereUniqueInput) => PostPromise;
  deleteManyPosts: (where?: PostWhereInput) => BatchPayloadPromise;
  createProperty: (data: PropertyCreateInput) => PropertyPromise;
  updateProperty: (args: {
    data: PropertyUpdateInput;
    where: PropertyWhereUniqueInput;
  }) => PropertyPromise;
  updateManyProperties: (args: {
    data: PropertyUpdateManyMutationInput;
    where?: PropertyWhereInput;
  }) => BatchPayloadPromise;
  upsertProperty: (args: {
    where: PropertyWhereUniqueInput;
    create: PropertyCreateInput;
    update: PropertyUpdateInput;
  }) => PropertyPromise;
  deleteProperty: (where: PropertyWhereUniqueInput) => PropertyPromise;
  deleteManyProperties: (where?: PropertyWhereInput) => BatchPayloadPromise;
  createQuote: (data: QuoteCreateInput) => QuotePromise;
  updateQuote: (args: {
    data: QuoteUpdateInput;
    where: QuoteWhereUniqueInput;
  }) => QuotePromise;
  updateManyQuotes: (args: {
    data: QuoteUpdateManyMutationInput;
    where?: QuoteWhereInput;
  }) => BatchPayloadPromise;
  upsertQuote: (args: {
    where: QuoteWhereUniqueInput;
    create: QuoteCreateInput;
    update: QuoteUpdateInput;
  }) => QuotePromise;
  deleteQuote: (where: QuoteWhereUniqueInput) => QuotePromise;
  deleteManyQuotes: (where?: QuoteWhereInput) => BatchPayloadPromise;
  createReply: (data: ReplyCreateInput) => ReplyPromise;
  updateReply: (args: {
    data: ReplyUpdateInput;
    where: ReplyWhereUniqueInput;
  }) => ReplyPromise;
  updateManyReplies: (args: {
    data: ReplyUpdateManyMutationInput;
    where?: ReplyWhereInput;
  }) => BatchPayloadPromise;
  upsertReply: (args: {
    where: ReplyWhereUniqueInput;
    create: ReplyCreateInput;
    update: ReplyUpdateInput;
  }) => ReplyPromise;
  deleteReply: (where: ReplyWhereUniqueInput) => ReplyPromise;
  deleteManyReplies: (where?: ReplyWhereInput) => BatchPayloadPromise;
  createStatement: (data: StatementCreateInput) => StatementPromise;
  updateStatement: (args: {
    data: StatementUpdateInput;
    where: StatementWhereUniqueInput;
  }) => StatementPromise;
  updateManyStatements: (args: {
    data: StatementUpdateManyMutationInput;
    where?: StatementWhereInput;
  }) => BatchPayloadPromise;
  upsertStatement: (args: {
    where: StatementWhereUniqueInput;
    create: StatementCreateInput;
    update: StatementUpdateInput;
  }) => StatementPromise;
  deleteStatement: (where: StatementWhereUniqueInput) => StatementPromise;
  deleteManyStatements: (where?: StatementWhereInput) => BatchPayloadPromise;
  createTag: (data: TagCreateInput) => TagPromise;
  updateTag: (args: {
    data: TagUpdateInput;
    where: TagWhereUniqueInput;
  }) => TagPromise;
  updateManyTags: (args: {
    data: TagUpdateManyMutationInput;
    where?: TagWhereInput;
  }) => BatchPayloadPromise;
  upsertTag: (args: {
    where: TagWhereUniqueInput;
    create: TagCreateInput;
    update: TagUpdateInput;
  }) => TagPromise;
  deleteTag: (where: TagWhereUniqueInput) => TagPromise;
  deleteManyTags: (where?: TagWhereInput) => BatchPayloadPromise;
  createTheme: (data: ThemeCreateInput) => ThemePromise;
  updateTheme: (args: {
    data: ThemeUpdateInput;
    where: ThemeWhereUniqueInput;
  }) => ThemePromise;
  updateManyThemes: (args: {
    data: ThemeUpdateManyMutationInput;
    where?: ThemeWhereInput;
  }) => BatchPayloadPromise;
  upsertTheme: (args: {
    where: ThemeWhereUniqueInput;
    create: ThemeCreateInput;
    update: ThemeUpdateInput;
  }) => ThemePromise;
  deleteTheme: (where: ThemeWhereUniqueInput) => ThemePromise;
  deleteManyThemes: (where?: ThemeWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createi18n: (data: i18nCreateInput) => i18nPromise;
  updatei18n: (args: {
    data: i18nUpdateInput;
    where: i18nWhereUniqueInput;
  }) => i18nPromise;
  updateManyi18ns: (args: {
    data: i18nUpdateManyMutationInput;
    where?: i18nWhereInput;
  }) => BatchPayloadPromise;
  upserti18n: (args: {
    where: i18nWhereUniqueInput;
    create: i18nCreateInput;
    update: i18nUpdateInput;
  }) => i18nPromise;
  deletei18n: (where: i18nWhereUniqueInput) => i18nPromise;
  deleteManyi18ns: (where?: i18nWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  access: (
    where?: AccessSubscriptionWhereInput
  ) => AccessSubscriptionPayloadSubscription;
  event: (
    where?: EventSubscriptionWhereInput
  ) => EventSubscriptionPayloadSubscription;
  file: (
    where?: FileSubscriptionWhereInput
  ) => FileSubscriptionPayloadSubscription;
  group: (
    where?: GroupSubscriptionWhereInput
  ) => GroupSubscriptionPayloadSubscription;
  image: (
    where?: ImageSubscriptionWhereInput
  ) => ImageSubscriptionPayloadSubscription;
  item: (
    where?: ItemSubscriptionWhereInput
  ) => ItemSubscriptionPayloadSubscription;
  lang: (
    where?: LangSubscriptionWhereInput
  ) => LangSubscriptionPayloadSubscription;
  log: (
    where?: LogSubscriptionWhereInput
  ) => LogSubscriptionPayloadSubscription;
  markup: (
    where?: MarkupSubscriptionWhereInput
  ) => MarkupSubscriptionPayloadSubscription;
  measurement: (
    where?: MeasurementSubscriptionWhereInput
  ) => MeasurementSubscriptionPayloadSubscription;
  news: (
    where?: NewsSubscriptionWhereInput
  ) => NewsSubscriptionPayloadSubscription;
  note: (
    where?: NoteSubscriptionWhereInput
  ) => NoteSubscriptionPayloadSubscription;
  paragraph: (
    where?: ParagraphSubscriptionWhereInput
  ) => ParagraphSubscriptionPayloadSubscription;
  permission: (
    where?: PermissionSubscriptionWhereInput
  ) => PermissionSubscriptionPayloadSubscription;
  permissionType: (
    where?: PermissionTypeSubscriptionWhereInput
  ) => PermissionTypeSubscriptionPayloadSubscription;
  post: (
    where?: PostSubscriptionWhereInput
  ) => PostSubscriptionPayloadSubscription;
  property: (
    where?: PropertySubscriptionWhereInput
  ) => PropertySubscriptionPayloadSubscription;
  quote: (
    where?: QuoteSubscriptionWhereInput
  ) => QuoteSubscriptionPayloadSubscription;
  reply: (
    where?: ReplySubscriptionWhereInput
  ) => ReplySubscriptionPayloadSubscription;
  statement: (
    where?: StatementSubscriptionWhereInput
  ) => StatementSubscriptionPayloadSubscription;
  tag: (
    where?: TagSubscriptionWhereInput
  ) => TagSubscriptionPayloadSubscription;
  theme: (
    where?: ThemeSubscriptionWhereInput
  ) => ThemeSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  i18n: (
    where?: i18nSubscriptionWhereInput
  ) => i18nSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AccessOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "read_ASC"
  | "read_DESC"
  | "write_ASC"
  | "write_DESC"
  | "delete_ASC"
  | "delete_DESC";

export type EventType = "ERROR" | "WARNING" | "INFO" | "LOG";

export type EventOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "result_ASC"
  | "result_DESC"
  | "timemark_ASC"
  | "timemark_DESC"
  | "meta_ASC"
  | "meta_DESC";

export type FileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "path_ASC"
  | "path_DESC"
  | "size_ASC"
  | "size_DESC"
  | "hidden_ASC"
  | "hidden_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "meta_ASC"
  | "meta_DESC";

export type GroupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "meta_ASC"
  | "meta_DESC";

export type ImageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "meta_ASC"
  | "meta_DESC";

export type i18nOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "meta_ASC"
  | "meta_DESC";

export type ParagraphType =
  | "HEADLINE"
  | "TITLE"
  | "SUBTITLE"
  | "QUOTE"
  | "PART"
  | "PARAGRAPH"
  | "IMAGE";

export type MarkupType =
  | "EMBED"
  | "ITEM"
  | "IMAGE"
  | "LINK"
  | "ITALIC"
  | "STRONG";

export type QuoteType = "HIGHLIGHT" | "NOTE" | "REPLY";

export type StatementOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "value_ASC"
  | "value_DESC"
  | "meta_ASC"
  | "meta_DESC";

export type ParagraphOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "index_ASC"
  | "index_DESC"
  | "text_ASC"
  | "text_DESC"
  | "type_ASC"
  | "type_DESC"
  | "meta_ASC"
  | "meta_DESC";

export type MarkupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "start_ASC"
  | "start_DESC"
  | "end_ASC"
  | "end_DESC"
  | "href_ASC"
  | "href_DESC"
  | "rel_ASC"
  | "rel_DESC"
  | "src_ASC"
  | "src_DESC"
  | "title_ASC"
  | "title_DESC"
  | "meta_ASC"
  | "meta_DESC";

export type QuoteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "start_ASC"
  | "start_DESC"
  | "end_ASC"
  | "end_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "meta_ASC"
  | "meta_DESC";

export type NoteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "content_ASC"
  | "content_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "meta_ASC"
  | "meta_DESC";

export type ReplyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "replyId_ASC"
  | "replyId_DESC"
  | "content_ASC"
  | "content_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "meta_ASC"
  | "meta_DESC";

export type LogOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "ip_ASC"
  | "ip_DESC"
  | "meta_ASC"
  | "meta_DESC";

export type ItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "itemId_ASC"
  | "itemId_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "meta_ASC"
  | "meta_DESC";

export type LangOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "langName_ASC"
  | "langName_DESC"
  | "meta_ASC"
  | "meta_DESC";

export type MeasurementOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "height_ASC"
  | "height_DESC"
  | "width_ASC"
  | "width_DESC";

export type NewsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "published_ASC"
  | "published_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "validUntil_ASC"
  | "validUntil_DESC"
  | "meta_ASC"
  | "meta_DESC";

export type PermissionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "loginAdmin_ASC"
  | "loginAdmin_DESC"
  | "meta_ASC"
  | "meta_DESC";

export type PermissionTypeOrderByInput = "id_ASC" | "id_DESC";

export type TagOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "meta_ASC"
  | "meta_DESC";

export type PostOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "published_ASC"
  | "published_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "validUntil_ASC"
  | "validUntil_DESC"
  | "meta_ASC"
  | "meta_DESC";

export type PropertyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "propertyId_ASC"
  | "propertyId_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "description_ASC"
  | "description_DESC"
  | "meta_ASC"
  | "meta_DESC";

export type ThemeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "component_ASC"
  | "component_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "meta_ASC"
  | "meta_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "userName_ASC"
  | "userName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "meta_ASC"
  | "meta_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AccessWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export interface AccessWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  read?: Maybe<Boolean>;
  read_not?: Maybe<Boolean>;
  write?: Maybe<Boolean>;
  write_not?: Maybe<Boolean>;
  delete?: Maybe<Boolean>;
  delete_not?: Maybe<Boolean>;
  AND?: Maybe<AccessWhereInput[] | AccessWhereInput>;
  OR?: Maybe<AccessWhereInput[] | AccessWhereInput>;
  NOT?: Maybe<AccessWhereInput[] | AccessWhereInput>;
}

export type EventWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export interface EventWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  type?: Maybe<EventType>;
  type_not?: Maybe<EventType>;
  type_in?: Maybe<EventType[] | EventType>;
  type_not_in?: Maybe<EventType[] | EventType>;
  result?: Maybe<String>;
  result_not?: Maybe<String>;
  result_in?: Maybe<String[] | String>;
  result_not_in?: Maybe<String[] | String>;
  result_lt?: Maybe<String>;
  result_lte?: Maybe<String>;
  result_gt?: Maybe<String>;
  result_gte?: Maybe<String>;
  result_contains?: Maybe<String>;
  result_not_contains?: Maybe<String>;
  result_starts_with?: Maybe<String>;
  result_not_starts_with?: Maybe<String>;
  result_ends_with?: Maybe<String>;
  result_not_ends_with?: Maybe<String>;
  timemark?: Maybe<DateTimeInput>;
  timemark_not?: Maybe<DateTimeInput>;
  timemark_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  timemark_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  timemark_lt?: Maybe<DateTimeInput>;
  timemark_lte?: Maybe<DateTimeInput>;
  timemark_gt?: Maybe<DateTimeInput>;
  timemark_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<EventWhereInput[] | EventWhereInput>;
  OR?: Maybe<EventWhereInput[] | EventWhereInput>;
  NOT?: Maybe<EventWhereInput[] | EventWhereInput>;
}

export type FileWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export interface FileWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  path?: Maybe<String>;
  path_not?: Maybe<String>;
  path_in?: Maybe<String[] | String>;
  path_not_in?: Maybe<String[] | String>;
  path_lt?: Maybe<String>;
  path_lte?: Maybe<String>;
  path_gt?: Maybe<String>;
  path_gte?: Maybe<String>;
  path_contains?: Maybe<String>;
  path_not_contains?: Maybe<String>;
  path_starts_with?: Maybe<String>;
  path_not_starts_with?: Maybe<String>;
  path_ends_with?: Maybe<String>;
  path_not_ends_with?: Maybe<String>;
  size?: Maybe<Float>;
  size_not?: Maybe<Float>;
  size_in?: Maybe<Float[] | Float>;
  size_not_in?: Maybe<Float[] | Float>;
  size_lt?: Maybe<Float>;
  size_lte?: Maybe<Float>;
  size_gt?: Maybe<Float>;
  size_gte?: Maybe<Float>;
  hidden?: Maybe<Boolean>;
  hidden_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  uploadBy?: Maybe<UserWhereInput>;
  AND?: Maybe<FileWhereInput[] | FileWhereInput>;
  OR?: Maybe<FileWhereInput[] | FileWhereInput>;
  NOT?: Maybe<FileWhereInput[] | FileWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  userName?: Maybe<String>;
  userName_not?: Maybe<String>;
  userName_in?: Maybe<String[] | String>;
  userName_not_in?: Maybe<String[] | String>;
  userName_lt?: Maybe<String>;
  userName_lte?: Maybe<String>;
  userName_gt?: Maybe<String>;
  userName_gte?: Maybe<String>;
  userName_contains?: Maybe<String>;
  userName_not_contains?: Maybe<String>;
  userName_starts_with?: Maybe<String>;
  userName_not_starts_with?: Maybe<String>;
  userName_ends_with?: Maybe<String>;
  userName_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  avatar?: Maybe<ImageWhereInput>;
  group?: Maybe<GroupWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface ImageWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  format?: Maybe<MeasurementWhereInput>;
  file?: Maybe<FileWhereInput>;
  AND?: Maybe<ImageWhereInput[] | ImageWhereInput>;
  OR?: Maybe<ImageWhereInput[] | ImageWhereInput>;
  NOT?: Maybe<ImageWhereInput[] | ImageWhereInput>;
}

export interface MeasurementWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  height?: Maybe<Float>;
  height_not?: Maybe<Float>;
  height_in?: Maybe<Float[] | Float>;
  height_not_in?: Maybe<Float[] | Float>;
  height_lt?: Maybe<Float>;
  height_lte?: Maybe<Float>;
  height_gt?: Maybe<Float>;
  height_gte?: Maybe<Float>;
  width?: Maybe<Float>;
  width_not?: Maybe<Float>;
  width_in?: Maybe<Float[] | Float>;
  width_not_in?: Maybe<Float[] | Float>;
  width_lt?: Maybe<Float>;
  width_lte?: Maybe<Float>;
  width_gt?: Maybe<Float>;
  width_gte?: Maybe<Float>;
  AND?: Maybe<MeasurementWhereInput[] | MeasurementWhereInput>;
  OR?: Maybe<MeasurementWhereInput[] | MeasurementWhereInput>;
  NOT?: Maybe<MeasurementWhereInput[] | MeasurementWhereInput>;
}

export interface GroupWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  permission?: Maybe<PermissionWhereInput>;
  AND?: Maybe<GroupWhereInput[] | GroupWhereInput>;
  OR?: Maybe<GroupWhereInput[] | GroupWhereInput>;
  NOT?: Maybe<GroupWhereInput[] | GroupWhereInput>;
}

export interface PermissionWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  loginAdmin?: Maybe<Boolean>;
  loginAdmin_not?: Maybe<Boolean>;
  news?: Maybe<PermissionTypeWhereInput>;
  post?: Maybe<PermissionTypeWhereInput>;
  reply?: Maybe<PermissionTypeWhereInput>;
  item?: Maybe<PermissionTypeWhereInput>;
  property?: Maybe<PermissionTypeWhereInput>;
  user?: Maybe<PermissionTypeWhereInput>;
  group?: Maybe<PermissionTypeWhereInput>;
  layout?: Maybe<PermissionTypeWhereInput>;
  log?: Maybe<PermissionTypeWhereInput>;
  analytics?: Maybe<PermissionTypeWhereInput>;
  AND?: Maybe<PermissionWhereInput[] | PermissionWhereInput>;
  OR?: Maybe<PermissionWhereInput[] | PermissionWhereInput>;
  NOT?: Maybe<PermissionWhereInput[] | PermissionWhereInput>;
}

export interface PermissionTypeWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  owner?: Maybe<AccessWhereInput>;
  group?: Maybe<AccessWhereInput>;
  anyone?: Maybe<AccessWhereInput>;
  AND?: Maybe<PermissionTypeWhereInput[] | PermissionTypeWhereInput>;
  OR?: Maybe<PermissionTypeWhereInput[] | PermissionTypeWhereInput>;
  NOT?: Maybe<PermissionTypeWhereInput[] | PermissionTypeWhereInput>;
}

export type GroupWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
  name?: Maybe<String>;
}>;

export type ImageWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export type ItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
  itemId?: Maybe<String>;
}>;

export interface i18nWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  lang?: Maybe<LangWhereInput>;
  i18n_every?: Maybe<i18nWhereInput>;
  i18n_some?: Maybe<i18nWhereInput>;
  i18n_none?: Maybe<i18nWhereInput>;
  AND?: Maybe<i18nWhereInput[] | i18nWhereInput>;
  OR?: Maybe<i18nWhereInput[] | i18nWhereInput>;
  NOT?: Maybe<i18nWhereInput[] | i18nWhereInput>;
}

export interface LangWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  langName?: Maybe<String>;
  langName_not?: Maybe<String>;
  langName_in?: Maybe<String[] | String>;
  langName_not_in?: Maybe<String[] | String>;
  langName_lt?: Maybe<String>;
  langName_lte?: Maybe<String>;
  langName_gt?: Maybe<String>;
  langName_gte?: Maybe<String>;
  langName_contains?: Maybe<String>;
  langName_not_contains?: Maybe<String>;
  langName_starts_with?: Maybe<String>;
  langName_not_starts_with?: Maybe<String>;
  langName_ends_with?: Maybe<String>;
  langName_not_ends_with?: Maybe<String>;
  i18n_every?: Maybe<i18nWhereInput>;
  i18n_some?: Maybe<i18nWhereInput>;
  i18n_none?: Maybe<i18nWhereInput>;
  AND?: Maybe<LangWhereInput[] | LangWhereInput>;
  OR?: Maybe<LangWhereInput[] | LangWhereInput>;
  NOT?: Maybe<LangWhereInput[] | LangWhereInput>;
}

export interface StatementWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  i18n_every?: Maybe<i18nWhereInput>;
  i18n_some?: Maybe<i18nWhereInput>;
  i18n_none?: Maybe<i18nWhereInput>;
  reference?: Maybe<ItemWhereInput>;
  AND?: Maybe<StatementWhereInput[] | StatementWhereInput>;
  OR?: Maybe<StatementWhereInput[] | StatementWhereInput>;
  NOT?: Maybe<StatementWhereInput[] | StatementWhereInput>;
}

export interface ItemWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  itemId?: Maybe<String>;
  itemId_not?: Maybe<String>;
  itemId_in?: Maybe<String[] | String>;
  itemId_not_in?: Maybe<String[] | String>;
  itemId_lt?: Maybe<String>;
  itemId_lte?: Maybe<String>;
  itemId_gt?: Maybe<String>;
  itemId_gte?: Maybe<String>;
  itemId_contains?: Maybe<String>;
  itemId_not_contains?: Maybe<String>;
  itemId_starts_with?: Maybe<String>;
  itemId_not_starts_with?: Maybe<String>;
  itemId_ends_with?: Maybe<String>;
  itemId_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  i18n_every?: Maybe<i18nWhereInput>;
  i18n_some?: Maybe<i18nWhereInput>;
  i18n_none?: Maybe<i18nWhereInput>;
  images_every?: Maybe<ImageWhereInput>;
  images_some?: Maybe<ImageWhereInput>;
  images_none?: Maybe<ImageWhereInput>;
  statements_every?: Maybe<StatementWhereInput>;
  statements_some?: Maybe<StatementWhereInput>;
  statements_none?: Maybe<StatementWhereInput>;
  introduction_every?: Maybe<ParagraphWhereInput>;
  introduction_some?: Maybe<ParagraphWhereInput>;
  introduction_none?: Maybe<ParagraphWhereInput>;
  logs_every?: Maybe<LogWhereInput>;
  logs_some?: Maybe<LogWhereInput>;
  logs_none?: Maybe<LogWhereInput>;
  AND?: Maybe<ItemWhereInput[] | ItemWhereInput>;
  OR?: Maybe<ItemWhereInput[] | ItemWhereInput>;
  NOT?: Maybe<ItemWhereInput[] | ItemWhereInput>;
}

export interface ParagraphWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  index?: Maybe<Int>;
  index_not?: Maybe<Int>;
  index_in?: Maybe<Int[] | Int>;
  index_not_in?: Maybe<Int[] | Int>;
  index_lt?: Maybe<Int>;
  index_lte?: Maybe<Int>;
  index_gt?: Maybe<Int>;
  index_gte?: Maybe<Int>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  type?: Maybe<ParagraphType>;
  type_not?: Maybe<ParagraphType>;
  type_in?: Maybe<ParagraphType[] | ParagraphType>;
  type_not_in?: Maybe<ParagraphType[] | ParagraphType>;
  markup_every?: Maybe<MarkupWhereInput>;
  markup_some?: Maybe<MarkupWhereInput>;
  markup_none?: Maybe<MarkupWhereInput>;
  quotes_every?: Maybe<QuoteWhereInput>;
  quotes_some?: Maybe<QuoteWhereInput>;
  quotes_none?: Maybe<QuoteWhereInput>;
  replies_every?: Maybe<ReplyWhereInput>;
  replies_some?: Maybe<ReplyWhereInput>;
  replies_none?: Maybe<ReplyWhereInput>;
  AND?: Maybe<ParagraphWhereInput[] | ParagraphWhereInput>;
  OR?: Maybe<ParagraphWhereInput[] | ParagraphWhereInput>;
  NOT?: Maybe<ParagraphWhereInput[] | ParagraphWhereInput>;
}

export interface MarkupWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  type?: Maybe<MarkupType>;
  type_not?: Maybe<MarkupType>;
  type_in?: Maybe<MarkupType[] | MarkupType>;
  type_not_in?: Maybe<MarkupType[] | MarkupType>;
  start?: Maybe<Int>;
  start_not?: Maybe<Int>;
  start_in?: Maybe<Int[] | Int>;
  start_not_in?: Maybe<Int[] | Int>;
  start_lt?: Maybe<Int>;
  start_lte?: Maybe<Int>;
  start_gt?: Maybe<Int>;
  start_gte?: Maybe<Int>;
  end?: Maybe<Int>;
  end_not?: Maybe<Int>;
  end_in?: Maybe<Int[] | Int>;
  end_not_in?: Maybe<Int[] | Int>;
  end_lt?: Maybe<Int>;
  end_lte?: Maybe<Int>;
  end_gt?: Maybe<Int>;
  end_gte?: Maybe<Int>;
  href?: Maybe<String>;
  href_not?: Maybe<String>;
  href_in?: Maybe<String[] | String>;
  href_not_in?: Maybe<String[] | String>;
  href_lt?: Maybe<String>;
  href_lte?: Maybe<String>;
  href_gt?: Maybe<String>;
  href_gte?: Maybe<String>;
  href_contains?: Maybe<String>;
  href_not_contains?: Maybe<String>;
  href_starts_with?: Maybe<String>;
  href_not_starts_with?: Maybe<String>;
  href_ends_with?: Maybe<String>;
  href_not_ends_with?: Maybe<String>;
  rel?: Maybe<String>;
  rel_not?: Maybe<String>;
  rel_in?: Maybe<String[] | String>;
  rel_not_in?: Maybe<String[] | String>;
  rel_lt?: Maybe<String>;
  rel_lte?: Maybe<String>;
  rel_gt?: Maybe<String>;
  rel_gte?: Maybe<String>;
  rel_contains?: Maybe<String>;
  rel_not_contains?: Maybe<String>;
  rel_starts_with?: Maybe<String>;
  rel_not_starts_with?: Maybe<String>;
  rel_ends_with?: Maybe<String>;
  rel_not_ends_with?: Maybe<String>;
  src?: Maybe<String>;
  src_not?: Maybe<String>;
  src_in?: Maybe<String[] | String>;
  src_not_in?: Maybe<String[] | String>;
  src_lt?: Maybe<String>;
  src_lte?: Maybe<String>;
  src_gt?: Maybe<String>;
  src_gte?: Maybe<String>;
  src_contains?: Maybe<String>;
  src_not_contains?: Maybe<String>;
  src_starts_with?: Maybe<String>;
  src_not_starts_with?: Maybe<String>;
  src_ends_with?: Maybe<String>;
  src_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  AND?: Maybe<MarkupWhereInput[] | MarkupWhereInput>;
  OR?: Maybe<MarkupWhereInput[] | MarkupWhereInput>;
  NOT?: Maybe<MarkupWhereInput[] | MarkupWhereInput>;
}

export interface QuoteWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  start?: Maybe<Int>;
  start_not?: Maybe<Int>;
  start_in?: Maybe<Int[] | Int>;
  start_not_in?: Maybe<Int[] | Int>;
  start_lt?: Maybe<Int>;
  start_lte?: Maybe<Int>;
  start_gt?: Maybe<Int>;
  start_gte?: Maybe<Int>;
  end?: Maybe<Int>;
  end_not?: Maybe<Int>;
  end_in?: Maybe<Int[] | Int>;
  end_not_in?: Maybe<Int[] | Int>;
  end_lt?: Maybe<Int>;
  end_lte?: Maybe<Int>;
  end_gt?: Maybe<Int>;
  end_gte?: Maybe<Int>;
  type?: Maybe<QuoteType>;
  type_not?: Maybe<QuoteType>;
  type_in?: Maybe<QuoteType[] | QuoteType>;
  type_not_in?: Maybe<QuoteType[] | QuoteType>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  user?: Maybe<UserWhereInput>;
  notes_every?: Maybe<NoteWhereInput>;
  notes_some?: Maybe<NoteWhereInput>;
  notes_none?: Maybe<NoteWhereInput>;
  reply_every?: Maybe<ReplyWhereInput>;
  reply_some?: Maybe<ReplyWhereInput>;
  reply_none?: Maybe<ReplyWhereInput>;
  AND?: Maybe<QuoteWhereInput[] | QuoteWhereInput>;
  OR?: Maybe<QuoteWhereInput[] | QuoteWhereInput>;
  NOT?: Maybe<QuoteWhereInput[] | QuoteWhereInput>;
}

export interface NoteWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  user?: Maybe<UserWhereInput>;
  notes_every?: Maybe<NoteWhereInput>;
  notes_some?: Maybe<NoteWhereInput>;
  notes_none?: Maybe<NoteWhereInput>;
  AND?: Maybe<NoteWhereInput[] | NoteWhereInput>;
  OR?: Maybe<NoteWhereInput[] | NoteWhereInput>;
  NOT?: Maybe<NoteWhereInput[] | NoteWhereInput>;
}

export interface ReplyWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  replyId?: Maybe<Int>;
  replyId_not?: Maybe<Int>;
  replyId_in?: Maybe<Int[] | Int>;
  replyId_not_in?: Maybe<Int[] | Int>;
  replyId_lt?: Maybe<Int>;
  replyId_lte?: Maybe<Int>;
  replyId_gt?: Maybe<Int>;
  replyId_gte?: Maybe<Int>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  replies_every?: Maybe<ReplyWhereInput>;
  replies_some?: Maybe<ReplyWhereInput>;
  replies_none?: Maybe<ReplyWhereInput>;
  AND?: Maybe<ReplyWhereInput[] | ReplyWhereInput>;
  OR?: Maybe<ReplyWhereInput[] | ReplyWhereInput>;
  NOT?: Maybe<ReplyWhereInput[] | ReplyWhereInput>;
}

export interface LogWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  ip?: Maybe<String>;
  ip_not?: Maybe<String>;
  ip_in?: Maybe<String[] | String>;
  ip_not_in?: Maybe<String[] | String>;
  ip_lt?: Maybe<String>;
  ip_lte?: Maybe<String>;
  ip_gt?: Maybe<String>;
  ip_gte?: Maybe<String>;
  ip_contains?: Maybe<String>;
  ip_not_contains?: Maybe<String>;
  ip_starts_with?: Maybe<String>;
  ip_not_starts_with?: Maybe<String>;
  ip_ends_with?: Maybe<String>;
  ip_not_ends_with?: Maybe<String>;
  event?: Maybe<EventWhereInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<LogWhereInput[] | LogWhereInput>;
  OR?: Maybe<LogWhereInput[] | LogWhereInput>;
  NOT?: Maybe<LogWhereInput[] | LogWhereInput>;
}

export type LangWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
  code?: Maybe<String>;
}>;

export type LogWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export type MarkupWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export type MeasurementWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export type NewsWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export interface NewsWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  published?: Maybe<Boolean>;
  published_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  validUntil?: Maybe<DateTimeInput>;
  validUntil_not?: Maybe<DateTimeInput>;
  validUntil_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  validUntil_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  validUntil_lt?: Maybe<DateTimeInput>;
  validUntil_lte?: Maybe<DateTimeInput>;
  validUntil_gt?: Maybe<DateTimeInput>;
  validUntil_gte?: Maybe<DateTimeInput>;
  author?: Maybe<UserWhereInput>;
  banner_every?: Maybe<ImageWhereInput>;
  banner_some?: Maybe<ImageWhereInput>;
  banner_none?: Maybe<ImageWhereInput>;
  AND?: Maybe<NewsWhereInput[] | NewsWhereInput>;
  OR?: Maybe<NewsWhereInput[] | NewsWhereInput>;
  NOT?: Maybe<NewsWhereInput[] | NewsWhereInput>;
}

export type NoteWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export type ParagraphWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export type PermissionWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
  type?: Maybe<String>;
}>;

export type PermissionTypeWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export type PostWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export interface TagWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TagWhereInput[] | TagWhereInput>;
  OR?: Maybe<TagWhereInput[] | TagWhereInput>;
  NOT?: Maybe<TagWhereInput[] | TagWhereInput>;
}

export interface PostWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  published?: Maybe<Boolean>;
  published_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  validUntil?: Maybe<DateTimeInput>;
  validUntil_not?: Maybe<DateTimeInput>;
  validUntil_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  validUntil_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  validUntil_lt?: Maybe<DateTimeInput>;
  validUntil_lte?: Maybe<DateTimeInput>;
  validUntil_gt?: Maybe<DateTimeInput>;
  validUntil_gte?: Maybe<DateTimeInput>;
  author?: Maybe<UserWhereInput>;
  banner_every?: Maybe<ImageWhereInput>;
  banner_some?: Maybe<ImageWhereInput>;
  banner_none?: Maybe<ImageWhereInput>;
  tags_every?: Maybe<TagWhereInput>;
  tags_some?: Maybe<TagWhereInput>;
  tags_none?: Maybe<TagWhereInput>;
  AND?: Maybe<PostWhereInput[] | PostWhereInput>;
  OR?: Maybe<PostWhereInput[] | PostWhereInput>;
  NOT?: Maybe<PostWhereInput[] | PostWhereInput>;
}

export type PropertyWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
  propertyId?: Maybe<String>;
  name?: Maybe<String>;
}>;

export interface PropertyWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  propertyId?: Maybe<String>;
  propertyId_not?: Maybe<String>;
  propertyId_in?: Maybe<String[] | String>;
  propertyId_not_in?: Maybe<String[] | String>;
  propertyId_lt?: Maybe<String>;
  propertyId_lte?: Maybe<String>;
  propertyId_gt?: Maybe<String>;
  propertyId_gte?: Maybe<String>;
  propertyId_contains?: Maybe<String>;
  propertyId_not_contains?: Maybe<String>;
  propertyId_starts_with?: Maybe<String>;
  propertyId_not_starts_with?: Maybe<String>;
  propertyId_ends_with?: Maybe<String>;
  propertyId_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  i18n_every?: Maybe<i18nWhereInput>;
  i18n_some?: Maybe<i18nWhereInput>;
  i18n_none?: Maybe<i18nWhereInput>;
  logs_every?: Maybe<LogWhereInput>;
  logs_some?: Maybe<LogWhereInput>;
  logs_none?: Maybe<LogWhereInput>;
  AND?: Maybe<PropertyWhereInput[] | PropertyWhereInput>;
  OR?: Maybe<PropertyWhereInput[] | PropertyWhereInput>;
  NOT?: Maybe<PropertyWhereInput[] | PropertyWhereInput>;
}

export type QuoteWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export type ReplyWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
  replyId?: Maybe<Int>;
}>;

export type StatementWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export type TagWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export type ThemeWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export interface ThemeWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  component?: Maybe<String>;
  component_not?: Maybe<String>;
  component_in?: Maybe<String[] | String>;
  component_not_in?: Maybe<String[] | String>;
  component_lt?: Maybe<String>;
  component_lte?: Maybe<String>;
  component_gt?: Maybe<String>;
  component_gte?: Maybe<String>;
  component_contains?: Maybe<String>;
  component_not_contains?: Maybe<String>;
  component_starts_with?: Maybe<String>;
  component_not_starts_with?: Maybe<String>;
  component_ends_with?: Maybe<String>;
  component_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ThemeWhereInput[] | ThemeWhereInput>;
  OR?: Maybe<ThemeWhereInput[] | ThemeWhereInput>;
  NOT?: Maybe<ThemeWhereInput[] | ThemeWhereInput>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
  userName?: Maybe<String>;
  email?: Maybe<String>;
}>;

export type i18nWhereUniqueInput = AtLeastOne<{
  id: Maybe<UUID>;
}>;

export interface AccessCreateInput {
  id?: Maybe<UUID>;
  read?: Maybe<Boolean>;
  write?: Maybe<Boolean>;
  delete?: Maybe<Boolean>;
}

export interface AccessUpdateInput {
  read?: Maybe<Boolean>;
  write?: Maybe<Boolean>;
  delete?: Maybe<Boolean>;
}

export interface AccessUpdateManyMutationInput {
  read?: Maybe<Boolean>;
  write?: Maybe<Boolean>;
  delete?: Maybe<Boolean>;
}

export interface EventCreateInput {
  id?: Maybe<UUID>;
  type?: Maybe<EventType>;
  result?: Maybe<String>;
  timemark: DateTimeInput;
  meta?: Maybe<Json>;
}

export interface EventUpdateInput {
  type?: Maybe<EventType>;
  result?: Maybe<String>;
  timemark?: Maybe<DateTimeInput>;
  meta?: Maybe<Json>;
}

export interface EventUpdateManyMutationInput {
  type?: Maybe<EventType>;
  result?: Maybe<String>;
  timemark?: Maybe<DateTimeInput>;
  meta?: Maybe<Json>;
}

export interface FileCreateInput {
  id?: Maybe<UUID>;
  name: String;
  path: String;
  size?: Maybe<Float>;
  hidden?: Maybe<Boolean>;
  uploadBy: UserCreateOneInput;
  meta?: Maybe<Json>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<UUID>;
  userName: String;
  email: String;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  description?: Maybe<String>;
  avatar?: Maybe<ImageCreateOneInput>;
  group?: Maybe<GroupCreateOneInput>;
  meta?: Maybe<Json>;
}

export interface ImageCreateOneInput {
  create?: Maybe<ImageCreateInput>;
  connect?: Maybe<ImageWhereUniqueInput>;
}

export interface ImageCreateInput {
  id?: Maybe<UUID>;
  name: String;
  description?: Maybe<String>;
  format?: Maybe<MeasurementCreateOneInput>;
  file?: Maybe<FileCreateOneInput>;
  meta?: Maybe<Json>;
}

export interface MeasurementCreateOneInput {
  create?: Maybe<MeasurementCreateInput>;
  connect?: Maybe<MeasurementWhereUniqueInput>;
}

export interface MeasurementCreateInput {
  id?: Maybe<UUID>;
  height?: Maybe<Float>;
  width?: Maybe<Float>;
}

export interface FileCreateOneInput {
  create?: Maybe<FileCreateInput>;
  connect?: Maybe<FileWhereUniqueInput>;
}

export interface GroupCreateOneInput {
  create?: Maybe<GroupCreateInput>;
  connect?: Maybe<GroupWhereUniqueInput>;
}

export interface GroupCreateInput {
  id?: Maybe<UUID>;
  name: String;
  description?: Maybe<String>;
  permission: PermissionCreateOneInput;
  meta?: Maybe<Json>;
}

export interface PermissionCreateOneInput {
  create?: Maybe<PermissionCreateInput>;
  connect?: Maybe<PermissionWhereUniqueInput>;
}

export interface PermissionCreateInput {
  id?: Maybe<UUID>;
  type: String;
  loginAdmin?: Maybe<Boolean>;
  news: PermissionTypeCreateOneInput;
  post: PermissionTypeCreateOneInput;
  reply: PermissionTypeCreateOneInput;
  item: PermissionTypeCreateOneInput;
  property: PermissionTypeCreateOneInput;
  user: PermissionTypeCreateOneInput;
  group: PermissionTypeCreateOneInput;
  layout: PermissionTypeCreateOneInput;
  log: PermissionTypeCreateOneInput;
  analytics: PermissionTypeCreateOneInput;
  meta?: Maybe<Json>;
}

export interface PermissionTypeCreateOneInput {
  create?: Maybe<PermissionTypeCreateInput>;
  connect?: Maybe<PermissionTypeWhereUniqueInput>;
}

export interface PermissionTypeCreateInput {
  id?: Maybe<UUID>;
  owner: AccessCreateOneInput;
  group: AccessCreateOneInput;
  anyone: AccessCreateOneInput;
}

export interface AccessCreateOneInput {
  create?: Maybe<AccessCreateInput>;
  connect?: Maybe<AccessWhereUniqueInput>;
}

export interface FileUpdateInput {
  name?: Maybe<String>;
  path?: Maybe<String>;
  size?: Maybe<Float>;
  hidden?: Maybe<Boolean>;
  uploadBy?: Maybe<UserUpdateOneRequiredInput>;
  meta?: Maybe<Json>;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  userName?: Maybe<String>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  description?: Maybe<String>;
  avatar?: Maybe<ImageUpdateOneInput>;
  group?: Maybe<GroupUpdateOneInput>;
  meta?: Maybe<Json>;
}

export interface ImageUpdateOneInput {
  create?: Maybe<ImageCreateInput>;
  update?: Maybe<ImageUpdateDataInput>;
  upsert?: Maybe<ImageUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ImageWhereUniqueInput>;
}

export interface ImageUpdateDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  format?: Maybe<MeasurementUpdateOneInput>;
  file?: Maybe<FileUpdateOneInput>;
  meta?: Maybe<Json>;
}

export interface MeasurementUpdateOneInput {
  create?: Maybe<MeasurementCreateInput>;
  update?: Maybe<MeasurementUpdateDataInput>;
  upsert?: Maybe<MeasurementUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<MeasurementWhereUniqueInput>;
}

export interface MeasurementUpdateDataInput {
  height?: Maybe<Float>;
  width?: Maybe<Float>;
}

export interface MeasurementUpsertNestedInput {
  update: MeasurementUpdateDataInput;
  create: MeasurementCreateInput;
}

export interface FileUpdateOneInput {
  create?: Maybe<FileCreateInput>;
  update?: Maybe<FileUpdateDataInput>;
  upsert?: Maybe<FileUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<FileWhereUniqueInput>;
}

export interface FileUpdateDataInput {
  name?: Maybe<String>;
  path?: Maybe<String>;
  size?: Maybe<Float>;
  hidden?: Maybe<Boolean>;
  uploadBy?: Maybe<UserUpdateOneRequiredInput>;
  meta?: Maybe<Json>;
}

export interface FileUpsertNestedInput {
  update: FileUpdateDataInput;
  create: FileCreateInput;
}

export interface ImageUpsertNestedInput {
  update: ImageUpdateDataInput;
  create: ImageCreateInput;
}

export interface GroupUpdateOneInput {
  create?: Maybe<GroupCreateInput>;
  update?: Maybe<GroupUpdateDataInput>;
  upsert?: Maybe<GroupUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<GroupWhereUniqueInput>;
}

export interface GroupUpdateDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  permission?: Maybe<PermissionUpdateOneRequiredInput>;
  meta?: Maybe<Json>;
}

export interface PermissionUpdateOneRequiredInput {
  create?: Maybe<PermissionCreateInput>;
  update?: Maybe<PermissionUpdateDataInput>;
  upsert?: Maybe<PermissionUpsertNestedInput>;
  connect?: Maybe<PermissionWhereUniqueInput>;
}

export interface PermissionUpdateDataInput {
  type?: Maybe<String>;
  loginAdmin?: Maybe<Boolean>;
  news?: Maybe<PermissionTypeUpdateOneRequiredInput>;
  post?: Maybe<PermissionTypeUpdateOneRequiredInput>;
  reply?: Maybe<PermissionTypeUpdateOneRequiredInput>;
  item?: Maybe<PermissionTypeUpdateOneRequiredInput>;
  property?: Maybe<PermissionTypeUpdateOneRequiredInput>;
  user?: Maybe<PermissionTypeUpdateOneRequiredInput>;
  group?: Maybe<PermissionTypeUpdateOneRequiredInput>;
  layout?: Maybe<PermissionTypeUpdateOneRequiredInput>;
  log?: Maybe<PermissionTypeUpdateOneRequiredInput>;
  analytics?: Maybe<PermissionTypeUpdateOneRequiredInput>;
  meta?: Maybe<Json>;
}

export interface PermissionTypeUpdateOneRequiredInput {
  create?: Maybe<PermissionTypeCreateInput>;
  update?: Maybe<PermissionTypeUpdateDataInput>;
  upsert?: Maybe<PermissionTypeUpsertNestedInput>;
  connect?: Maybe<PermissionTypeWhereUniqueInput>;
}

export interface PermissionTypeUpdateDataInput {
  owner?: Maybe<AccessUpdateOneRequiredInput>;
  group?: Maybe<AccessUpdateOneRequiredInput>;
  anyone?: Maybe<AccessUpdateOneRequiredInput>;
}

export interface AccessUpdateOneRequiredInput {
  create?: Maybe<AccessCreateInput>;
  update?: Maybe<AccessUpdateDataInput>;
  upsert?: Maybe<AccessUpsertNestedInput>;
  connect?: Maybe<AccessWhereUniqueInput>;
}

export interface AccessUpdateDataInput {
  read?: Maybe<Boolean>;
  write?: Maybe<Boolean>;
  delete?: Maybe<Boolean>;
}

export interface AccessUpsertNestedInput {
  update: AccessUpdateDataInput;
  create: AccessCreateInput;
}

export interface PermissionTypeUpsertNestedInput {
  update: PermissionTypeUpdateDataInput;
  create: PermissionTypeCreateInput;
}

export interface PermissionUpsertNestedInput {
  update: PermissionUpdateDataInput;
  create: PermissionCreateInput;
}

export interface GroupUpsertNestedInput {
  update: GroupUpdateDataInput;
  create: GroupCreateInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface FileUpdateManyMutationInput {
  name?: Maybe<String>;
  path?: Maybe<String>;
  size?: Maybe<Float>;
  hidden?: Maybe<Boolean>;
  meta?: Maybe<Json>;
}

export interface GroupUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  permission?: Maybe<PermissionUpdateOneRequiredInput>;
  meta?: Maybe<Json>;
}

export interface GroupUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface ImageUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  format?: Maybe<MeasurementUpdateOneInput>;
  file?: Maybe<FileUpdateOneInput>;
  meta?: Maybe<Json>;
}

export interface ImageUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface ItemCreateInput {
  id?: Maybe<UUID>;
  itemId: String;
  name: String;
  i18n?: Maybe<i18nCreateManyInput>;
  images?: Maybe<ImageCreateManyInput>;
  statements?: Maybe<StatementCreateManyWithoutReferenceInput>;
  introduction?: Maybe<ParagraphCreateManyInput>;
  logs?: Maybe<LogCreateManyInput>;
  meta?: Maybe<Json>;
}

export interface i18nCreateManyInput {
  create?: Maybe<i18nCreateInput[] | i18nCreateInput>;
  connect?: Maybe<i18nWhereUniqueInput[] | i18nWhereUniqueInput>;
}

export interface i18nCreateInput {
  id?: Maybe<UUID>;
  text?: Maybe<String>;
  lang: LangCreateOneWithoutI18nInput;
  i18n?: Maybe<i18nCreateManyInput>;
  meta?: Maybe<Json>;
}

export interface LangCreateOneWithoutI18nInput {
  create?: Maybe<LangCreateWithoutI18nInput>;
  connect?: Maybe<LangWhereUniqueInput>;
}

export interface LangCreateWithoutI18nInput {
  id?: Maybe<UUID>;
  code: String;
  langName: String;
  meta?: Maybe<Json>;
}

export interface ImageCreateManyInput {
  create?: Maybe<ImageCreateInput[] | ImageCreateInput>;
  connect?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
}

export interface StatementCreateManyWithoutReferenceInput {
  create?: Maybe<
    | StatementCreateWithoutReferenceInput[]
    | StatementCreateWithoutReferenceInput
  >;
  connect?: Maybe<StatementWhereUniqueInput[] | StatementWhereUniqueInput>;
}

export interface StatementCreateWithoutReferenceInput {
  id?: Maybe<UUID>;
  value: String;
  i18n?: Maybe<i18nCreateManyInput>;
  meta?: Maybe<Json>;
}

export interface ParagraphCreateManyInput {
  create?: Maybe<ParagraphCreateInput[] | ParagraphCreateInput>;
  connect?: Maybe<ParagraphWhereUniqueInput[] | ParagraphWhereUniqueInput>;
}

export interface ParagraphCreateInput {
  id?: Maybe<UUID>;
  index?: Maybe<Int>;
  text?: Maybe<String>;
  type?: Maybe<ParagraphType>;
  markup?: Maybe<MarkupCreateManyInput>;
  quotes?: Maybe<QuoteCreateManyInput>;
  replies?: Maybe<ReplyCreateManyInput>;
  meta?: Maybe<Json>;
}

export interface MarkupCreateManyInput {
  create?: Maybe<MarkupCreateInput[] | MarkupCreateInput>;
  connect?: Maybe<MarkupWhereUniqueInput[] | MarkupWhereUniqueInput>;
}

export interface MarkupCreateInput {
  id?: Maybe<UUID>;
  type: MarkupType;
  start?: Maybe<Int>;
  end?: Maybe<Int>;
  href?: Maybe<String>;
  rel?: Maybe<String>;
  src?: Maybe<String>;
  title?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface QuoteCreateManyInput {
  create?: Maybe<QuoteCreateInput[] | QuoteCreateInput>;
  connect?: Maybe<QuoteWhereUniqueInput[] | QuoteWhereUniqueInput>;
}

export interface QuoteCreateInput {
  id?: Maybe<UUID>;
  start?: Maybe<Int>;
  end?: Maybe<Int>;
  type?: Maybe<QuoteType>;
  user: UserCreateOneInput;
  notes?: Maybe<NoteCreateManyInput>;
  reply?: Maybe<ReplyCreateManyInput>;
  meta?: Maybe<Json>;
}

export interface NoteCreateManyInput {
  create?: Maybe<NoteCreateInput[] | NoteCreateInput>;
  connect?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
}

export interface NoteCreateInput {
  id?: Maybe<UUID>;
  content?: Maybe<String>;
  user: UserCreateOneInput;
  notes?: Maybe<NoteCreateManyInput>;
  meta?: Maybe<Json>;
}

export interface ReplyCreateManyInput {
  create?: Maybe<ReplyCreateInput[] | ReplyCreateInput>;
  connect?: Maybe<ReplyWhereUniqueInput[] | ReplyWhereUniqueInput>;
}

export interface ReplyCreateInput {
  id?: Maybe<UUID>;
  replyId: Int;
  content: String;
  user: UserCreateOneInput;
  replies?: Maybe<ReplyCreateManyInput>;
  meta?: Maybe<Json>;
}

export interface LogCreateManyInput {
  create?: Maybe<LogCreateInput[] | LogCreateInput>;
  connect?: Maybe<LogWhereUniqueInput[] | LogWhereUniqueInput>;
}

export interface LogCreateInput {
  id?: Maybe<UUID>;
  ip: String;
  event: EventCreateOneInput;
  user: UserCreateOneInput;
  meta?: Maybe<Json>;
}

export interface EventCreateOneInput {
  create?: Maybe<EventCreateInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface ItemUpdateInput {
  itemId?: Maybe<String>;
  name?: Maybe<String>;
  i18n?: Maybe<i18nUpdateManyInput>;
  images?: Maybe<ImageUpdateManyInput>;
  statements?: Maybe<StatementUpdateManyWithoutReferenceInput>;
  introduction?: Maybe<ParagraphUpdateManyInput>;
  logs?: Maybe<LogUpdateManyInput>;
  meta?: Maybe<Json>;
}

export interface i18nUpdateManyInput {
  create?: Maybe<i18nCreateInput[] | i18nCreateInput>;
  update?: Maybe<
    | i18nUpdateWithWhereUniqueNestedInput[]
    | i18nUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | i18nUpsertWithWhereUniqueNestedInput[]
    | i18nUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<i18nWhereUniqueInput[] | i18nWhereUniqueInput>;
  connect?: Maybe<i18nWhereUniqueInput[] | i18nWhereUniqueInput>;
  set?: Maybe<i18nWhereUniqueInput[] | i18nWhereUniqueInput>;
  disconnect?: Maybe<i18nWhereUniqueInput[] | i18nWhereUniqueInput>;
  deleteMany?: Maybe<i18nScalarWhereInput[] | i18nScalarWhereInput>;
  updateMany?: Maybe<
    i18nUpdateManyWithWhereNestedInput[] | i18nUpdateManyWithWhereNestedInput
  >;
}

export interface i18nUpdateWithWhereUniqueNestedInput {
  where: i18nWhereUniqueInput;
  data: i18nUpdateDataInput;
}

export interface i18nUpdateDataInput {
  text?: Maybe<String>;
  lang?: Maybe<LangUpdateOneRequiredWithoutI18nInput>;
  i18n?: Maybe<i18nUpdateManyInput>;
  meta?: Maybe<Json>;
}

export interface LangUpdateOneRequiredWithoutI18nInput {
  create?: Maybe<LangCreateWithoutI18nInput>;
  update?: Maybe<LangUpdateWithoutI18nDataInput>;
  upsert?: Maybe<LangUpsertWithoutI18nInput>;
  connect?: Maybe<LangWhereUniqueInput>;
}

export interface LangUpdateWithoutI18nDataInput {
  code?: Maybe<String>;
  langName?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface LangUpsertWithoutI18nInput {
  update: LangUpdateWithoutI18nDataInput;
  create: LangCreateWithoutI18nInput;
}

export interface i18nUpsertWithWhereUniqueNestedInput {
  where: i18nWhereUniqueInput;
  update: i18nUpdateDataInput;
  create: i18nCreateInput;
}

export interface i18nScalarWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  AND?: Maybe<i18nScalarWhereInput[] | i18nScalarWhereInput>;
  OR?: Maybe<i18nScalarWhereInput[] | i18nScalarWhereInput>;
  NOT?: Maybe<i18nScalarWhereInput[] | i18nScalarWhereInput>;
}

export interface i18nUpdateManyWithWhereNestedInput {
  where: i18nScalarWhereInput;
  data: i18nUpdateManyDataInput;
}

export interface i18nUpdateManyDataInput {
  text?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface ImageUpdateManyInput {
  create?: Maybe<ImageCreateInput[] | ImageCreateInput>;
  update?: Maybe<
    | ImageUpdateWithWhereUniqueNestedInput[]
    | ImageUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ImageUpsertWithWhereUniqueNestedInput[]
    | ImageUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
  connect?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
  set?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
  disconnect?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
  deleteMany?: Maybe<ImageScalarWhereInput[] | ImageScalarWhereInput>;
  updateMany?: Maybe<
    ImageUpdateManyWithWhereNestedInput[] | ImageUpdateManyWithWhereNestedInput
  >;
}

export interface ImageUpdateWithWhereUniqueNestedInput {
  where: ImageWhereUniqueInput;
  data: ImageUpdateDataInput;
}

export interface ImageUpsertWithWhereUniqueNestedInput {
  where: ImageWhereUniqueInput;
  update: ImageUpdateDataInput;
  create: ImageCreateInput;
}

export interface ImageScalarWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<ImageScalarWhereInput[] | ImageScalarWhereInput>;
  OR?: Maybe<ImageScalarWhereInput[] | ImageScalarWhereInput>;
  NOT?: Maybe<ImageScalarWhereInput[] | ImageScalarWhereInput>;
}

export interface ImageUpdateManyWithWhereNestedInput {
  where: ImageScalarWhereInput;
  data: ImageUpdateManyDataInput;
}

export interface ImageUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface StatementUpdateManyWithoutReferenceInput {
  create?: Maybe<
    | StatementCreateWithoutReferenceInput[]
    | StatementCreateWithoutReferenceInput
  >;
  delete?: Maybe<StatementWhereUniqueInput[] | StatementWhereUniqueInput>;
  connect?: Maybe<StatementWhereUniqueInput[] | StatementWhereUniqueInput>;
  set?: Maybe<StatementWhereUniqueInput[] | StatementWhereUniqueInput>;
  disconnect?: Maybe<StatementWhereUniqueInput[] | StatementWhereUniqueInput>;
  update?: Maybe<
    | StatementUpdateWithWhereUniqueWithoutReferenceInput[]
    | StatementUpdateWithWhereUniqueWithoutReferenceInput
  >;
  upsert?: Maybe<
    | StatementUpsertWithWhereUniqueWithoutReferenceInput[]
    | StatementUpsertWithWhereUniqueWithoutReferenceInput
  >;
  deleteMany?: Maybe<StatementScalarWhereInput[] | StatementScalarWhereInput>;
  updateMany?: Maybe<
    | StatementUpdateManyWithWhereNestedInput[]
    | StatementUpdateManyWithWhereNestedInput
  >;
}

export interface StatementUpdateWithWhereUniqueWithoutReferenceInput {
  where: StatementWhereUniqueInput;
  data: StatementUpdateWithoutReferenceDataInput;
}

export interface StatementUpdateWithoutReferenceDataInput {
  value?: Maybe<String>;
  i18n?: Maybe<i18nUpdateManyInput>;
  meta?: Maybe<Json>;
}

export interface StatementUpsertWithWhereUniqueWithoutReferenceInput {
  where: StatementWhereUniqueInput;
  update: StatementUpdateWithoutReferenceDataInput;
  create: StatementCreateWithoutReferenceInput;
}

export interface StatementScalarWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  AND?: Maybe<StatementScalarWhereInput[] | StatementScalarWhereInput>;
  OR?: Maybe<StatementScalarWhereInput[] | StatementScalarWhereInput>;
  NOT?: Maybe<StatementScalarWhereInput[] | StatementScalarWhereInput>;
}

export interface StatementUpdateManyWithWhereNestedInput {
  where: StatementScalarWhereInput;
  data: StatementUpdateManyDataInput;
}

export interface StatementUpdateManyDataInput {
  value?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface ParagraphUpdateManyInput {
  create?: Maybe<ParagraphCreateInput[] | ParagraphCreateInput>;
  update?: Maybe<
    | ParagraphUpdateWithWhereUniqueNestedInput[]
    | ParagraphUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ParagraphUpsertWithWhereUniqueNestedInput[]
    | ParagraphUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ParagraphWhereUniqueInput[] | ParagraphWhereUniqueInput>;
  connect?: Maybe<ParagraphWhereUniqueInput[] | ParagraphWhereUniqueInput>;
  set?: Maybe<ParagraphWhereUniqueInput[] | ParagraphWhereUniqueInput>;
  disconnect?: Maybe<ParagraphWhereUniqueInput[] | ParagraphWhereUniqueInput>;
  deleteMany?: Maybe<ParagraphScalarWhereInput[] | ParagraphScalarWhereInput>;
  updateMany?: Maybe<
    | ParagraphUpdateManyWithWhereNestedInput[]
    | ParagraphUpdateManyWithWhereNestedInput
  >;
}

export interface ParagraphUpdateWithWhereUniqueNestedInput {
  where: ParagraphWhereUniqueInput;
  data: ParagraphUpdateDataInput;
}

export interface ParagraphUpdateDataInput {
  index?: Maybe<Int>;
  text?: Maybe<String>;
  type?: Maybe<ParagraphType>;
  markup?: Maybe<MarkupUpdateManyInput>;
  quotes?: Maybe<QuoteUpdateManyInput>;
  replies?: Maybe<ReplyUpdateManyInput>;
  meta?: Maybe<Json>;
}

export interface MarkupUpdateManyInput {
  create?: Maybe<MarkupCreateInput[] | MarkupCreateInput>;
  update?: Maybe<
    | MarkupUpdateWithWhereUniqueNestedInput[]
    | MarkupUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | MarkupUpsertWithWhereUniqueNestedInput[]
    | MarkupUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<MarkupWhereUniqueInput[] | MarkupWhereUniqueInput>;
  connect?: Maybe<MarkupWhereUniqueInput[] | MarkupWhereUniqueInput>;
  set?: Maybe<MarkupWhereUniqueInput[] | MarkupWhereUniqueInput>;
  disconnect?: Maybe<MarkupWhereUniqueInput[] | MarkupWhereUniqueInput>;
  deleteMany?: Maybe<MarkupScalarWhereInput[] | MarkupScalarWhereInput>;
  updateMany?: Maybe<
    | MarkupUpdateManyWithWhereNestedInput[]
    | MarkupUpdateManyWithWhereNestedInput
  >;
}

export interface MarkupUpdateWithWhereUniqueNestedInput {
  where: MarkupWhereUniqueInput;
  data: MarkupUpdateDataInput;
}

export interface MarkupUpdateDataInput {
  type?: Maybe<MarkupType>;
  start?: Maybe<Int>;
  end?: Maybe<Int>;
  href?: Maybe<String>;
  rel?: Maybe<String>;
  src?: Maybe<String>;
  title?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface MarkupUpsertWithWhereUniqueNestedInput {
  where: MarkupWhereUniqueInput;
  update: MarkupUpdateDataInput;
  create: MarkupCreateInput;
}

export interface MarkupScalarWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  type?: Maybe<MarkupType>;
  type_not?: Maybe<MarkupType>;
  type_in?: Maybe<MarkupType[] | MarkupType>;
  type_not_in?: Maybe<MarkupType[] | MarkupType>;
  start?: Maybe<Int>;
  start_not?: Maybe<Int>;
  start_in?: Maybe<Int[] | Int>;
  start_not_in?: Maybe<Int[] | Int>;
  start_lt?: Maybe<Int>;
  start_lte?: Maybe<Int>;
  start_gt?: Maybe<Int>;
  start_gte?: Maybe<Int>;
  end?: Maybe<Int>;
  end_not?: Maybe<Int>;
  end_in?: Maybe<Int[] | Int>;
  end_not_in?: Maybe<Int[] | Int>;
  end_lt?: Maybe<Int>;
  end_lte?: Maybe<Int>;
  end_gt?: Maybe<Int>;
  end_gte?: Maybe<Int>;
  href?: Maybe<String>;
  href_not?: Maybe<String>;
  href_in?: Maybe<String[] | String>;
  href_not_in?: Maybe<String[] | String>;
  href_lt?: Maybe<String>;
  href_lte?: Maybe<String>;
  href_gt?: Maybe<String>;
  href_gte?: Maybe<String>;
  href_contains?: Maybe<String>;
  href_not_contains?: Maybe<String>;
  href_starts_with?: Maybe<String>;
  href_not_starts_with?: Maybe<String>;
  href_ends_with?: Maybe<String>;
  href_not_ends_with?: Maybe<String>;
  rel?: Maybe<String>;
  rel_not?: Maybe<String>;
  rel_in?: Maybe<String[] | String>;
  rel_not_in?: Maybe<String[] | String>;
  rel_lt?: Maybe<String>;
  rel_lte?: Maybe<String>;
  rel_gt?: Maybe<String>;
  rel_gte?: Maybe<String>;
  rel_contains?: Maybe<String>;
  rel_not_contains?: Maybe<String>;
  rel_starts_with?: Maybe<String>;
  rel_not_starts_with?: Maybe<String>;
  rel_ends_with?: Maybe<String>;
  rel_not_ends_with?: Maybe<String>;
  src?: Maybe<String>;
  src_not?: Maybe<String>;
  src_in?: Maybe<String[] | String>;
  src_not_in?: Maybe<String[] | String>;
  src_lt?: Maybe<String>;
  src_lte?: Maybe<String>;
  src_gt?: Maybe<String>;
  src_gte?: Maybe<String>;
  src_contains?: Maybe<String>;
  src_not_contains?: Maybe<String>;
  src_starts_with?: Maybe<String>;
  src_not_starts_with?: Maybe<String>;
  src_ends_with?: Maybe<String>;
  src_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  AND?: Maybe<MarkupScalarWhereInput[] | MarkupScalarWhereInput>;
  OR?: Maybe<MarkupScalarWhereInput[] | MarkupScalarWhereInput>;
  NOT?: Maybe<MarkupScalarWhereInput[] | MarkupScalarWhereInput>;
}

export interface MarkupUpdateManyWithWhereNestedInput {
  where: MarkupScalarWhereInput;
  data: MarkupUpdateManyDataInput;
}

export interface MarkupUpdateManyDataInput {
  type?: Maybe<MarkupType>;
  start?: Maybe<Int>;
  end?: Maybe<Int>;
  href?: Maybe<String>;
  rel?: Maybe<String>;
  src?: Maybe<String>;
  title?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface QuoteUpdateManyInput {
  create?: Maybe<QuoteCreateInput[] | QuoteCreateInput>;
  update?: Maybe<
    | QuoteUpdateWithWhereUniqueNestedInput[]
    | QuoteUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | QuoteUpsertWithWhereUniqueNestedInput[]
    | QuoteUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<QuoteWhereUniqueInput[] | QuoteWhereUniqueInput>;
  connect?: Maybe<QuoteWhereUniqueInput[] | QuoteWhereUniqueInput>;
  set?: Maybe<QuoteWhereUniqueInput[] | QuoteWhereUniqueInput>;
  disconnect?: Maybe<QuoteWhereUniqueInput[] | QuoteWhereUniqueInput>;
  deleteMany?: Maybe<QuoteScalarWhereInput[] | QuoteScalarWhereInput>;
  updateMany?: Maybe<
    QuoteUpdateManyWithWhereNestedInput[] | QuoteUpdateManyWithWhereNestedInput
  >;
}

export interface QuoteUpdateWithWhereUniqueNestedInput {
  where: QuoteWhereUniqueInput;
  data: QuoteUpdateDataInput;
}

export interface QuoteUpdateDataInput {
  start?: Maybe<Int>;
  end?: Maybe<Int>;
  type?: Maybe<QuoteType>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  notes?: Maybe<NoteUpdateManyInput>;
  reply?: Maybe<ReplyUpdateManyInput>;
  meta?: Maybe<Json>;
}

export interface NoteUpdateManyInput {
  create?: Maybe<NoteCreateInput[] | NoteCreateInput>;
  update?: Maybe<
    | NoteUpdateWithWhereUniqueNestedInput[]
    | NoteUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | NoteUpsertWithWhereUniqueNestedInput[]
    | NoteUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  connect?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  set?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  disconnect?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  deleteMany?: Maybe<NoteScalarWhereInput[] | NoteScalarWhereInput>;
  updateMany?: Maybe<
    NoteUpdateManyWithWhereNestedInput[] | NoteUpdateManyWithWhereNestedInput
  >;
}

export interface NoteUpdateWithWhereUniqueNestedInput {
  where: NoteWhereUniqueInput;
  data: NoteUpdateDataInput;
}

export interface NoteUpdateDataInput {
  content?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  notes?: Maybe<NoteUpdateManyInput>;
  meta?: Maybe<Json>;
}

export interface NoteUpsertWithWhereUniqueNestedInput {
  where: NoteWhereUniqueInput;
  update: NoteUpdateDataInput;
  create: NoteCreateInput;
}

export interface NoteScalarWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<NoteScalarWhereInput[] | NoteScalarWhereInput>;
  OR?: Maybe<NoteScalarWhereInput[] | NoteScalarWhereInput>;
  NOT?: Maybe<NoteScalarWhereInput[] | NoteScalarWhereInput>;
}

export interface NoteUpdateManyWithWhereNestedInput {
  where: NoteScalarWhereInput;
  data: NoteUpdateManyDataInput;
}

export interface NoteUpdateManyDataInput {
  content?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface ReplyUpdateManyInput {
  create?: Maybe<ReplyCreateInput[] | ReplyCreateInput>;
  update?: Maybe<
    | ReplyUpdateWithWhereUniqueNestedInput[]
    | ReplyUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ReplyUpsertWithWhereUniqueNestedInput[]
    | ReplyUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ReplyWhereUniqueInput[] | ReplyWhereUniqueInput>;
  connect?: Maybe<ReplyWhereUniqueInput[] | ReplyWhereUniqueInput>;
  set?: Maybe<ReplyWhereUniqueInput[] | ReplyWhereUniqueInput>;
  disconnect?: Maybe<ReplyWhereUniqueInput[] | ReplyWhereUniqueInput>;
  deleteMany?: Maybe<ReplyScalarWhereInput[] | ReplyScalarWhereInput>;
  updateMany?: Maybe<
    ReplyUpdateManyWithWhereNestedInput[] | ReplyUpdateManyWithWhereNestedInput
  >;
}

export interface ReplyUpdateWithWhereUniqueNestedInput {
  where: ReplyWhereUniqueInput;
  data: ReplyUpdateDataInput;
}

export interface ReplyUpdateDataInput {
  replyId?: Maybe<Int>;
  content?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  replies?: Maybe<ReplyUpdateManyInput>;
  meta?: Maybe<Json>;
}

export interface ReplyUpsertWithWhereUniqueNestedInput {
  where: ReplyWhereUniqueInput;
  update: ReplyUpdateDataInput;
  create: ReplyCreateInput;
}

export interface ReplyScalarWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  replyId?: Maybe<Int>;
  replyId_not?: Maybe<Int>;
  replyId_in?: Maybe<Int[] | Int>;
  replyId_not_in?: Maybe<Int[] | Int>;
  replyId_lt?: Maybe<Int>;
  replyId_lte?: Maybe<Int>;
  replyId_gt?: Maybe<Int>;
  replyId_gte?: Maybe<Int>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReplyScalarWhereInput[] | ReplyScalarWhereInput>;
  OR?: Maybe<ReplyScalarWhereInput[] | ReplyScalarWhereInput>;
  NOT?: Maybe<ReplyScalarWhereInput[] | ReplyScalarWhereInput>;
}

export interface ReplyUpdateManyWithWhereNestedInput {
  where: ReplyScalarWhereInput;
  data: ReplyUpdateManyDataInput;
}

export interface ReplyUpdateManyDataInput {
  replyId?: Maybe<Int>;
  content?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface QuoteUpsertWithWhereUniqueNestedInput {
  where: QuoteWhereUniqueInput;
  update: QuoteUpdateDataInput;
  create: QuoteCreateInput;
}

export interface QuoteScalarWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  start?: Maybe<Int>;
  start_not?: Maybe<Int>;
  start_in?: Maybe<Int[] | Int>;
  start_not_in?: Maybe<Int[] | Int>;
  start_lt?: Maybe<Int>;
  start_lte?: Maybe<Int>;
  start_gt?: Maybe<Int>;
  start_gte?: Maybe<Int>;
  end?: Maybe<Int>;
  end_not?: Maybe<Int>;
  end_in?: Maybe<Int[] | Int>;
  end_not_in?: Maybe<Int[] | Int>;
  end_lt?: Maybe<Int>;
  end_lte?: Maybe<Int>;
  end_gt?: Maybe<Int>;
  end_gte?: Maybe<Int>;
  type?: Maybe<QuoteType>;
  type_not?: Maybe<QuoteType>;
  type_in?: Maybe<QuoteType[] | QuoteType>;
  type_not_in?: Maybe<QuoteType[] | QuoteType>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<QuoteScalarWhereInput[] | QuoteScalarWhereInput>;
  OR?: Maybe<QuoteScalarWhereInput[] | QuoteScalarWhereInput>;
  NOT?: Maybe<QuoteScalarWhereInput[] | QuoteScalarWhereInput>;
}

export interface QuoteUpdateManyWithWhereNestedInput {
  where: QuoteScalarWhereInput;
  data: QuoteUpdateManyDataInput;
}

export interface QuoteUpdateManyDataInput {
  start?: Maybe<Int>;
  end?: Maybe<Int>;
  type?: Maybe<QuoteType>;
  meta?: Maybe<Json>;
}

export interface ParagraphUpsertWithWhereUniqueNestedInput {
  where: ParagraphWhereUniqueInput;
  update: ParagraphUpdateDataInput;
  create: ParagraphCreateInput;
}

export interface ParagraphScalarWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  index?: Maybe<Int>;
  index_not?: Maybe<Int>;
  index_in?: Maybe<Int[] | Int>;
  index_not_in?: Maybe<Int[] | Int>;
  index_lt?: Maybe<Int>;
  index_lte?: Maybe<Int>;
  index_gt?: Maybe<Int>;
  index_gte?: Maybe<Int>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  type?: Maybe<ParagraphType>;
  type_not?: Maybe<ParagraphType>;
  type_in?: Maybe<ParagraphType[] | ParagraphType>;
  type_not_in?: Maybe<ParagraphType[] | ParagraphType>;
  AND?: Maybe<ParagraphScalarWhereInput[] | ParagraphScalarWhereInput>;
  OR?: Maybe<ParagraphScalarWhereInput[] | ParagraphScalarWhereInput>;
  NOT?: Maybe<ParagraphScalarWhereInput[] | ParagraphScalarWhereInput>;
}

export interface ParagraphUpdateManyWithWhereNestedInput {
  where: ParagraphScalarWhereInput;
  data: ParagraphUpdateManyDataInput;
}

export interface ParagraphUpdateManyDataInput {
  index?: Maybe<Int>;
  text?: Maybe<String>;
  type?: Maybe<ParagraphType>;
  meta?: Maybe<Json>;
}

export interface LogUpdateManyInput {
  create?: Maybe<LogCreateInput[] | LogCreateInput>;
  update?: Maybe<
    LogUpdateWithWhereUniqueNestedInput[] | LogUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    LogUpsertWithWhereUniqueNestedInput[] | LogUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<LogWhereUniqueInput[] | LogWhereUniqueInput>;
  connect?: Maybe<LogWhereUniqueInput[] | LogWhereUniqueInput>;
  set?: Maybe<LogWhereUniqueInput[] | LogWhereUniqueInput>;
  disconnect?: Maybe<LogWhereUniqueInput[] | LogWhereUniqueInput>;
  deleteMany?: Maybe<LogScalarWhereInput[] | LogScalarWhereInput>;
  updateMany?: Maybe<
    LogUpdateManyWithWhereNestedInput[] | LogUpdateManyWithWhereNestedInput
  >;
}

export interface LogUpdateWithWhereUniqueNestedInput {
  where: LogWhereUniqueInput;
  data: LogUpdateDataInput;
}

export interface LogUpdateDataInput {
  ip?: Maybe<String>;
  event?: Maybe<EventUpdateOneRequiredInput>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  meta?: Maybe<Json>;
}

export interface EventUpdateOneRequiredInput {
  create?: Maybe<EventCreateInput>;
  update?: Maybe<EventUpdateDataInput>;
  upsert?: Maybe<EventUpsertNestedInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface EventUpdateDataInput {
  type?: Maybe<EventType>;
  result?: Maybe<String>;
  timemark?: Maybe<DateTimeInput>;
  meta?: Maybe<Json>;
}

export interface EventUpsertNestedInput {
  update: EventUpdateDataInput;
  create: EventCreateInput;
}

export interface LogUpsertWithWhereUniqueNestedInput {
  where: LogWhereUniqueInput;
  update: LogUpdateDataInput;
  create: LogCreateInput;
}

export interface LogScalarWhereInput {
  id?: Maybe<UUID>;
  id_not?: Maybe<UUID>;
  id_in?: Maybe<UUID[] | UUID>;
  id_not_in?: Maybe<UUID[] | UUID>;
  id_lt?: Maybe<UUID>;
  id_lte?: Maybe<UUID>;
  id_gt?: Maybe<UUID>;
  id_gte?: Maybe<UUID>;
  id_contains?: Maybe<UUID>;
  id_not_contains?: Maybe<UUID>;
  id_starts_with?: Maybe<UUID>;
  id_not_starts_with?: Maybe<UUID>;
  id_ends_with?: Maybe<UUID>;
  id_not_ends_with?: Maybe<UUID>;
  ip?: Maybe<String>;
  ip_not?: Maybe<String>;
  ip_in?: Maybe<String[] | String>;
  ip_not_in?: Maybe<String[] | String>;
  ip_lt?: Maybe<String>;
  ip_lte?: Maybe<String>;
  ip_gt?: Maybe<String>;
  ip_gte?: Maybe<String>;
  ip_contains?: Maybe<String>;
  ip_not_contains?: Maybe<String>;
  ip_starts_with?: Maybe<String>;
  ip_not_starts_with?: Maybe<String>;
  ip_ends_with?: Maybe<String>;
  ip_not_ends_with?: Maybe<String>;
  AND?: Maybe<LogScalarWhereInput[] | LogScalarWhereInput>;
  OR?: Maybe<LogScalarWhereInput[] | LogScalarWhereInput>;
  NOT?: Maybe<LogScalarWhereInput[] | LogScalarWhereInput>;
}

export interface LogUpdateManyWithWhereNestedInput {
  where: LogScalarWhereInput;
  data: LogUpdateManyDataInput;
}

export interface LogUpdateManyDataInput {
  ip?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface ItemUpdateManyMutationInput {
  itemId?: Maybe<String>;
  name?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface LangCreateInput {
  id?: Maybe<UUID>;
  code: String;
  langName: String;
  i18n?: Maybe<i18nCreateManyWithoutLangInput>;
  meta?: Maybe<Json>;
}

export interface i18nCreateManyWithoutLangInput {
  create?: Maybe<i18nCreateWithoutLangInput[] | i18nCreateWithoutLangInput>;
  connect?: Maybe<i18nWhereUniqueInput[] | i18nWhereUniqueInput>;
}

export interface i18nCreateWithoutLangInput {
  id?: Maybe<UUID>;
  text?: Maybe<String>;
  i18n?: Maybe<i18nCreateManyInput>;
  meta?: Maybe<Json>;
}

export interface LangUpdateInput {
  code?: Maybe<String>;
  langName?: Maybe<String>;
  i18n?: Maybe<i18nUpdateManyWithoutLangInput>;
  meta?: Maybe<Json>;
}

export interface i18nUpdateManyWithoutLangInput {
  create?: Maybe<i18nCreateWithoutLangInput[] | i18nCreateWithoutLangInput>;
  delete?: Maybe<i18nWhereUniqueInput[] | i18nWhereUniqueInput>;
  connect?: Maybe<i18nWhereUniqueInput[] | i18nWhereUniqueInput>;
  set?: Maybe<i18nWhereUniqueInput[] | i18nWhereUniqueInput>;
  disconnect?: Maybe<i18nWhereUniqueInput[] | i18nWhereUniqueInput>;
  update?: Maybe<
    | i18nUpdateWithWhereUniqueWithoutLangInput[]
    | i18nUpdateWithWhereUniqueWithoutLangInput
  >;
  upsert?: Maybe<
    | i18nUpsertWithWhereUniqueWithoutLangInput[]
    | i18nUpsertWithWhereUniqueWithoutLangInput
  >;
  deleteMany?: Maybe<i18nScalarWhereInput[] | i18nScalarWhereInput>;
  updateMany?: Maybe<
    i18nUpdateManyWithWhereNestedInput[] | i18nUpdateManyWithWhereNestedInput
  >;
}

export interface i18nUpdateWithWhereUniqueWithoutLangInput {
  where: i18nWhereUniqueInput;
  data: i18nUpdateWithoutLangDataInput;
}

export interface i18nUpdateWithoutLangDataInput {
  text?: Maybe<String>;
  i18n?: Maybe<i18nUpdateManyInput>;
  meta?: Maybe<Json>;
}

export interface i18nUpsertWithWhereUniqueWithoutLangInput {
  where: i18nWhereUniqueInput;
  update: i18nUpdateWithoutLangDataInput;
  create: i18nCreateWithoutLangInput;
}

export interface LangUpdateManyMutationInput {
  code?: Maybe<String>;
  langName?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface LogUpdateInput {
  ip?: Maybe<String>;
  event?: Maybe<EventUpdateOneRequiredInput>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  meta?: Maybe<Json>;
}

export interface LogUpdateManyMutationInput {
  ip?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface MarkupUpdateInput {
  type?: Maybe<MarkupType>;
  start?: Maybe<Int>;
  end?: Maybe<Int>;
  href?: Maybe<String>;
  rel?: Maybe<String>;
  src?: Maybe<String>;
  title?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface MarkupUpdateManyMutationInput {
  type?: Maybe<MarkupType>;
  start?: Maybe<Int>;
  end?: Maybe<Int>;
  href?: Maybe<String>;
  rel?: Maybe<String>;
  src?: Maybe<String>;
  title?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface MeasurementUpdateInput {
  height?: Maybe<Float>;
  width?: Maybe<Float>;
}

export interface MeasurementUpdateManyMutationInput {
  height?: Maybe<Float>;
  width?: Maybe<Float>;
}

export interface NewsCreateInput {
  id?: Maybe<UUID>;
  title: String;
  published?: Maybe<Boolean>;
  validUntil: DateTimeInput;
  author: UserCreateOneInput;
  banner?: Maybe<ImageCreateManyInput>;
  meta?: Maybe<Json>;
}

export interface NewsUpdateInput {
  title?: Maybe<String>;
  published?: Maybe<Boolean>;
  validUntil?: Maybe<DateTimeInput>;
  author?: Maybe<UserUpdateOneRequiredInput>;
  banner?: Maybe<ImageUpdateManyInput>;
  meta?: Maybe<Json>;
}

export interface NewsUpdateManyMutationInput {
  title?: Maybe<String>;
  published?: Maybe<Boolean>;
  validUntil?: Maybe<DateTimeInput>;
  meta?: Maybe<Json>;
}

export interface NoteUpdateInput {
  content?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  notes?: Maybe<NoteUpdateManyInput>;
  meta?: Maybe<Json>;
}

export interface NoteUpdateManyMutationInput {
  content?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface ParagraphUpdateInput {
  index?: Maybe<Int>;
  text?: Maybe<String>;
  type?: Maybe<ParagraphType>;
  markup?: Maybe<MarkupUpdateManyInput>;
  quotes?: Maybe<QuoteUpdateManyInput>;
  replies?: Maybe<ReplyUpdateManyInput>;
  meta?: Maybe<Json>;
}

export interface ParagraphUpdateManyMutationInput {
  index?: Maybe<Int>;
  text?: Maybe<String>;
  type?: Maybe<ParagraphType>;
  meta?: Maybe<Json>;
}

export interface PermissionUpdateInput {
  type?: Maybe<String>;
  loginAdmin?: Maybe<Boolean>;
  news?: Maybe<PermissionTypeUpdateOneRequiredInput>;
  post?: Maybe<PermissionTypeUpdateOneRequiredInput>;
  reply?: Maybe<PermissionTypeUpdateOneRequiredInput>;
  item?: Maybe<PermissionTypeUpdateOneRequiredInput>;
  property?: Maybe<PermissionTypeUpdateOneRequiredInput>;
  user?: Maybe<PermissionTypeUpdateOneRequiredInput>;
  group?: Maybe<PermissionTypeUpdateOneRequiredInput>;
  layout?: Maybe<PermissionTypeUpdateOneRequiredInput>;
  log?: Maybe<PermissionTypeUpdateOneRequiredInput>;
  analytics?: Maybe<PermissionTypeUpdateOneRequiredInput>;
  meta?: Maybe<Json>;
}

export interface PermissionUpdateManyMutationInput {
  type?: Maybe<String>;
  loginAdmin?: Maybe<Boolean>;
  meta?: Maybe<Json>;
}

export interface PermissionTypeUpdateInput {
  owner?: Maybe<AccessUpdateOneRequiredInput>;
  group?: Maybe<AccessUpdateOneRequiredInput>;
  anyone?: Maybe<AccessUpdateOneRequiredInput>;
}

export interface PostCreateInput {
  id?: Maybe<UUID>;
  title: String;
  published?: Maybe<Boolean>;
  validUntil: DateTimeInput;
  author: UserCreateOneInput;
  banner?: Maybe<ImageCreateManyInput>;
  tags?: Maybe<TagCreateManyInput>;
  meta?: Maybe<Json>;
}

export interface TagCreateManyInput {
  create?: Maybe<TagCreateInput[] | TagCreateInput>;
  connect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
}

export interface TagCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface PostUpdateInput {
  title?: Maybe<String>;
  published?: Maybe<Boolean>;
  validUntil?: Maybe<DateTimeInput>;
  author?: Maybe<UserUpdateOneRequiredInput>;
  banner?: Maybe<ImageUpdateManyInput>;
  tags?: Maybe<TagUpdateManyInput>;
  meta?: Maybe<Json>;
}

export interface TagUpdateManyInput {
  create?: Maybe<TagCreateInput[] | TagCreateInput>;
  update?: Maybe<
    TagUpdateWithWhereUniqueNestedInput[] | TagUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    TagUpsertWithWhereUniqueNestedInput[] | TagUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  connect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  set?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  disconnect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  deleteMany?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  updateMany?: Maybe<
    TagUpdateManyWithWhereNestedInput[] | TagUpdateManyWithWhereNestedInput
  >;
}

export interface TagUpdateWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput;
  data: TagUpdateDataInput;
}

export interface TagUpdateDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface TagUpsertWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput;
  update: TagUpdateDataInput;
  create: TagCreateInput;
}

export interface TagScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  OR?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  NOT?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
}

export interface TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput;
  data: TagUpdateManyDataInput;
}

export interface TagUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface PostUpdateManyMutationInput {
  title?: Maybe<String>;
  published?: Maybe<Boolean>;
  validUntil?: Maybe<DateTimeInput>;
  meta?: Maybe<Json>;
}

export interface PropertyCreateInput {
  id?: Maybe<UUID>;
  propertyId: String;
  name: String;
  description?: Maybe<String>;
  i18n?: Maybe<i18nCreateManyInput>;
  logs?: Maybe<LogCreateManyInput>;
  meta?: Maybe<Json>;
}

export interface PropertyUpdateInput {
  propertyId?: Maybe<String>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  i18n?: Maybe<i18nUpdateManyInput>;
  logs?: Maybe<LogUpdateManyInput>;
  meta?: Maybe<Json>;
}

export interface PropertyUpdateManyMutationInput {
  propertyId?: Maybe<String>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface QuoteUpdateInput {
  start?: Maybe<Int>;
  end?: Maybe<Int>;
  type?: Maybe<QuoteType>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  notes?: Maybe<NoteUpdateManyInput>;
  reply?: Maybe<ReplyUpdateManyInput>;
  meta?: Maybe<Json>;
}

export interface QuoteUpdateManyMutationInput {
  start?: Maybe<Int>;
  end?: Maybe<Int>;
  type?: Maybe<QuoteType>;
  meta?: Maybe<Json>;
}

export interface ReplyUpdateInput {
  replyId?: Maybe<Int>;
  content?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredInput>;
  replies?: Maybe<ReplyUpdateManyInput>;
  meta?: Maybe<Json>;
}

export interface ReplyUpdateManyMutationInput {
  replyId?: Maybe<Int>;
  content?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface StatementCreateInput {
  id?: Maybe<UUID>;
  value: String;
  i18n?: Maybe<i18nCreateManyInput>;
  reference?: Maybe<ItemCreateOneWithoutStatementsInput>;
  meta?: Maybe<Json>;
}

export interface ItemCreateOneWithoutStatementsInput {
  create?: Maybe<ItemCreateWithoutStatementsInput>;
  connect?: Maybe<ItemWhereUniqueInput>;
}

export interface ItemCreateWithoutStatementsInput {
  id?: Maybe<UUID>;
  itemId: String;
  name: String;
  i18n?: Maybe<i18nCreateManyInput>;
  images?: Maybe<ImageCreateManyInput>;
  introduction?: Maybe<ParagraphCreateManyInput>;
  logs?: Maybe<LogCreateManyInput>;
  meta?: Maybe<Json>;
}

export interface StatementUpdateInput {
  value?: Maybe<String>;
  i18n?: Maybe<i18nUpdateManyInput>;
  reference?: Maybe<ItemUpdateOneWithoutStatementsInput>;
  meta?: Maybe<Json>;
}

export interface ItemUpdateOneWithoutStatementsInput {
  create?: Maybe<ItemCreateWithoutStatementsInput>;
  update?: Maybe<ItemUpdateWithoutStatementsDataInput>;
  upsert?: Maybe<ItemUpsertWithoutStatementsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ItemWhereUniqueInput>;
}

export interface ItemUpdateWithoutStatementsDataInput {
  itemId?: Maybe<String>;
  name?: Maybe<String>;
  i18n?: Maybe<i18nUpdateManyInput>;
  images?: Maybe<ImageUpdateManyInput>;
  introduction?: Maybe<ParagraphUpdateManyInput>;
  logs?: Maybe<LogUpdateManyInput>;
  meta?: Maybe<Json>;
}

export interface ItemUpsertWithoutStatementsInput {
  update: ItemUpdateWithoutStatementsDataInput;
  create: ItemCreateWithoutStatementsInput;
}

export interface StatementUpdateManyMutationInput {
  value?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface TagUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface TagUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface ThemeCreateInput {
  id?: Maybe<UUID>;
  name: String;
  description?: Maybe<String>;
  component?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface ThemeUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  component?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface ThemeUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  component?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface UserUpdateInput {
  userName?: Maybe<String>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  description?: Maybe<String>;
  avatar?: Maybe<ImageUpdateOneInput>;
  group?: Maybe<GroupUpdateOneInput>;
  meta?: Maybe<Json>;
}

export interface UserUpdateManyMutationInput {
  userName?: Maybe<String>;
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  description?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface i18nUpdateInput {
  text?: Maybe<String>;
  lang?: Maybe<LangUpdateOneRequiredWithoutI18nInput>;
  i18n?: Maybe<i18nUpdateManyInput>;
  meta?: Maybe<Json>;
}

export interface i18nUpdateManyMutationInput {
  text?: Maybe<String>;
  meta?: Maybe<Json>;
}

export interface AccessSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AccessWhereInput>;
  AND?: Maybe<AccessSubscriptionWhereInput[] | AccessSubscriptionWhereInput>;
  OR?: Maybe<AccessSubscriptionWhereInput[] | AccessSubscriptionWhereInput>;
  NOT?: Maybe<AccessSubscriptionWhereInput[] | AccessSubscriptionWhereInput>;
}

export interface EventSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EventWhereInput>;
  AND?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
  OR?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
  NOT?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
}

export interface FileSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FileWhereInput>;
  AND?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
  OR?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
  NOT?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
}

export interface GroupSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GroupWhereInput>;
  AND?: Maybe<GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput>;
  OR?: Maybe<GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput>;
  NOT?: Maybe<GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput>;
}

export interface ImageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ImageWhereInput>;
  AND?: Maybe<ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput>;
  OR?: Maybe<ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput>;
  NOT?: Maybe<ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput>;
}

export interface ItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ItemWhereInput>;
  AND?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
  OR?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
  NOT?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
}

export interface LangSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LangWhereInput>;
  AND?: Maybe<LangSubscriptionWhereInput[] | LangSubscriptionWhereInput>;
  OR?: Maybe<LangSubscriptionWhereInput[] | LangSubscriptionWhereInput>;
  NOT?: Maybe<LangSubscriptionWhereInput[] | LangSubscriptionWhereInput>;
}

export interface LogSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LogWhereInput>;
  AND?: Maybe<LogSubscriptionWhereInput[] | LogSubscriptionWhereInput>;
  OR?: Maybe<LogSubscriptionWhereInput[] | LogSubscriptionWhereInput>;
  NOT?: Maybe<LogSubscriptionWhereInput[] | LogSubscriptionWhereInput>;
}

export interface MarkupSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MarkupWhereInput>;
  AND?: Maybe<MarkupSubscriptionWhereInput[] | MarkupSubscriptionWhereInput>;
  OR?: Maybe<MarkupSubscriptionWhereInput[] | MarkupSubscriptionWhereInput>;
  NOT?: Maybe<MarkupSubscriptionWhereInput[] | MarkupSubscriptionWhereInput>;
}

export interface MeasurementSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MeasurementWhereInput>;
  AND?: Maybe<
    MeasurementSubscriptionWhereInput[] | MeasurementSubscriptionWhereInput
  >;
  OR?: Maybe<
    MeasurementSubscriptionWhereInput[] | MeasurementSubscriptionWhereInput
  >;
  NOT?: Maybe<
    MeasurementSubscriptionWhereInput[] | MeasurementSubscriptionWhereInput
  >;
}

export interface NewsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NewsWhereInput>;
  AND?: Maybe<NewsSubscriptionWhereInput[] | NewsSubscriptionWhereInput>;
  OR?: Maybe<NewsSubscriptionWhereInput[] | NewsSubscriptionWhereInput>;
  NOT?: Maybe<NewsSubscriptionWhereInput[] | NewsSubscriptionWhereInput>;
}

export interface NoteSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NoteWhereInput>;
  AND?: Maybe<NoteSubscriptionWhereInput[] | NoteSubscriptionWhereInput>;
  OR?: Maybe<NoteSubscriptionWhereInput[] | NoteSubscriptionWhereInput>;
  NOT?: Maybe<NoteSubscriptionWhereInput[] | NoteSubscriptionWhereInput>;
}

export interface ParagraphSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ParagraphWhereInput>;
  AND?: Maybe<
    ParagraphSubscriptionWhereInput[] | ParagraphSubscriptionWhereInput
  >;
  OR?: Maybe<
    ParagraphSubscriptionWhereInput[] | ParagraphSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ParagraphSubscriptionWhereInput[] | ParagraphSubscriptionWhereInput
  >;
}

export interface PermissionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PermissionWhereInput>;
  AND?: Maybe<
    PermissionSubscriptionWhereInput[] | PermissionSubscriptionWhereInput
  >;
  OR?: Maybe<
    PermissionSubscriptionWhereInput[] | PermissionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    PermissionSubscriptionWhereInput[] | PermissionSubscriptionWhereInput
  >;
}

export interface PermissionTypeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PermissionTypeWhereInput>;
  AND?: Maybe<
    | PermissionTypeSubscriptionWhereInput[]
    | PermissionTypeSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PermissionTypeSubscriptionWhereInput[]
    | PermissionTypeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PermissionTypeSubscriptionWhereInput[]
    | PermissionTypeSubscriptionWhereInput
  >;
}

export interface PostSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PostWhereInput>;
  AND?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
  OR?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
  NOT?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
}

export interface PropertySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PropertyWhereInput>;
  AND?: Maybe<
    PropertySubscriptionWhereInput[] | PropertySubscriptionWhereInput
  >;
  OR?: Maybe<PropertySubscriptionWhereInput[] | PropertySubscriptionWhereInput>;
  NOT?: Maybe<
    PropertySubscriptionWhereInput[] | PropertySubscriptionWhereInput
  >;
}

export interface QuoteSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QuoteWhereInput>;
  AND?: Maybe<QuoteSubscriptionWhereInput[] | QuoteSubscriptionWhereInput>;
  OR?: Maybe<QuoteSubscriptionWhereInput[] | QuoteSubscriptionWhereInput>;
  NOT?: Maybe<QuoteSubscriptionWhereInput[] | QuoteSubscriptionWhereInput>;
}

export interface ReplySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ReplyWhereInput>;
  AND?: Maybe<ReplySubscriptionWhereInput[] | ReplySubscriptionWhereInput>;
  OR?: Maybe<ReplySubscriptionWhereInput[] | ReplySubscriptionWhereInput>;
  NOT?: Maybe<ReplySubscriptionWhereInput[] | ReplySubscriptionWhereInput>;
}

export interface StatementSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StatementWhereInput>;
  AND?: Maybe<
    StatementSubscriptionWhereInput[] | StatementSubscriptionWhereInput
  >;
  OR?: Maybe<
    StatementSubscriptionWhereInput[] | StatementSubscriptionWhereInput
  >;
  NOT?: Maybe<
    StatementSubscriptionWhereInput[] | StatementSubscriptionWhereInput
  >;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TagWhereInput>;
  AND?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
  OR?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
  NOT?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
}

export interface ThemeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ThemeWhereInput>;
  AND?: Maybe<ThemeSubscriptionWhereInput[] | ThemeSubscriptionWhereInput>;
  OR?: Maybe<ThemeSubscriptionWhereInput[] | ThemeSubscriptionWhereInput>;
  NOT?: Maybe<ThemeSubscriptionWhereInput[] | ThemeSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface i18nSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<i18nWhereInput>;
  AND?: Maybe<i18nSubscriptionWhereInput[] | i18nSubscriptionWhereInput>;
  OR?: Maybe<i18nSubscriptionWhereInput[] | i18nSubscriptionWhereInput>;
  NOT?: Maybe<i18nSubscriptionWhereInput[] | i18nSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Access {
  id: UUID;
  read: Boolean;
  write: Boolean;
  delete: Boolean;
}

export interface AccessPromise extends Promise<Access>, Fragmentable {
  id: () => Promise<UUID>;
  read: () => Promise<Boolean>;
  write: () => Promise<Boolean>;
  delete: () => Promise<Boolean>;
}

export interface AccessSubscription
  extends Promise<AsyncIterator<Access>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  read: () => Promise<AsyncIterator<Boolean>>;
  write: () => Promise<AsyncIterator<Boolean>>;
  delete: () => Promise<AsyncIterator<Boolean>>;
}

export interface AccessNullablePromise
  extends Promise<Access | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  read: () => Promise<Boolean>;
  write: () => Promise<Boolean>;
  delete: () => Promise<Boolean>;
}

export interface AccessConnection {
  pageInfo: PageInfo;
  edges: AccessEdge[];
}

export interface AccessConnectionPromise
  extends Promise<AccessConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AccessEdge>>() => T;
  aggregate: <T = AggregateAccessPromise>() => T;
}

export interface AccessConnectionSubscription
  extends Promise<AsyncIterator<AccessConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AccessEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAccessSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AccessEdge {
  node: Access;
  cursor: String;
}

export interface AccessEdgePromise extends Promise<AccessEdge>, Fragmentable {
  node: <T = AccessPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AccessEdgeSubscription
  extends Promise<AsyncIterator<AccessEdge>>,
    Fragmentable {
  node: <T = AccessSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAccess {
  count: Int;
}

export interface AggregateAccessPromise
  extends Promise<AggregateAccess>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAccessSubscription
  extends Promise<AsyncIterator<AggregateAccess>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Event {
  id: UUID;
  type: EventType;
  result?: String;
  timemark: DateTimeOutput;
  meta?: Json;
}

export interface EventPromise extends Promise<Event>, Fragmentable {
  id: () => Promise<UUID>;
  type: () => Promise<EventType>;
  result: () => Promise<String>;
  timemark: () => Promise<DateTimeOutput>;
  meta: () => Promise<Json>;
}

export interface EventSubscription
  extends Promise<AsyncIterator<Event>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  type: () => Promise<AsyncIterator<EventType>>;
  result: () => Promise<AsyncIterator<String>>;
  timemark: () => Promise<AsyncIterator<DateTimeOutput>>;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface EventNullablePromise
  extends Promise<Event | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  type: () => Promise<EventType>;
  result: () => Promise<String>;
  timemark: () => Promise<DateTimeOutput>;
  meta: () => Promise<Json>;
}

export interface EventConnection {
  pageInfo: PageInfo;
  edges: EventEdge[];
}

export interface EventConnectionPromise
  extends Promise<EventConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EventEdge>>() => T;
  aggregate: <T = AggregateEventPromise>() => T;
}

export interface EventConnectionSubscription
  extends Promise<AsyncIterator<EventConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EventEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEventSubscription>() => T;
}

export interface EventEdge {
  node: Event;
  cursor: String;
}

export interface EventEdgePromise extends Promise<EventEdge>, Fragmentable {
  node: <T = EventPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EventEdgeSubscription
  extends Promise<AsyncIterator<EventEdge>>,
    Fragmentable {
  node: <T = EventSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEvent {
  count: Int;
}

export interface AggregateEventPromise
  extends Promise<AggregateEvent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEventSubscription
  extends Promise<AsyncIterator<AggregateEvent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface File {
  id: UUID;
  name: String;
  path: String;
  size: Float;
  hidden: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  meta?: Json;
}

export interface FilePromise extends Promise<File>, Fragmentable {
  id: () => Promise<UUID>;
  name: () => Promise<String>;
  path: () => Promise<String>;
  size: () => Promise<Float>;
  hidden: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  uploadBy: <T = UserPromise>() => T;
  meta: () => Promise<Json>;
}

export interface FileSubscription
  extends Promise<AsyncIterator<File>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  name: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Float>>;
  hidden: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  uploadBy: <T = UserSubscription>() => T;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface FileNullablePromise
  extends Promise<File | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  name: () => Promise<String>;
  path: () => Promise<String>;
  size: () => Promise<Float>;
  hidden: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  uploadBy: <T = UserPromise>() => T;
  meta: () => Promise<Json>;
}

export interface User {
  id: UUID;
  userName: String;
  email: String;
  firstName?: String;
  lastName?: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  meta?: Json;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<UUID>;
  userName: () => Promise<String>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  avatar: <T = ImagePromise>() => T;
  group: <T = GroupPromise>() => T;
  meta: () => Promise<Json>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  userName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  avatar: <T = ImageSubscription>() => T;
  group: <T = GroupSubscription>() => T;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  userName: () => Promise<String>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  avatar: <T = ImagePromise>() => T;
  group: <T = GroupPromise>() => T;
  meta: () => Promise<Json>;
}

export interface Image {
  id: UUID;
  name: String;
  description?: String;
  meta?: Json;
}

export interface ImagePromise extends Promise<Image>, Fragmentable {
  id: () => Promise<UUID>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  format: <T = MeasurementPromise>() => T;
  file: <T = FilePromise>() => T;
  meta: () => Promise<Json>;
}

export interface ImageSubscription
  extends Promise<AsyncIterator<Image>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  format: <T = MeasurementSubscription>() => T;
  file: <T = FileSubscription>() => T;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface ImageNullablePromise
  extends Promise<Image | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  format: <T = MeasurementPromise>() => T;
  file: <T = FilePromise>() => T;
  meta: () => Promise<Json>;
}

export interface Measurement {
  id: UUID;
  height: Float;
  width: Float;
}

export interface MeasurementPromise extends Promise<Measurement>, Fragmentable {
  id: () => Promise<UUID>;
  height: () => Promise<Float>;
  width: () => Promise<Float>;
}

export interface MeasurementSubscription
  extends Promise<AsyncIterator<Measurement>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  height: () => Promise<AsyncIterator<Float>>;
  width: () => Promise<AsyncIterator<Float>>;
}

export interface MeasurementNullablePromise
  extends Promise<Measurement | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  height: () => Promise<Float>;
  width: () => Promise<Float>;
}

export interface Group {
  id: UUID;
  name: String;
  description?: String;
  meta?: Json;
}

export interface GroupPromise extends Promise<Group>, Fragmentable {
  id: () => Promise<UUID>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  permission: <T = PermissionPromise>() => T;
  meta: () => Promise<Json>;
}

export interface GroupSubscription
  extends Promise<AsyncIterator<Group>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  permission: <T = PermissionSubscription>() => T;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface GroupNullablePromise
  extends Promise<Group | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  permission: <T = PermissionPromise>() => T;
  meta: () => Promise<Json>;
}

export interface Permission {
  id: UUID;
  type: String;
  loginAdmin: Boolean;
  meta?: Json;
}

export interface PermissionPromise extends Promise<Permission>, Fragmentable {
  id: () => Promise<UUID>;
  type: () => Promise<String>;
  loginAdmin: () => Promise<Boolean>;
  news: <T = PermissionTypePromise>() => T;
  post: <T = PermissionTypePromise>() => T;
  reply: <T = PermissionTypePromise>() => T;
  item: <T = PermissionTypePromise>() => T;
  property: <T = PermissionTypePromise>() => T;
  user: <T = PermissionTypePromise>() => T;
  group: <T = PermissionTypePromise>() => T;
  layout: <T = PermissionTypePromise>() => T;
  log: <T = PermissionTypePromise>() => T;
  analytics: <T = PermissionTypePromise>() => T;
  meta: () => Promise<Json>;
}

export interface PermissionSubscription
  extends Promise<AsyncIterator<Permission>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  type: () => Promise<AsyncIterator<String>>;
  loginAdmin: () => Promise<AsyncIterator<Boolean>>;
  news: <T = PermissionTypeSubscription>() => T;
  post: <T = PermissionTypeSubscription>() => T;
  reply: <T = PermissionTypeSubscription>() => T;
  item: <T = PermissionTypeSubscription>() => T;
  property: <T = PermissionTypeSubscription>() => T;
  user: <T = PermissionTypeSubscription>() => T;
  group: <T = PermissionTypeSubscription>() => T;
  layout: <T = PermissionTypeSubscription>() => T;
  log: <T = PermissionTypeSubscription>() => T;
  analytics: <T = PermissionTypeSubscription>() => T;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface PermissionNullablePromise
  extends Promise<Permission | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  type: () => Promise<String>;
  loginAdmin: () => Promise<Boolean>;
  news: <T = PermissionTypePromise>() => T;
  post: <T = PermissionTypePromise>() => T;
  reply: <T = PermissionTypePromise>() => T;
  item: <T = PermissionTypePromise>() => T;
  property: <T = PermissionTypePromise>() => T;
  user: <T = PermissionTypePromise>() => T;
  group: <T = PermissionTypePromise>() => T;
  layout: <T = PermissionTypePromise>() => T;
  log: <T = PermissionTypePromise>() => T;
  analytics: <T = PermissionTypePromise>() => T;
  meta: () => Promise<Json>;
}

export interface PermissionType {
  id: UUID;
}

export interface PermissionTypePromise
  extends Promise<PermissionType>,
    Fragmentable {
  id: () => Promise<UUID>;
  owner: <T = AccessPromise>() => T;
  group: <T = AccessPromise>() => T;
  anyone: <T = AccessPromise>() => T;
}

export interface PermissionTypeSubscription
  extends Promise<AsyncIterator<PermissionType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  owner: <T = AccessSubscription>() => T;
  group: <T = AccessSubscription>() => T;
  anyone: <T = AccessSubscription>() => T;
}

export interface PermissionTypeNullablePromise
  extends Promise<PermissionType | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  owner: <T = AccessPromise>() => T;
  group: <T = AccessPromise>() => T;
  anyone: <T = AccessPromise>() => T;
}

export interface FileConnection {
  pageInfo: PageInfo;
  edges: FileEdge[];
}

export interface FileConnectionPromise
  extends Promise<FileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FileEdge>>() => T;
  aggregate: <T = AggregateFilePromise>() => T;
}

export interface FileConnectionSubscription
  extends Promise<AsyncIterator<FileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFileSubscription>() => T;
}

export interface FileEdge {
  node: File;
  cursor: String;
}

export interface FileEdgePromise extends Promise<FileEdge>, Fragmentable {
  node: <T = FilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FileEdgeSubscription
  extends Promise<AsyncIterator<FileEdge>>,
    Fragmentable {
  node: <T = FileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFile {
  count: Int;
}

export interface AggregateFilePromise
  extends Promise<AggregateFile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFileSubscription
  extends Promise<AsyncIterator<AggregateFile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GroupConnection {
  pageInfo: PageInfo;
  edges: GroupEdge[];
}

export interface GroupConnectionPromise
  extends Promise<GroupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GroupEdge>>() => T;
  aggregate: <T = AggregateGroupPromise>() => T;
}

export interface GroupConnectionSubscription
  extends Promise<AsyncIterator<GroupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GroupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGroupSubscription>() => T;
}

export interface GroupEdge {
  node: Group;
  cursor: String;
}

export interface GroupEdgePromise extends Promise<GroupEdge>, Fragmentable {
  node: <T = GroupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GroupEdgeSubscription
  extends Promise<AsyncIterator<GroupEdge>>,
    Fragmentable {
  node: <T = GroupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGroup {
  count: Int;
}

export interface AggregateGroupPromise
  extends Promise<AggregateGroup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGroupSubscription
  extends Promise<AsyncIterator<AggregateGroup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ImageConnection {
  pageInfo: PageInfo;
  edges: ImageEdge[];
}

export interface ImageConnectionPromise
  extends Promise<ImageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ImageEdge>>() => T;
  aggregate: <T = AggregateImagePromise>() => T;
}

export interface ImageConnectionSubscription
  extends Promise<AsyncIterator<ImageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ImageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateImageSubscription>() => T;
}

export interface ImageEdge {
  node: Image;
  cursor: String;
}

export interface ImageEdgePromise extends Promise<ImageEdge>, Fragmentable {
  node: <T = ImagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ImageEdgeSubscription
  extends Promise<AsyncIterator<ImageEdge>>,
    Fragmentable {
  node: <T = ImageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateImage {
  count: Int;
}

export interface AggregateImagePromise
  extends Promise<AggregateImage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateImageSubscription
  extends Promise<AsyncIterator<AggregateImage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Item {
  id: UUID;
  itemId: String;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  meta?: Json;
}

export interface ItemPromise extends Promise<Item>, Fragmentable {
  id: () => Promise<UUID>;
  itemId: () => Promise<String>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  i18n: <T = FragmentableArray<i18n>>(args?: {
    where?: i18nWhereInput;
    orderBy?: i18nOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  images: <T = FragmentableArray<Image>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  statements: <T = FragmentableArray<Statement>>(args?: {
    where?: StatementWhereInput;
    orderBy?: StatementOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  introduction: <T = FragmentableArray<Paragraph>>(args?: {
    where?: ParagraphWhereInput;
    orderBy?: ParagraphOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  logs: <T = FragmentableArray<Log>>(args?: {
    where?: LogWhereInput;
    orderBy?: LogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<Json>;
}

export interface ItemSubscription
  extends Promise<AsyncIterator<Item>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  itemId: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  i18n: <T = Promise<AsyncIterator<i18nSubscription>>>(args?: {
    where?: i18nWhereInput;
    orderBy?: i18nOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  images: <T = Promise<AsyncIterator<ImageSubscription>>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  statements: <T = Promise<AsyncIterator<StatementSubscription>>>(args?: {
    where?: StatementWhereInput;
    orderBy?: StatementOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  introduction: <T = Promise<AsyncIterator<ParagraphSubscription>>>(args?: {
    where?: ParagraphWhereInput;
    orderBy?: ParagraphOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  logs: <T = Promise<AsyncIterator<LogSubscription>>>(args?: {
    where?: LogWhereInput;
    orderBy?: LogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface ItemNullablePromise
  extends Promise<Item | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  itemId: () => Promise<String>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  i18n: <T = FragmentableArray<i18n>>(args?: {
    where?: i18nWhereInput;
    orderBy?: i18nOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  images: <T = FragmentableArray<Image>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  statements: <T = FragmentableArray<Statement>>(args?: {
    where?: StatementWhereInput;
    orderBy?: StatementOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  introduction: <T = FragmentableArray<Paragraph>>(args?: {
    where?: ParagraphWhereInput;
    orderBy?: ParagraphOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  logs: <T = FragmentableArray<Log>>(args?: {
    where?: LogWhereInput;
    orderBy?: LogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<Json>;
}

export interface i18n {
  id: UUID;
  text?: String;
  meta?: Json;
}

export interface i18nPromise extends Promise<i18n>, Fragmentable {
  id: () => Promise<UUID>;
  text: () => Promise<String>;
  lang: <T = LangPromise>() => T;
  i18n: <T = FragmentableArray<i18n>>(args?: {
    where?: i18nWhereInput;
    orderBy?: i18nOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<Json>;
}

export interface i18nSubscription
  extends Promise<AsyncIterator<i18n>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  text: () => Promise<AsyncIterator<String>>;
  lang: <T = LangSubscription>() => T;
  i18n: <T = Promise<AsyncIterator<i18nSubscription>>>(args?: {
    where?: i18nWhereInput;
    orderBy?: i18nOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface i18nNullablePromise
  extends Promise<i18n | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  text: () => Promise<String>;
  lang: <T = LangPromise>() => T;
  i18n: <T = FragmentableArray<i18n>>(args?: {
    where?: i18nWhereInput;
    orderBy?: i18nOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<Json>;
}

export interface Lang {
  id: UUID;
  code: String;
  langName: String;
  meta?: Json;
}

export interface LangPromise extends Promise<Lang>, Fragmentable {
  id: () => Promise<UUID>;
  code: () => Promise<String>;
  langName: () => Promise<String>;
  i18n: <T = FragmentableArray<i18n>>(args?: {
    where?: i18nWhereInput;
    orderBy?: i18nOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<Json>;
}

export interface LangSubscription
  extends Promise<AsyncIterator<Lang>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  code: () => Promise<AsyncIterator<String>>;
  langName: () => Promise<AsyncIterator<String>>;
  i18n: <T = Promise<AsyncIterator<i18nSubscription>>>(args?: {
    where?: i18nWhereInput;
    orderBy?: i18nOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface LangNullablePromise
  extends Promise<Lang | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  code: () => Promise<String>;
  langName: () => Promise<String>;
  i18n: <T = FragmentableArray<i18n>>(args?: {
    where?: i18nWhereInput;
    orderBy?: i18nOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<Json>;
}

export interface Statement {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  value: String;
  meta?: Json;
}

export interface StatementPromise extends Promise<Statement>, Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  value: () => Promise<String>;
  i18n: <T = FragmentableArray<i18n>>(args?: {
    where?: i18nWhereInput;
    orderBy?: i18nOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reference: <T = ItemPromise>() => T;
  meta: () => Promise<Json>;
}

export interface StatementSubscription
  extends Promise<AsyncIterator<Statement>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  value: () => Promise<AsyncIterator<String>>;
  i18n: <T = Promise<AsyncIterator<i18nSubscription>>>(args?: {
    where?: i18nWhereInput;
    orderBy?: i18nOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reference: <T = ItemSubscription>() => T;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface StatementNullablePromise
  extends Promise<Statement | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  value: () => Promise<String>;
  i18n: <T = FragmentableArray<i18n>>(args?: {
    where?: i18nWhereInput;
    orderBy?: i18nOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reference: <T = ItemPromise>() => T;
  meta: () => Promise<Json>;
}

export interface Paragraph {
  id: UUID;
  index: Int;
  text?: String;
  type?: ParagraphType;
  meta?: Json;
}

export interface ParagraphPromise extends Promise<Paragraph>, Fragmentable {
  id: () => Promise<UUID>;
  index: () => Promise<Int>;
  text: () => Promise<String>;
  type: () => Promise<ParagraphType>;
  markup: <T = FragmentableArray<Markup>>(args?: {
    where?: MarkupWhereInput;
    orderBy?: MarkupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  quotes: <T = FragmentableArray<Quote>>(args?: {
    where?: QuoteWhereInput;
    orderBy?: QuoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  replies: <T = FragmentableArray<Reply>>(args?: {
    where?: ReplyWhereInput;
    orderBy?: ReplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<Json>;
}

export interface ParagraphSubscription
  extends Promise<AsyncIterator<Paragraph>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  index: () => Promise<AsyncIterator<Int>>;
  text: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<ParagraphType>>;
  markup: <T = Promise<AsyncIterator<MarkupSubscription>>>(args?: {
    where?: MarkupWhereInput;
    orderBy?: MarkupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  quotes: <T = Promise<AsyncIterator<QuoteSubscription>>>(args?: {
    where?: QuoteWhereInput;
    orderBy?: QuoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  replies: <T = Promise<AsyncIterator<ReplySubscription>>>(args?: {
    where?: ReplyWhereInput;
    orderBy?: ReplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface ParagraphNullablePromise
  extends Promise<Paragraph | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  index: () => Promise<Int>;
  text: () => Promise<String>;
  type: () => Promise<ParagraphType>;
  markup: <T = FragmentableArray<Markup>>(args?: {
    where?: MarkupWhereInput;
    orderBy?: MarkupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  quotes: <T = FragmentableArray<Quote>>(args?: {
    where?: QuoteWhereInput;
    orderBy?: QuoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  replies: <T = FragmentableArray<Reply>>(args?: {
    where?: ReplyWhereInput;
    orderBy?: ReplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<Json>;
}

export interface Markup {
  id: UUID;
  type: MarkupType;
  start?: Int;
  end?: Int;
  href?: String;
  rel?: String;
  src?: String;
  title?: String;
  meta?: Json;
}

export interface MarkupPromise extends Promise<Markup>, Fragmentable {
  id: () => Promise<UUID>;
  type: () => Promise<MarkupType>;
  start: () => Promise<Int>;
  end: () => Promise<Int>;
  href: () => Promise<String>;
  rel: () => Promise<String>;
  src: () => Promise<String>;
  title: () => Promise<String>;
  meta: () => Promise<Json>;
}

export interface MarkupSubscription
  extends Promise<AsyncIterator<Markup>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  type: () => Promise<AsyncIterator<MarkupType>>;
  start: () => Promise<AsyncIterator<Int>>;
  end: () => Promise<AsyncIterator<Int>>;
  href: () => Promise<AsyncIterator<String>>;
  rel: () => Promise<AsyncIterator<String>>;
  src: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface MarkupNullablePromise
  extends Promise<Markup | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  type: () => Promise<MarkupType>;
  start: () => Promise<Int>;
  end: () => Promise<Int>;
  href: () => Promise<String>;
  rel: () => Promise<String>;
  src: () => Promise<String>;
  title: () => Promise<String>;
  meta: () => Promise<Json>;
}

export interface Quote {
  id: UUID;
  start: Int;
  end: Int;
  type: QuoteType;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  meta?: Json;
}

export interface QuotePromise extends Promise<Quote>, Fragmentable {
  id: () => Promise<UUID>;
  start: () => Promise<Int>;
  end: () => Promise<Int>;
  type: () => Promise<QuoteType>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  notes: <T = FragmentableArray<Note>>(args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reply: <T = FragmentableArray<Reply>>(args?: {
    where?: ReplyWhereInput;
    orderBy?: ReplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<Json>;
}

export interface QuoteSubscription
  extends Promise<AsyncIterator<Quote>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  start: () => Promise<AsyncIterator<Int>>;
  end: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<QuoteType>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  notes: <T = Promise<AsyncIterator<NoteSubscription>>>(args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reply: <T = Promise<AsyncIterator<ReplySubscription>>>(args?: {
    where?: ReplyWhereInput;
    orderBy?: ReplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface QuoteNullablePromise
  extends Promise<Quote | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  start: () => Promise<Int>;
  end: () => Promise<Int>;
  type: () => Promise<QuoteType>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  notes: <T = FragmentableArray<Note>>(args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reply: <T = FragmentableArray<Reply>>(args?: {
    where?: ReplyWhereInput;
    orderBy?: ReplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<Json>;
}

export interface Note {
  id: UUID;
  content?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  meta?: Json;
}

export interface NotePromise extends Promise<Note>, Fragmentable {
  id: () => Promise<UUID>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  notes: <T = FragmentableArray<Note>>(args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<Json>;
}

export interface NoteSubscription
  extends Promise<AsyncIterator<Note>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  notes: <T = Promise<AsyncIterator<NoteSubscription>>>(args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface NoteNullablePromise
  extends Promise<Note | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  notes: <T = FragmentableArray<Note>>(args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<Json>;
}

export interface Reply {
  id: UUID;
  replyId: Int;
  content: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  meta?: Json;
}

export interface ReplyPromise extends Promise<Reply>, Fragmentable {
  id: () => Promise<UUID>;
  replyId: () => Promise<Int>;
  content: () => Promise<String>;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  replies: <T = FragmentableArray<Reply>>(args?: {
    where?: ReplyWhereInput;
    orderBy?: ReplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<Json>;
}

export interface ReplySubscription
  extends Promise<AsyncIterator<Reply>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  replyId: () => Promise<AsyncIterator<Int>>;
  content: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  replies: <T = Promise<AsyncIterator<ReplySubscription>>>(args?: {
    where?: ReplyWhereInput;
    orderBy?: ReplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface ReplyNullablePromise
  extends Promise<Reply | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  replyId: () => Promise<Int>;
  content: () => Promise<String>;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  replies: <T = FragmentableArray<Reply>>(args?: {
    where?: ReplyWhereInput;
    orderBy?: ReplyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<Json>;
}

export interface Log {
  id: UUID;
  ip: String;
  meta?: Json;
}

export interface LogPromise extends Promise<Log>, Fragmentable {
  id: () => Promise<UUID>;
  ip: () => Promise<String>;
  event: <T = EventPromise>() => T;
  user: <T = UserPromise>() => T;
  meta: () => Promise<Json>;
}

export interface LogSubscription
  extends Promise<AsyncIterator<Log>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  ip: () => Promise<AsyncIterator<String>>;
  event: <T = EventSubscription>() => T;
  user: <T = UserSubscription>() => T;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface LogNullablePromise extends Promise<Log | null>, Fragmentable {
  id: () => Promise<UUID>;
  ip: () => Promise<String>;
  event: <T = EventPromise>() => T;
  user: <T = UserPromise>() => T;
  meta: () => Promise<Json>;
}

export interface ItemConnection {
  pageInfo: PageInfo;
  edges: ItemEdge[];
}

export interface ItemConnectionPromise
  extends Promise<ItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ItemEdge>>() => T;
  aggregate: <T = AggregateItemPromise>() => T;
}

export interface ItemConnectionSubscription
  extends Promise<AsyncIterator<ItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateItemSubscription>() => T;
}

export interface ItemEdge {
  node: Item;
  cursor: String;
}

export interface ItemEdgePromise extends Promise<ItemEdge>, Fragmentable {
  node: <T = ItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ItemEdgeSubscription
  extends Promise<AsyncIterator<ItemEdge>>,
    Fragmentable {
  node: <T = ItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateItem {
  count: Int;
}

export interface AggregateItemPromise
  extends Promise<AggregateItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateItemSubscription
  extends Promise<AsyncIterator<AggregateItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LangConnection {
  pageInfo: PageInfo;
  edges: LangEdge[];
}

export interface LangConnectionPromise
  extends Promise<LangConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LangEdge>>() => T;
  aggregate: <T = AggregateLangPromise>() => T;
}

export interface LangConnectionSubscription
  extends Promise<AsyncIterator<LangConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LangEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLangSubscription>() => T;
}

export interface LangEdge {
  node: Lang;
  cursor: String;
}

export interface LangEdgePromise extends Promise<LangEdge>, Fragmentable {
  node: <T = LangPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LangEdgeSubscription
  extends Promise<AsyncIterator<LangEdge>>,
    Fragmentable {
  node: <T = LangSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLang {
  count: Int;
}

export interface AggregateLangPromise
  extends Promise<AggregateLang>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLangSubscription
  extends Promise<AsyncIterator<AggregateLang>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LogConnection {
  pageInfo: PageInfo;
  edges: LogEdge[];
}

export interface LogConnectionPromise
  extends Promise<LogConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LogEdge>>() => T;
  aggregate: <T = AggregateLogPromise>() => T;
}

export interface LogConnectionSubscription
  extends Promise<AsyncIterator<LogConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LogEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLogSubscription>() => T;
}

export interface LogEdge {
  node: Log;
  cursor: String;
}

export interface LogEdgePromise extends Promise<LogEdge>, Fragmentable {
  node: <T = LogPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LogEdgeSubscription
  extends Promise<AsyncIterator<LogEdge>>,
    Fragmentable {
  node: <T = LogSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLog {
  count: Int;
}

export interface AggregateLogPromise
  extends Promise<AggregateLog>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLogSubscription
  extends Promise<AsyncIterator<AggregateLog>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MarkupConnection {
  pageInfo: PageInfo;
  edges: MarkupEdge[];
}

export interface MarkupConnectionPromise
  extends Promise<MarkupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MarkupEdge>>() => T;
  aggregate: <T = AggregateMarkupPromise>() => T;
}

export interface MarkupConnectionSubscription
  extends Promise<AsyncIterator<MarkupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MarkupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMarkupSubscription>() => T;
}

export interface MarkupEdge {
  node: Markup;
  cursor: String;
}

export interface MarkupEdgePromise extends Promise<MarkupEdge>, Fragmentable {
  node: <T = MarkupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MarkupEdgeSubscription
  extends Promise<AsyncIterator<MarkupEdge>>,
    Fragmentable {
  node: <T = MarkupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMarkup {
  count: Int;
}

export interface AggregateMarkupPromise
  extends Promise<AggregateMarkup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMarkupSubscription
  extends Promise<AsyncIterator<AggregateMarkup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MeasurementConnection {
  pageInfo: PageInfo;
  edges: MeasurementEdge[];
}

export interface MeasurementConnectionPromise
  extends Promise<MeasurementConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MeasurementEdge>>() => T;
  aggregate: <T = AggregateMeasurementPromise>() => T;
}

export interface MeasurementConnectionSubscription
  extends Promise<AsyncIterator<MeasurementConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MeasurementEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMeasurementSubscription>() => T;
}

export interface MeasurementEdge {
  node: Measurement;
  cursor: String;
}

export interface MeasurementEdgePromise
  extends Promise<MeasurementEdge>,
    Fragmentable {
  node: <T = MeasurementPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MeasurementEdgeSubscription
  extends Promise<AsyncIterator<MeasurementEdge>>,
    Fragmentable {
  node: <T = MeasurementSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMeasurement {
  count: Int;
}

export interface AggregateMeasurementPromise
  extends Promise<AggregateMeasurement>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMeasurementSubscription
  extends Promise<AsyncIterator<AggregateMeasurement>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface News {
  id: UUID;
  title: String;
  published: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  validUntil: DateTimeOutput;
  meta?: Json;
}

export interface NewsPromise extends Promise<News>, Fragmentable {
  id: () => Promise<UUID>;
  title: () => Promise<String>;
  published: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  validUntil: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
  banner: <T = FragmentableArray<Image>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<Json>;
}

export interface NewsSubscription
  extends Promise<AsyncIterator<News>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  title: () => Promise<AsyncIterator<String>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  validUntil: () => Promise<AsyncIterator<DateTimeOutput>>;
  author: <T = UserSubscription>() => T;
  banner: <T = Promise<AsyncIterator<ImageSubscription>>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface NewsNullablePromise
  extends Promise<News | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  title: () => Promise<String>;
  published: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  validUntil: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
  banner: <T = FragmentableArray<Image>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<Json>;
}

export interface NewsConnection {
  pageInfo: PageInfo;
  edges: NewsEdge[];
}

export interface NewsConnectionPromise
  extends Promise<NewsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NewsEdge>>() => T;
  aggregate: <T = AggregateNewsPromise>() => T;
}

export interface NewsConnectionSubscription
  extends Promise<AsyncIterator<NewsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NewsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNewsSubscription>() => T;
}

export interface NewsEdge {
  node: News;
  cursor: String;
}

export interface NewsEdgePromise extends Promise<NewsEdge>, Fragmentable {
  node: <T = NewsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NewsEdgeSubscription
  extends Promise<AsyncIterator<NewsEdge>>,
    Fragmentable {
  node: <T = NewsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNews {
  count: Int;
}

export interface AggregateNewsPromise
  extends Promise<AggregateNews>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNewsSubscription
  extends Promise<AsyncIterator<AggregateNews>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NoteConnection {
  pageInfo: PageInfo;
  edges: NoteEdge[];
}

export interface NoteConnectionPromise
  extends Promise<NoteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NoteEdge>>() => T;
  aggregate: <T = AggregateNotePromise>() => T;
}

export interface NoteConnectionSubscription
  extends Promise<AsyncIterator<NoteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NoteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNoteSubscription>() => T;
}

export interface NoteEdge {
  node: Note;
  cursor: String;
}

export interface NoteEdgePromise extends Promise<NoteEdge>, Fragmentable {
  node: <T = NotePromise>() => T;
  cursor: () => Promise<String>;
}

export interface NoteEdgeSubscription
  extends Promise<AsyncIterator<NoteEdge>>,
    Fragmentable {
  node: <T = NoteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNote {
  count: Int;
}

export interface AggregateNotePromise
  extends Promise<AggregateNote>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNoteSubscription
  extends Promise<AsyncIterator<AggregateNote>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ParagraphConnection {
  pageInfo: PageInfo;
  edges: ParagraphEdge[];
}

export interface ParagraphConnectionPromise
  extends Promise<ParagraphConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ParagraphEdge>>() => T;
  aggregate: <T = AggregateParagraphPromise>() => T;
}

export interface ParagraphConnectionSubscription
  extends Promise<AsyncIterator<ParagraphConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ParagraphEdgeSubscription>>>() => T;
  aggregate: <T = AggregateParagraphSubscription>() => T;
}

export interface ParagraphEdge {
  node: Paragraph;
  cursor: String;
}

export interface ParagraphEdgePromise
  extends Promise<ParagraphEdge>,
    Fragmentable {
  node: <T = ParagraphPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ParagraphEdgeSubscription
  extends Promise<AsyncIterator<ParagraphEdge>>,
    Fragmentable {
  node: <T = ParagraphSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateParagraph {
  count: Int;
}

export interface AggregateParagraphPromise
  extends Promise<AggregateParagraph>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateParagraphSubscription
  extends Promise<AsyncIterator<AggregateParagraph>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PermissionConnection {
  pageInfo: PageInfo;
  edges: PermissionEdge[];
}

export interface PermissionConnectionPromise
  extends Promise<PermissionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PermissionEdge>>() => T;
  aggregate: <T = AggregatePermissionPromise>() => T;
}

export interface PermissionConnectionSubscription
  extends Promise<AsyncIterator<PermissionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PermissionEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePermissionSubscription>() => T;
}

export interface PermissionEdge {
  node: Permission;
  cursor: String;
}

export interface PermissionEdgePromise
  extends Promise<PermissionEdge>,
    Fragmentable {
  node: <T = PermissionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PermissionEdgeSubscription
  extends Promise<AsyncIterator<PermissionEdge>>,
    Fragmentable {
  node: <T = PermissionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePermission {
  count: Int;
}

export interface AggregatePermissionPromise
  extends Promise<AggregatePermission>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePermissionSubscription
  extends Promise<AsyncIterator<AggregatePermission>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PermissionTypeConnection {
  pageInfo: PageInfo;
  edges: PermissionTypeEdge[];
}

export interface PermissionTypeConnectionPromise
  extends Promise<PermissionTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PermissionTypeEdge>>() => T;
  aggregate: <T = AggregatePermissionTypePromise>() => T;
}

export interface PermissionTypeConnectionSubscription
  extends Promise<AsyncIterator<PermissionTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PermissionTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePermissionTypeSubscription>() => T;
}

export interface PermissionTypeEdge {
  node: PermissionType;
  cursor: String;
}

export interface PermissionTypeEdgePromise
  extends Promise<PermissionTypeEdge>,
    Fragmentable {
  node: <T = PermissionTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PermissionTypeEdgeSubscription
  extends Promise<AsyncIterator<PermissionTypeEdge>>,
    Fragmentable {
  node: <T = PermissionTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePermissionType {
  count: Int;
}

export interface AggregatePermissionTypePromise
  extends Promise<AggregatePermissionType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePermissionTypeSubscription
  extends Promise<AsyncIterator<AggregatePermissionType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Post {
  id: UUID;
  title: String;
  published: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  validUntil: DateTimeOutput;
  meta?: Json;
}

export interface PostPromise extends Promise<Post>, Fragmentable {
  id: () => Promise<UUID>;
  title: () => Promise<String>;
  published: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  validUntil: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
  banner: <T = FragmentableArray<Image>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<Json>;
}

export interface PostSubscription
  extends Promise<AsyncIterator<Post>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  title: () => Promise<AsyncIterator<String>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  validUntil: () => Promise<AsyncIterator<DateTimeOutput>>;
  author: <T = UserSubscription>() => T;
  banner: <T = Promise<AsyncIterator<ImageSubscription>>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface PostNullablePromise
  extends Promise<Post | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  title: () => Promise<String>;
  published: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  validUntil: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
  banner: <T = FragmentableArray<Image>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<Json>;
}

export interface Tag {
  id: ID_Output;
  name: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  meta?: Json;
}

export interface TagPromise extends Promise<Tag>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  meta: () => Promise<Json>;
}

export interface TagSubscription
  extends Promise<AsyncIterator<Tag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface TagNullablePromise extends Promise<Tag | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  meta: () => Promise<Json>;
}

export interface PostConnection {
  pageInfo: PageInfo;
  edges: PostEdge[];
}

export interface PostConnectionPromise
  extends Promise<PostConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostEdge>>() => T;
  aggregate: <T = AggregatePostPromise>() => T;
}

export interface PostConnectionSubscription
  extends Promise<AsyncIterator<PostConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostSubscription>() => T;
}

export interface PostEdge {
  node: Post;
  cursor: String;
}

export interface PostEdgePromise extends Promise<PostEdge>, Fragmentable {
  node: <T = PostPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostEdgeSubscription
  extends Promise<AsyncIterator<PostEdge>>,
    Fragmentable {
  node: <T = PostSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePost {
  count: Int;
}

export interface AggregatePostPromise
  extends Promise<AggregatePost>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostSubscription
  extends Promise<AsyncIterator<AggregatePost>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Property {
  id: UUID;
  propertyId: String;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
  meta?: Json;
}

export interface PropertyPromise extends Promise<Property>, Fragmentable {
  id: () => Promise<UUID>;
  propertyId: () => Promise<String>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  i18n: <T = FragmentableArray<i18n>>(args?: {
    where?: i18nWhereInput;
    orderBy?: i18nOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  logs: <T = FragmentableArray<Log>>(args?: {
    where?: LogWhereInput;
    orderBy?: LogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<Json>;
}

export interface PropertySubscription
  extends Promise<AsyncIterator<Property>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  propertyId: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  i18n: <T = Promise<AsyncIterator<i18nSubscription>>>(args?: {
    where?: i18nWhereInput;
    orderBy?: i18nOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  logs: <T = Promise<AsyncIterator<LogSubscription>>>(args?: {
    where?: LogWhereInput;
    orderBy?: LogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface PropertyNullablePromise
  extends Promise<Property | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  propertyId: () => Promise<String>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  i18n: <T = FragmentableArray<i18n>>(args?: {
    where?: i18nWhereInput;
    orderBy?: i18nOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  logs: <T = FragmentableArray<Log>>(args?: {
    where?: LogWhereInput;
    orderBy?: LogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  meta: () => Promise<Json>;
}

export interface PropertyConnection {
  pageInfo: PageInfo;
  edges: PropertyEdge[];
}

export interface PropertyConnectionPromise
  extends Promise<PropertyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PropertyEdge>>() => T;
  aggregate: <T = AggregatePropertyPromise>() => T;
}

export interface PropertyConnectionSubscription
  extends Promise<AsyncIterator<PropertyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PropertyEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePropertySubscription>() => T;
}

export interface PropertyEdge {
  node: Property;
  cursor: String;
}

export interface PropertyEdgePromise
  extends Promise<PropertyEdge>,
    Fragmentable {
  node: <T = PropertyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PropertyEdgeSubscription
  extends Promise<AsyncIterator<PropertyEdge>>,
    Fragmentable {
  node: <T = PropertySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProperty {
  count: Int;
}

export interface AggregatePropertyPromise
  extends Promise<AggregateProperty>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePropertySubscription
  extends Promise<AsyncIterator<AggregateProperty>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuoteConnection {
  pageInfo: PageInfo;
  edges: QuoteEdge[];
}

export interface QuoteConnectionPromise
  extends Promise<QuoteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuoteEdge>>() => T;
  aggregate: <T = AggregateQuotePromise>() => T;
}

export interface QuoteConnectionSubscription
  extends Promise<AsyncIterator<QuoteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuoteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuoteSubscription>() => T;
}

export interface QuoteEdge {
  node: Quote;
  cursor: String;
}

export interface QuoteEdgePromise extends Promise<QuoteEdge>, Fragmentable {
  node: <T = QuotePromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuoteEdgeSubscription
  extends Promise<AsyncIterator<QuoteEdge>>,
    Fragmentable {
  node: <T = QuoteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateQuote {
  count: Int;
}

export interface AggregateQuotePromise
  extends Promise<AggregateQuote>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuoteSubscription
  extends Promise<AsyncIterator<AggregateQuote>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ReplyConnection {
  pageInfo: PageInfo;
  edges: ReplyEdge[];
}

export interface ReplyConnectionPromise
  extends Promise<ReplyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ReplyEdge>>() => T;
  aggregate: <T = AggregateReplyPromise>() => T;
}

export interface ReplyConnectionSubscription
  extends Promise<AsyncIterator<ReplyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ReplyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateReplySubscription>() => T;
}

export interface ReplyEdge {
  node: Reply;
  cursor: String;
}

export interface ReplyEdgePromise extends Promise<ReplyEdge>, Fragmentable {
  node: <T = ReplyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ReplyEdgeSubscription
  extends Promise<AsyncIterator<ReplyEdge>>,
    Fragmentable {
  node: <T = ReplySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateReply {
  count: Int;
}

export interface AggregateReplyPromise
  extends Promise<AggregateReply>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateReplySubscription
  extends Promise<AsyncIterator<AggregateReply>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StatementConnection {
  pageInfo: PageInfo;
  edges: StatementEdge[];
}

export interface StatementConnectionPromise
  extends Promise<StatementConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StatementEdge>>() => T;
  aggregate: <T = AggregateStatementPromise>() => T;
}

export interface StatementConnectionSubscription
  extends Promise<AsyncIterator<StatementConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StatementEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStatementSubscription>() => T;
}

export interface StatementEdge {
  node: Statement;
  cursor: String;
}

export interface StatementEdgePromise
  extends Promise<StatementEdge>,
    Fragmentable {
  node: <T = StatementPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StatementEdgeSubscription
  extends Promise<AsyncIterator<StatementEdge>>,
    Fragmentable {
  node: <T = StatementSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStatement {
  count: Int;
}

export interface AggregateStatementPromise
  extends Promise<AggregateStatement>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStatementSubscription
  extends Promise<AsyncIterator<AggregateStatement>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TagConnection {
  pageInfo: PageInfo;
  edges: TagEdge[];
}

export interface TagConnectionPromise
  extends Promise<TagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TagEdge>>() => T;
  aggregate: <T = AggregateTagPromise>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface TagEdge {
  node: Tag;
  cursor: String;
}

export interface TagEdgePromise extends Promise<TagEdge>, Fragmentable {
  node: <T = TagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription
  extends Promise<AsyncIterator<TagEdge>>,
    Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTag {
  count: Int;
}

export interface AggregateTagPromise
  extends Promise<AggregateTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Theme {
  id: UUID;
  name: String;
  description?: String;
  component?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  meta?: Json;
}

export interface ThemePromise extends Promise<Theme>, Fragmentable {
  id: () => Promise<UUID>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  component: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  meta: () => Promise<Json>;
}

export interface ThemeSubscription
  extends Promise<AsyncIterator<Theme>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  component: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface ThemeNullablePromise
  extends Promise<Theme | null>,
    Fragmentable {
  id: () => Promise<UUID>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  component: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  meta: () => Promise<Json>;
}

export interface ThemeConnection {
  pageInfo: PageInfo;
  edges: ThemeEdge[];
}

export interface ThemeConnectionPromise
  extends Promise<ThemeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ThemeEdge>>() => T;
  aggregate: <T = AggregateThemePromise>() => T;
}

export interface ThemeConnectionSubscription
  extends Promise<AsyncIterator<ThemeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ThemeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateThemeSubscription>() => T;
}

export interface ThemeEdge {
  node: Theme;
  cursor: String;
}

export interface ThemeEdgePromise extends Promise<ThemeEdge>, Fragmentable {
  node: <T = ThemePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ThemeEdgeSubscription
  extends Promise<AsyncIterator<ThemeEdge>>,
    Fragmentable {
  node: <T = ThemeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTheme {
  count: Int;
}

export interface AggregateThemePromise
  extends Promise<AggregateTheme>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateThemeSubscription
  extends Promise<AsyncIterator<AggregateTheme>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface i18nConnection {
  pageInfo: PageInfo;
  edges: i18nEdge[];
}

export interface i18nConnectionPromise
  extends Promise<i18nConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<i18nEdge>>() => T;
  aggregate: <T = Aggregatei18nPromise>() => T;
}

export interface i18nConnectionSubscription
  extends Promise<AsyncIterator<i18nConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<i18nEdgeSubscription>>>() => T;
  aggregate: <T = Aggregatei18nSubscription>() => T;
}

export interface i18nEdge {
  node: i18n;
  cursor: String;
}

export interface i18nEdgePromise extends Promise<i18nEdge>, Fragmentable {
  node: <T = i18nPromise>() => T;
  cursor: () => Promise<String>;
}

export interface i18nEdgeSubscription
  extends Promise<AsyncIterator<i18nEdge>>,
    Fragmentable {
  node: <T = i18nSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Aggregatei18n {
  count: Int;
}

export interface Aggregatei18nPromise
  extends Promise<Aggregatei18n>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface Aggregatei18nSubscription
  extends Promise<AsyncIterator<Aggregatei18n>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AccessSubscriptionPayload {
  mutation: MutationType;
  node: Access;
  updatedFields: String[];
  previousValues: AccessPreviousValues;
}

export interface AccessSubscriptionPayloadPromise
  extends Promise<AccessSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AccessPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AccessPreviousValuesPromise>() => T;
}

export interface AccessSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AccessSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AccessSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AccessPreviousValuesSubscription>() => T;
}

export interface AccessPreviousValues {
  id: UUID;
  read: Boolean;
  write: Boolean;
  delete: Boolean;
}

export interface AccessPreviousValuesPromise
  extends Promise<AccessPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  read: () => Promise<Boolean>;
  write: () => Promise<Boolean>;
  delete: () => Promise<Boolean>;
}

export interface AccessPreviousValuesSubscription
  extends Promise<AsyncIterator<AccessPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  read: () => Promise<AsyncIterator<Boolean>>;
  write: () => Promise<AsyncIterator<Boolean>>;
  delete: () => Promise<AsyncIterator<Boolean>>;
}

export interface EventSubscriptionPayload {
  mutation: MutationType;
  node: Event;
  updatedFields: String[];
  previousValues: EventPreviousValues;
}

export interface EventSubscriptionPayloadPromise
  extends Promise<EventSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EventPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EventPreviousValuesPromise>() => T;
}

export interface EventSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EventSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EventSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EventPreviousValuesSubscription>() => T;
}

export interface EventPreviousValues {
  id: UUID;
  type: EventType;
  result?: String;
  timemark: DateTimeOutput;
  meta?: Json;
}

export interface EventPreviousValuesPromise
  extends Promise<EventPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  type: () => Promise<EventType>;
  result: () => Promise<String>;
  timemark: () => Promise<DateTimeOutput>;
  meta: () => Promise<Json>;
}

export interface EventPreviousValuesSubscription
  extends Promise<AsyncIterator<EventPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  type: () => Promise<AsyncIterator<EventType>>;
  result: () => Promise<AsyncIterator<String>>;
  timemark: () => Promise<AsyncIterator<DateTimeOutput>>;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface FileSubscriptionPayload {
  mutation: MutationType;
  node: File;
  updatedFields: String[];
  previousValues: FilePreviousValues;
}

export interface FileSubscriptionPayloadPromise
  extends Promise<FileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FilePreviousValuesPromise>() => T;
}

export interface FileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FilePreviousValuesSubscription>() => T;
}

export interface FilePreviousValues {
  id: UUID;
  name: String;
  path: String;
  size: Float;
  hidden: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  meta?: Json;
}

export interface FilePreviousValuesPromise
  extends Promise<FilePreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  name: () => Promise<String>;
  path: () => Promise<String>;
  size: () => Promise<Float>;
  hidden: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  meta: () => Promise<Json>;
}

export interface FilePreviousValuesSubscription
  extends Promise<AsyncIterator<FilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  name: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  size: () => Promise<AsyncIterator<Float>>;
  hidden: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface GroupSubscriptionPayload {
  mutation: MutationType;
  node: Group;
  updatedFields: String[];
  previousValues: GroupPreviousValues;
}

export interface GroupSubscriptionPayloadPromise
  extends Promise<GroupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GroupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GroupPreviousValuesPromise>() => T;
}

export interface GroupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GroupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GroupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GroupPreviousValuesSubscription>() => T;
}

export interface GroupPreviousValues {
  id: UUID;
  name: String;
  description?: String;
  meta?: Json;
}

export interface GroupPreviousValuesPromise
  extends Promise<GroupPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  meta: () => Promise<Json>;
}

export interface GroupPreviousValuesSubscription
  extends Promise<AsyncIterator<GroupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface ImageSubscriptionPayload {
  mutation: MutationType;
  node: Image;
  updatedFields: String[];
  previousValues: ImagePreviousValues;
}

export interface ImageSubscriptionPayloadPromise
  extends Promise<ImageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ImagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ImagePreviousValuesPromise>() => T;
}

export interface ImageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ImageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ImageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ImagePreviousValuesSubscription>() => T;
}

export interface ImagePreviousValues {
  id: UUID;
  name: String;
  description?: String;
  meta?: Json;
}

export interface ImagePreviousValuesPromise
  extends Promise<ImagePreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  meta: () => Promise<Json>;
}

export interface ImagePreviousValuesSubscription
  extends Promise<AsyncIterator<ImagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface ItemSubscriptionPayload {
  mutation: MutationType;
  node: Item;
  updatedFields: String[];
  previousValues: ItemPreviousValues;
}

export interface ItemSubscriptionPayloadPromise
  extends Promise<ItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ItemPreviousValuesPromise>() => T;
}

export interface ItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ItemPreviousValuesSubscription>() => T;
}

export interface ItemPreviousValues {
  id: UUID;
  itemId: String;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  meta?: Json;
}

export interface ItemPreviousValuesPromise
  extends Promise<ItemPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  itemId: () => Promise<String>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  meta: () => Promise<Json>;
}

export interface ItemPreviousValuesSubscription
  extends Promise<AsyncIterator<ItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  itemId: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface LangSubscriptionPayload {
  mutation: MutationType;
  node: Lang;
  updatedFields: String[];
  previousValues: LangPreviousValues;
}

export interface LangSubscriptionPayloadPromise
  extends Promise<LangSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LangPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LangPreviousValuesPromise>() => T;
}

export interface LangSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LangSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LangSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LangPreviousValuesSubscription>() => T;
}

export interface LangPreviousValues {
  id: UUID;
  code: String;
  langName: String;
  meta?: Json;
}

export interface LangPreviousValuesPromise
  extends Promise<LangPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  code: () => Promise<String>;
  langName: () => Promise<String>;
  meta: () => Promise<Json>;
}

export interface LangPreviousValuesSubscription
  extends Promise<AsyncIterator<LangPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  code: () => Promise<AsyncIterator<String>>;
  langName: () => Promise<AsyncIterator<String>>;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface LogSubscriptionPayload {
  mutation: MutationType;
  node: Log;
  updatedFields: String[];
  previousValues: LogPreviousValues;
}

export interface LogSubscriptionPayloadPromise
  extends Promise<LogSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LogPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LogPreviousValuesPromise>() => T;
}

export interface LogSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LogSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LogSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LogPreviousValuesSubscription>() => T;
}

export interface LogPreviousValues {
  id: UUID;
  ip: String;
  meta?: Json;
}

export interface LogPreviousValuesPromise
  extends Promise<LogPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  ip: () => Promise<String>;
  meta: () => Promise<Json>;
}

export interface LogPreviousValuesSubscription
  extends Promise<AsyncIterator<LogPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  ip: () => Promise<AsyncIterator<String>>;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface MarkupSubscriptionPayload {
  mutation: MutationType;
  node: Markup;
  updatedFields: String[];
  previousValues: MarkupPreviousValues;
}

export interface MarkupSubscriptionPayloadPromise
  extends Promise<MarkupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MarkupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MarkupPreviousValuesPromise>() => T;
}

export interface MarkupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MarkupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MarkupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MarkupPreviousValuesSubscription>() => T;
}

export interface MarkupPreviousValues {
  id: UUID;
  type: MarkupType;
  start?: Int;
  end?: Int;
  href?: String;
  rel?: String;
  src?: String;
  title?: String;
  meta?: Json;
}

export interface MarkupPreviousValuesPromise
  extends Promise<MarkupPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  type: () => Promise<MarkupType>;
  start: () => Promise<Int>;
  end: () => Promise<Int>;
  href: () => Promise<String>;
  rel: () => Promise<String>;
  src: () => Promise<String>;
  title: () => Promise<String>;
  meta: () => Promise<Json>;
}

export interface MarkupPreviousValuesSubscription
  extends Promise<AsyncIterator<MarkupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  type: () => Promise<AsyncIterator<MarkupType>>;
  start: () => Promise<AsyncIterator<Int>>;
  end: () => Promise<AsyncIterator<Int>>;
  href: () => Promise<AsyncIterator<String>>;
  rel: () => Promise<AsyncIterator<String>>;
  src: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface MeasurementSubscriptionPayload {
  mutation: MutationType;
  node: Measurement;
  updatedFields: String[];
  previousValues: MeasurementPreviousValues;
}

export interface MeasurementSubscriptionPayloadPromise
  extends Promise<MeasurementSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MeasurementPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MeasurementPreviousValuesPromise>() => T;
}

export interface MeasurementSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MeasurementSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MeasurementSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MeasurementPreviousValuesSubscription>() => T;
}

export interface MeasurementPreviousValues {
  id: UUID;
  height: Float;
  width: Float;
}

export interface MeasurementPreviousValuesPromise
  extends Promise<MeasurementPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  height: () => Promise<Float>;
  width: () => Promise<Float>;
}

export interface MeasurementPreviousValuesSubscription
  extends Promise<AsyncIterator<MeasurementPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  height: () => Promise<AsyncIterator<Float>>;
  width: () => Promise<AsyncIterator<Float>>;
}

export interface NewsSubscriptionPayload {
  mutation: MutationType;
  node: News;
  updatedFields: String[];
  previousValues: NewsPreviousValues;
}

export interface NewsSubscriptionPayloadPromise
  extends Promise<NewsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NewsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NewsPreviousValuesPromise>() => T;
}

export interface NewsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NewsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NewsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NewsPreviousValuesSubscription>() => T;
}

export interface NewsPreviousValues {
  id: UUID;
  title: String;
  published: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  validUntil: DateTimeOutput;
  meta?: Json;
}

export interface NewsPreviousValuesPromise
  extends Promise<NewsPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  title: () => Promise<String>;
  published: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  validUntil: () => Promise<DateTimeOutput>;
  meta: () => Promise<Json>;
}

export interface NewsPreviousValuesSubscription
  extends Promise<AsyncIterator<NewsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  title: () => Promise<AsyncIterator<String>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  validUntil: () => Promise<AsyncIterator<DateTimeOutput>>;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface NoteSubscriptionPayload {
  mutation: MutationType;
  node: Note;
  updatedFields: String[];
  previousValues: NotePreviousValues;
}

export interface NoteSubscriptionPayloadPromise
  extends Promise<NoteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NotePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NotePreviousValuesPromise>() => T;
}

export interface NoteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NoteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NoteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NotePreviousValuesSubscription>() => T;
}

export interface NotePreviousValues {
  id: UUID;
  content?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  meta?: Json;
}

export interface NotePreviousValuesPromise
  extends Promise<NotePreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  meta: () => Promise<Json>;
}

export interface NotePreviousValuesSubscription
  extends Promise<AsyncIterator<NotePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface ParagraphSubscriptionPayload {
  mutation: MutationType;
  node: Paragraph;
  updatedFields: String[];
  previousValues: ParagraphPreviousValues;
}

export interface ParagraphSubscriptionPayloadPromise
  extends Promise<ParagraphSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ParagraphPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ParagraphPreviousValuesPromise>() => T;
}

export interface ParagraphSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ParagraphSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ParagraphSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ParagraphPreviousValuesSubscription>() => T;
}

export interface ParagraphPreviousValues {
  id: UUID;
  index: Int;
  text?: String;
  type?: ParagraphType;
  meta?: Json;
}

export interface ParagraphPreviousValuesPromise
  extends Promise<ParagraphPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  index: () => Promise<Int>;
  text: () => Promise<String>;
  type: () => Promise<ParagraphType>;
  meta: () => Promise<Json>;
}

export interface ParagraphPreviousValuesSubscription
  extends Promise<AsyncIterator<ParagraphPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  index: () => Promise<AsyncIterator<Int>>;
  text: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<ParagraphType>>;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface PermissionSubscriptionPayload {
  mutation: MutationType;
  node: Permission;
  updatedFields: String[];
  previousValues: PermissionPreviousValues;
}

export interface PermissionSubscriptionPayloadPromise
  extends Promise<PermissionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PermissionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PermissionPreviousValuesPromise>() => T;
}

export interface PermissionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PermissionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PermissionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PermissionPreviousValuesSubscription>() => T;
}

export interface PermissionPreviousValues {
  id: UUID;
  type: String;
  loginAdmin: Boolean;
  meta?: Json;
}

export interface PermissionPreviousValuesPromise
  extends Promise<PermissionPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  type: () => Promise<String>;
  loginAdmin: () => Promise<Boolean>;
  meta: () => Promise<Json>;
}

export interface PermissionPreviousValuesSubscription
  extends Promise<AsyncIterator<PermissionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  type: () => Promise<AsyncIterator<String>>;
  loginAdmin: () => Promise<AsyncIterator<Boolean>>;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface PermissionTypeSubscriptionPayload {
  mutation: MutationType;
  node: PermissionType;
  updatedFields: String[];
  previousValues: PermissionTypePreviousValues;
}

export interface PermissionTypeSubscriptionPayloadPromise
  extends Promise<PermissionTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PermissionTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PermissionTypePreviousValuesPromise>() => T;
}

export interface PermissionTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PermissionTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PermissionTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PermissionTypePreviousValuesSubscription>() => T;
}

export interface PermissionTypePreviousValues {
  id: UUID;
}

export interface PermissionTypePreviousValuesPromise
  extends Promise<PermissionTypePreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
}

export interface PermissionTypePreviousValuesSubscription
  extends Promise<AsyncIterator<PermissionTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
}

export interface PostSubscriptionPayload {
  mutation: MutationType;
  node: Post;
  updatedFields: String[];
  previousValues: PostPreviousValues;
}

export interface PostSubscriptionPayloadPromise
  extends Promise<PostSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostPreviousValuesPromise>() => T;
}

export interface PostSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostPreviousValuesSubscription>() => T;
}

export interface PostPreviousValues {
  id: UUID;
  title: String;
  published: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  validUntil: DateTimeOutput;
  meta?: Json;
}

export interface PostPreviousValuesPromise
  extends Promise<PostPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  title: () => Promise<String>;
  published: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  validUntil: () => Promise<DateTimeOutput>;
  meta: () => Promise<Json>;
}

export interface PostPreviousValuesSubscription
  extends Promise<AsyncIterator<PostPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  title: () => Promise<AsyncIterator<String>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  validUntil: () => Promise<AsyncIterator<DateTimeOutput>>;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface PropertySubscriptionPayload {
  mutation: MutationType;
  node: Property;
  updatedFields: String[];
  previousValues: PropertyPreviousValues;
}

export interface PropertySubscriptionPayloadPromise
  extends Promise<PropertySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PropertyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PropertyPreviousValuesPromise>() => T;
}

export interface PropertySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PropertySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PropertySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PropertyPreviousValuesSubscription>() => T;
}

export interface PropertyPreviousValues {
  id: UUID;
  propertyId: String;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
  meta?: Json;
}

export interface PropertyPreviousValuesPromise
  extends Promise<PropertyPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  propertyId: () => Promise<String>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  meta: () => Promise<Json>;
}

export interface PropertyPreviousValuesSubscription
  extends Promise<AsyncIterator<PropertyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  propertyId: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface QuoteSubscriptionPayload {
  mutation: MutationType;
  node: Quote;
  updatedFields: String[];
  previousValues: QuotePreviousValues;
}

export interface QuoteSubscriptionPayloadPromise
  extends Promise<QuoteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuotePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuotePreviousValuesPromise>() => T;
}

export interface QuoteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuoteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuoteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuotePreviousValuesSubscription>() => T;
}

export interface QuotePreviousValues {
  id: UUID;
  start: Int;
  end: Int;
  type: QuoteType;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  meta?: Json;
}

export interface QuotePreviousValuesPromise
  extends Promise<QuotePreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  start: () => Promise<Int>;
  end: () => Promise<Int>;
  type: () => Promise<QuoteType>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  meta: () => Promise<Json>;
}

export interface QuotePreviousValuesSubscription
  extends Promise<AsyncIterator<QuotePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  start: () => Promise<AsyncIterator<Int>>;
  end: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<QuoteType>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface ReplySubscriptionPayload {
  mutation: MutationType;
  node: Reply;
  updatedFields: String[];
  previousValues: ReplyPreviousValues;
}

export interface ReplySubscriptionPayloadPromise
  extends Promise<ReplySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ReplyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ReplyPreviousValuesPromise>() => T;
}

export interface ReplySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ReplySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ReplySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ReplyPreviousValuesSubscription>() => T;
}

export interface ReplyPreviousValues {
  id: UUID;
  replyId: Int;
  content: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  meta?: Json;
}

export interface ReplyPreviousValuesPromise
  extends Promise<ReplyPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  replyId: () => Promise<Int>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  meta: () => Promise<Json>;
}

export interface ReplyPreviousValuesSubscription
  extends Promise<AsyncIterator<ReplyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  replyId: () => Promise<AsyncIterator<Int>>;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface StatementSubscriptionPayload {
  mutation: MutationType;
  node: Statement;
  updatedFields: String[];
  previousValues: StatementPreviousValues;
}

export interface StatementSubscriptionPayloadPromise
  extends Promise<StatementSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StatementPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StatementPreviousValuesPromise>() => T;
}

export interface StatementSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StatementSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StatementSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StatementPreviousValuesSubscription>() => T;
}

export interface StatementPreviousValues {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  value: String;
  meta?: Json;
}

export interface StatementPreviousValuesPromise
  extends Promise<StatementPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  value: () => Promise<String>;
  meta: () => Promise<Json>;
}

export interface StatementPreviousValuesSubscription
  extends Promise<AsyncIterator<StatementPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  value: () => Promise<AsyncIterator<String>>;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface TagSubscriptionPayload {
  mutation: MutationType;
  node: Tag;
  updatedFields: String[];
  previousValues: TagPreviousValues;
}

export interface TagSubscriptionPayloadPromise
  extends Promise<TagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValuesPromise>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface TagPreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  meta?: Json;
}

export interface TagPreviousValuesPromise
  extends Promise<TagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  meta: () => Promise<Json>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface ThemeSubscriptionPayload {
  mutation: MutationType;
  node: Theme;
  updatedFields: String[];
  previousValues: ThemePreviousValues;
}

export interface ThemeSubscriptionPayloadPromise
  extends Promise<ThemeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ThemePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ThemePreviousValuesPromise>() => T;
}

export interface ThemeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ThemeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ThemeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ThemePreviousValuesSubscription>() => T;
}

export interface ThemePreviousValues {
  id: UUID;
  name: String;
  description?: String;
  component?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  meta?: Json;
}

export interface ThemePreviousValuesPromise
  extends Promise<ThemePreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  component: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  meta: () => Promise<Json>;
}

export interface ThemePreviousValuesSubscription
  extends Promise<AsyncIterator<ThemePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  component: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: UUID;
  userName: String;
  email: String;
  firstName?: String;
  lastName?: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  meta?: Json;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  userName: () => Promise<String>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  meta: () => Promise<Json>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  userName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  meta: () => Promise<AsyncIterator<Json>>;
}

export interface i18nSubscriptionPayload {
  mutation: MutationType;
  node: i18n;
  updatedFields: String[];
  previousValues: i18nPreviousValues;
}

export interface i18nSubscriptionPayloadPromise
  extends Promise<i18nSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = i18nPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = i18nPreviousValuesPromise>() => T;
}

export interface i18nSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<i18nSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = i18nSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = i18nPreviousValuesSubscription>() => T;
}

export interface i18nPreviousValues {
  id: UUID;
  text?: String;
  meta?: Json;
}

export interface i18nPreviousValuesPromise
  extends Promise<i18nPreviousValues>,
    Fragmentable {
  id: () => Promise<UUID>;
  text: () => Promise<String>;
  meta: () => Promise<Json>;
}

export interface i18nPreviousValuesSubscription
  extends Promise<AsyncIterator<i18nPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  text: () => Promise<AsyncIterator<String>>;
  meta: () => Promise<AsyncIterator<Json>>;
}

export type UUID = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Json = any;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "EventType",
    embedded: false
  },
  {
    name: "Event",
    embedded: false
  },
  {
    name: "Log",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Group",
    embedded: false
  },
  {
    name: "Access",
    embedded: false
  },
  {
    name: "PermissionType",
    embedded: false
  },
  {
    name: "Permission",
    embedded: false
  },
  {
    name: "i18n",
    embedded: false
  },
  {
    name: "Lang",
    embedded: false
  },
  {
    name: "File",
    embedded: false
  },
  {
    name: "Measurement",
    embedded: false
  },
  {
    name: "Image",
    embedded: false
  },
  {
    name: "Item",
    embedded: false
  },
  {
    name: "Property",
    embedded: false
  },
  {
    name: "Statement",
    embedded: false
  },
  {
    name: "ParagraphType",
    embedded: false
  },
  {
    name: "Paragraph",
    embedded: false
  },
  {
    name: "MarkupType",
    embedded: false
  },
  {
    name: "Markup",
    embedded: false
  },
  {
    name: "QuoteType",
    embedded: false
  },
  {
    name: "Quote",
    embedded: false
  },
  {
    name: "Reply",
    embedded: false
  },
  {
    name: "Note",
    embedded: false
  },
  {
    name: "News",
    embedded: false
  },
  {
    name: "Post",
    embedded: false
  },
  {
    name: "Tag",
    embedded: false
  },
  {
    name: "Theme",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
